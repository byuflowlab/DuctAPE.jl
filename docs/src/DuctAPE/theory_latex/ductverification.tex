
\section{Verification of Full Solver Implementations in DuctAPE}
\label{ssec:verification}

As we have established, the methodology behind DuctAPE is based heavily on DFDC.
%
Therefore, we take the opportunity to provide a set of comparisons between DuctAPE and DFDC.
%
We compared an example available in the DFDC source code using a single ducted rotor across a range of operating conditions, specifically across a range of advance ratios including a hover condition.

The geometry used in the single ducted rotor example case is shown in \cref{fig:singlerotorgeom}.
%
For this verification case, we used a rotor with tip radius of 0.15572 meters located 0.12 meters aft of the center body leading edge.
%
The wake extended 0.8 times the length of the duct (roughly 0.3 meters) past the duct trailing edge.
%
We used 10 blade elements associated with 11 wake sheets to model the rotor.
%
We set the rotor rotation rate constant at 8000 revolutions per minute and adjust the freestream velocity in order to sweep across advance ratios from 0.0 to 2.0 by increments of 0.1.
%
We assumed sea level conditions for reference values.

\begin{figure}[h!]
     \centering
% \tikzsetnextfilename{solvers/ductape_single_rotor_geometry}
     \input{figures/ductape_single_rotor_geometry.tikz}\hspace*{5em}
     \caption{Single rotor verification case geometry generated by DuctAPE. Duct geometry in \primary{blue}, center body geometry in \secondary{red}, rotor lifting line location in \tertiary{green}, and wake grid geometry in \gray{gray}.}
    \label{fig:singlerotorgeom}
\end{figure}

\begin{figure}[h!]
     \centering
% \tikzsetnextfilename{solvers/dfdc_single_rotor_geometry}
     \begin{subfigure}[t]{\textwidth}
         \centering
         \subcaptionbox{DFDC generated geometry.\label{fig:dfdcsinglerotorgeom}}{%
             \input{figures/dfdc_single_rotor_geometry.tikz}\hspace*{5em}
     }\qquad
     \end{subfigure}

     \begin{subfigure}[t]{\textwidth}
         \centering
% \tikzsetnextfilename{solvers/ductape_single_rotor_geometry}
         \subcaptionbox{DuctAPE generated geometry.\label{fig:ductapesinglerotorgeom}}{%
             \input{figures/ductape_single_rotor_geometry.tikz}\hspace*{5em}
     }\qquad
     \end{subfigure}
     \caption{Single rotor verification case geometry as generated by DFDC and DuctAPE. Duct geometry in \primary{blue}, center body geometry in \secondary{red}, rotor lifting line location in \tertiary{green}, and wake grid geometry in \gray{gray}.}
    \label{fig:singlerotorgeom}
\end{figure}


We note here that DuctAPE also differs from DFDC in the geometry re-paneling approach.
%
The reason for a different approach to geometry generation in DuctAPE is so that the duct, center body, and wake can be paneled in such a way to avoid discontinuities in gradients if the relative position of the rotors, duct, and center body were to change in an optimization setting.
%
Comparing the subfigures of \cref{fig:singlerotorgeom} we see two major differences between the DFDC generated geometry (\cref{fig:dfdcsinglerotorgeom}) and the DuctAPE generated geometry (\cref{fig:ductapesinglerotorgeom}).
%
The DuctAPE geometry re-paneling approach aligns the duct, center body, and wake panels aft of the rotor and distributes them linearly.
%
We align the panels so that there is a consistent number of panels between discrete locations (such as rotor positions and body trailing edges) in the geometry, thereby avoiding discontinuities.
%
For example, the number of center body and duct panels ahead of and behind the rotor need to stay constant if the rotor position is selected as a design variable in an optimization.
%
Without the number of panels ahead of and behind the rotor staying constant, there would be discontinuities as the rotor passed over panels along the solid bodies.
%
 The second difference in geometries is that DuctAPE does not yet apply any expansion in the wake panel length aft of the duct exit. %TODO; should this be added?
%
 The main reason to apply expansion is to reduce the number of panels in the wake, and thereby reduce the size of the system being solved.
%
 % Not applying an expansion does not affect the solution, and is not yet implemented in DuctAPE (see \cref{sec:conclusions}), so we simply maintain a linear distribution of panels in the trailing wake.
%
 Also note that the number of panels in the wake needs to stay constant between each discrete location, even aft of the duct exit, in case the duct chord length is selected as a design variable in an optimization.
%
 One additional difference, not visible, is that the duct and center body geometries are defined counter-clockwise for DFDC and clockwise for DuctAPE, which simply led to some differences in sign (compared to the DFDC implementation) in the various induced velocity equations presented above.

As we are comparing the performance of solvers using the DFDC-like CSOR approach and our alternate approach, we verify here that both implementations match values from the original Fortran implementation of DFDC.
%
Scanning \cref{tab:hovercompsinglerotor,tab:cruisecompsinglerotor}, we see that the differences between DFDC and both approaches implemented in DuctAPE are less than 0.5\% for major output values for both a hover and a cruise case.
%
\Cref{fig:singlerotorcpcteta} shows comparisons of total thrust and power coefficients (\cref{fig:singlerotorcpct}) and total efficiency (\cref{fig:singlerotoreta}), across the range of advance ratios, showing excellent matching across the entire range.
%
Note that the results for both the DFDC-like solver and alternate DuctAPE solver yield identical plots, so we include only one here.

\begin{table}[h!]
    \caption{Comparison of solver outputs for hover case (\(J=0.0\)). Errors relative to DFDC.}
    \begin{subtable}[t]{0.35\textwidth}
        \begin{center}
            \input{figures/single_rotor_J0_verification_table_CSOR.tex}
        \end{center}
    \end{subtable}

    \begin{subtable}[t]{0.45\textwidth}
        \begin{center}
            \input{figures/single_rotor_J0_verification_table_DuctAPE.tex}
        \end{center}
    \end{subtable}
    \label{tab:hovercompsinglerotor}
\end{table}

\begin{table}[h!]
    \caption{Comparison of solver outputs for a cruise case (\(J=1.0\)). Errors relative to DFDC.}
    \begin{subtable}[t]{0.35\textwidth}
        \begin{center}
            \input{figures/single_rotor_J1_verification_table_CSOR.tex}
        \end{center}
    \end{subtable}

    \begin{subtable}[t]{0.45\textwidth}
        \begin{center}
            \input{figures/single_rotor_J1_verification_table_DuctAPE.tex}
        \end{center}
    \end{subtable}
    \label{tab:cruisecompsinglerotor}
\end{table}

\begin{figure}[h!]
     \centering
     \begin{subfigure}[t]{0.45\textwidth}
         \centering
% \tikzsetnextfilename{solvers/single_rotor_cpct_comparison_CSOR}
        \input{figures/single_rotor_cpct_comparison_CSOR.tikz}
        \caption{Power and thrust comparison.}
        \label{fig:singlerotorcpct}
     \end{subfigure}
\hfill
     \begin{subfigure}[t]{0.45\textwidth}
         \centering
% \tikzsetnextfilename{solvers/single_rotor_efficiency_comparison_CSOR}
         \input{figures/single_rotor_efficiency_comparison_CSOR.tikz}
         \caption{Efficiency comparison.}
        \label{fig:singlerotoreta}
     \end{subfigure}
    \caption{Comparison of power and thrust coefficients and efficiency for DFDC (dashed) and the DuctAPE implementations (solid) across a range of advance ratios.}
    \label{fig:singlerotorcpcteta}
\end{figure}


\begin{figure}[h!]
     \centering
     \begin{subfigure}[t]{0.45\textwidth}
         \centering
% \tikzsetnextfilename{solvers/single_rotor_cpct_comparison_DuctAPE}
        \input{figures/single_rotor_cpct_comparison_DuctAPE.tikz}
        \caption{Power and Thrust Comparison.}
        \label{fig:singlerotorcpct}
     \end{subfigure}
\hfill
     \begin{subfigure}[t]{0.45\textwidth}
         \centering
% \tikzsetnextfilename{solvers/single_rotor_efficiency_comparison_DuctAPE}
         \input{figures/single_rotor_efficiency_comparison_DuctAPE.tikz}
         \caption{Efficiency comparison.}
        \label{fig:singlerotoreta}
     \end{subfigure}
    \caption{Comparison of power and thrust coefficients and efficiency for DFDC (dashed) and DuctAPE (solid) across a range of advance ratios.}
    \label{fig:singlerotorcpcteta}
\end{figure}

\subsection{Benchmarking Solver Implementations}
\label{ssec:benchmarking}

Now that we have shown that both solve approaches yield nearly identical results, we show a comparison in solver efficiency.
%
To do so, we benchmarked various solvers against the CSOR solver.
%
Included in our comparison are the following external solvers:
%
\begin{itemize}
    \item Fixed-point Solvers
        \begin{itemize}
        \item NLsolve's \scite{Mogensen_2020} Anderson accelerated fixed-point method \scite{Walker_2011}.
        \item SpeedMapping.jl\footnote{\url{https://github.com/NicolasL-S/SpeedMapping.jl}} which uses an alternating cyclic extrapolation algorithm \scite{Lepage_2021}.
        \item Fixedpoint.jl\footnote{\url{https://github.com/francescoalemanno/FixedPoint.jl}} which is a Nesterov accelerated fixed-point method.
        \end{itemize}
    \item Quasi-Newton Solvers
        \begin{itemize}
            \item The modified Powell Method \scite{Powell_1970} implemented in MINPACK's HYBRJ method,\footnote{\url{https://www.netlib.org/minpack/}} accessed through the Julia wrapper package, MINPACK.jl\footnote{\url{https://github.com/sglyon/MINPACK.jl}} which wraps a C++ re-write of MINPACK.
        \end{itemize}
    \item Newton Solvers
        \begin{itemize}
        \item NLsolve's Newton method using automatic differentiation for the Jacobian calculation and the Mor\'{e}-Thuente line search method \scite{More_1994} option available through the LineSearches.jl\footnote{\url{https://github.com/JuliaNLSolvers/LineSearches.jl}} package.
        \item The Newton-Raphson method implemented in the SimpleNonlinearSolve.jl package\footnote{\url{https://github.com/SciML/SimpleNonlinearSolve.jl}} \scite{pal2024}.
    \end{itemize}
\end{itemize}
%
\noindent Other than those specifically noted in this list, all solvers were set to use their default settings and given absolute convergence tolerances of 1e-12.


To perform the benchmarks, we used the same geometry and operating points used in \cref{ssec:verification}.
%
For each advance ratio, we used BenchmarkTools.jl\footnote{\url{https://github.com/JuliaCI/BenchmarkTools.jl}}, a benchmarking package in the Julia language, to run 200 samples, then calculated the median computational time across all samples and all advance ratios.
%
We allowed the fixed-point solvers an iteration limit of 1000, the quasi-Newton solvers an iteration limit of 100, and the Newton solvers an iteration limit of 25.
%
These iteration limits were sufficiently large that all solvers were able to converged on every analysis.
%
We also ran each advance ratio one additional time, saving the solve iteration counts and taking the mean number of iterations across the advance ratios in order to determine solver efficiency.
%
% Given the ducted fan design and iteration limits, all the solvers tested had a 100\% convergence rate, though convergence rates drop if iterations are limited further.

\renewcommand{\arraystretch}{1.5}
\begin{table}[h!]
    \caption{
    Comparison of benchmarked solver method median times and mean iterations.
    \primary{Blue} indicates fixed-point solvers, \secondary{red} indicates quasi-Newton solvers, and \tertiary{green} indicates Newton solvers.
    In all cases, except for CSOR Default, the solvers were given absolute convergence criteria of 1e-12.
    (Note that the SimpleNonlinearSolve.jl package does not have any iteration tracing functionality and so that information is missing from this table.)
    }
    \begin{center}
        \input{"figures/benchmark_table.tex"}
    \end{center}
    \label{tab:benchmarkcomp}
\end{table}


\Cref{tab:benchmarkcomp} includes comparisons of the median solve times and mean number of iterations across all advance ratios for each of the benchmarked solvers.
%
From \cref{tab:benchmarkcomp}, we first see that the default DFDC-like CSOR solve approach with loose, relative tolerances was very fast and efficient.
%
We should expect this as the default convergence criteria is between 1e-3 and 2e-4, depending on the residual value. %(see \cref{eqn:convergencecrit}).
%
In contrast, all other solvers were given an absolute convergence tolerance of 1e-12, including the CSOR solver with absolute convergence criteria. % (see \cref{eqn:convergencecritabs}).
%
Therefore, for tight, absolute tolerances, an Anderson accelerated fixed-point solver may be considered in favor of the CSOR solver if speed is the absolute priority, though a much broader set of benchmarks would need to be run before making that a general recommendation.
%
In addition, selecting non-default options for the various solvers may lead to increases in speed or efficiency, again requiring a broader set of benchmarks before general recommendations can be made.
%
That being said, based on these results, further exploration is worth pursuing.


Another important result to notice here is the cost of computing the Jacobian of the residual.
%
Looking at the quasi- and full Newton methods, we see several orders of magnitude increase in time, despite the lower number of overall iterations.
%
As expected, the Jacobian-based methods are more efficient in iterations, but the cost to compute the Jacobian is so high that it outweighs any inherent efficiency of the method.

