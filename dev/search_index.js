var documenterSearchIndex = {"docs":
[{"location":"DuctAPE/api/caches/#Precompiled-Caches","page":"Precompiled Caches","title":"Precompiled Caches","text":"There are several available caches that can be precompiled to help speed up multiple analyses. The first is a cache used for intermediate calculations in the pre- and post-processing phases of the analysis. It can be preallocated using allocate_prepost_container_cache\n\nThe second is a cache containing parameters used in the solver, in other words, the results of the pre-processing phase. It can be preallocated using allocate_solve_parameter_cache.\n\nThe final precompileable cache is for intermediate calculations within the solve and can be preallocated using allocate_solve_container_cache\n\nYou may run all these simultaneously using the initialize_all_caches function.\n\nAs an example of how to run this function, we'll grab solver options and paneling constants from previous examples\n\nusing DuctAPE\nusing LineSearches\n\n# - grab an object of SolverOptionsType defined in a previous example - #\naero_solver_options = DuctAPE.NLsolveOptions(;\n    algorithm=:newton,\n    atol=1e-10,\n    iteration_limit=30,\n    linesearch_method=LineSearches.BackTracking, #don't include parentheses on method handle\n    linesearch_kwargs=(; order=3, maxstep=1e6),\n)\n\n# - grab an object of PanelingConstants type from the Getting Started tutorial - #\nnum_duct_inlet_panels = 30\nnum_center_body_inlet_panels = 30\nnum_panels = [30, 1, 30]\ndte_minus_cbte = -1.0\nnum_wake_sheets = 11\nwake_length = 0.8\n\n# assemble paneling constants\npaneling_constants = DuctAPE.PanelingConstants(\n    num_duct_inlet_panels,\n    num_center_body_inlet_panels,\n    num_panels,\n    dte_minus_cbte,\n    num_wake_sheets,\n    wake_length,\n)\n\n# - Airfoils are required for proper sizing of the caches - #\n# DFDC-type airfoil object\nafparams = DuctAPE.c4b.DFDCairfoil()\n\n# specify the airfoil array\nairfoils = [fill(afparams, 6)]\n\n# - Initialize Caches - #\nprepost_container_caching, solve_parameter_caching, solve_container_caching = DuctAPE.initialize_all_caches(\n    aero_solver_options, paneling_constants, airfoils\n)\n","category":"section"},{"location":"DuctAPE/api/caches/#How-to-pass-the-caches-into-an-analysis","page":"Precompiled Caches","title":"How to pass the caches into an analysis","text":"The precompiled caches can be passed in via keyword arguments to the analysis functions. If they are not, they are generated as the first step in the analysis.","category":"section"},{"location":"DuctAPE/api/caches/#DuctAPE.allocate_prepost_container_cache-DuctAPE-api-caches","page":"Precompiled Caches","title":"DuctAPE.allocate_prepost_container_cache","text":"allocate_prepost_container_cache(paneling_constants::PanelingConstants)\nallocate_prepost_container_cache(problem_dimensions::ProblemDimensions)\n\nAllocate the pre- and post-processing cache (used for intermediate calculations) based on paneling constants or problem dimensions.\n\nArguments\n\npaneling_constants::PanelingConstants : a PanelingConstants object\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chunk size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nprepost_container_caching::NamedTuple : a Named Tuple containing:\nprepost_container_cache::PreallocationTools.DiffCache : the cache\nprepost_container_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/caches/#DuctAPE.allocate_solve_parameter_cache-DuctAPE-api-caches","page":"Precompiled Caches","title":"DuctAPE.allocate_solve_parameter_cache","text":"allocate_solve_parameter_cache(\n    solve_type::SolverOptionsType,\n    paneling_constants::PanelingConstants;\n    airfoils,\n    fd_chunk_size=12,\n    levels=1,\n)\nallocate_solve_parameter_cache(\n    solve_type::SolverOptionsType,\n    problem_dimensions::ProblemDimensions;\n    airfoils,\n    fd_chunk_size=12,\n    levels=1\n)\n\nAllocate the solve parameter cache for parameters passed into the solver(s).\n\nArguments\n\nsolve_type::SolverOptionsType : Solver options type used for dispatch\npaneling_constants::PanelingConstants : a PanlingConstants object used for sizing\nairfoils::Airfoil : an array of airfoil composite types (MUST be a composite type), such as one of the types available in DuctAPE.C4Blade.\n\nOR\n\nsolve_type::SolverOptionsType : Solver options type used for dispatch\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object used for sizing\nairfoils::Airfoil : an array of airfoil composite types (MUST be a composite type), such as one of the types available in DuctAPE.C4Blade.\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chunk size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nsolve_parameter_caching::NamedTuple : a Named Tuple containing:\nsolve_parameter_cache::PreallocationTools.DiffCache : the cache\nsolve_parameter_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/caches/#DuctAPE.allocate_solve_container_cache-DuctAPE-api-caches","page":"Precompiled Caches","title":"DuctAPE.allocate_solve_container_cache","text":"allocate_solve_container_cache(\n    solve_type::SolverOptionsType,\n    paneling_constants::PanelingConstants;\n    fd_chunk_size=12,\n    levels=1,\n)\nallocate_solve_container_cache(\n    solve_type::SolverOptionsType,\n    problem_dimensions::ProblemDimensions;\n    fd_chunk_size=12,\n    levels=1,\n)\n\nAllocate the solve cache (used for intermediate calculations) based on paneling constants or problem dimensions.\n\nArguments\n\npaneling_constants::PanelingConstants : a PanelingConstants object\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chunk size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nsolve_container_caching::NamedTuple : a Named Tuple containing:\nsolve_container_cache::PreallocationTools.DiffCache : the cache\nsolve_container_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/caches/#DuctAPE.initialize_all_caches-DuctAPE-api-caches","page":"Precompiled Caches","title":"DuctAPE.initialize_all_caches","text":"initialize_all_caches(solver_options, paneling_constants, airfoils)\n\nConvenience function to initialize all caches before calling analysis.\n\nArguments\n\nsolver_options::SolverOptionsType : solver options used for cache allocation dispatch\npaneling_constants::PanelingConstants : PanelingConstants object upon which all cache sizing depends\nairfoils::Array{Airfoil} : Array of airfoil objects (from Rotor object)\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chunk size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nprepost_container_caching::NamedTuple : A named tuple containing the PreallocationTools DiffCache and a named tuple with relevant dimensions for accessing the cache.\nsolve_parameter_caching::NamedTuple : A named tuple containing the PreallocationTools DiffCache and a named tuple with relevant dimensions for accessing the cache.\nsolve_container_caching::NamedTuple : A named tuple containing the PreallocationTools DiffCache and a named tuple with relevant dimensions for accessing the cache.\n\n\n\n\n\n","category":"function"},{"location":"C4Blade/api/#Index","page":"API Index","title":"Index","text":"Pages = [\"C4Blade/api.md\"]\nDepth = 5\n\nModules=[DuctAPE.C4Blade]","category":"section"},{"location":"C4Blade/airfoil_types/CCBlade/#CCBlade-Airfoil-Types","page":"CCBlade Airfoil Types","title":"CCBlade Airfoil Types","text":"DuctAPE includes stripped-down versions of most of the airfoil types as well as most of the polar correction methods available in CCBlade. We have modified several of the CCBlade airfoil types to be compatible with the preallocated caching methods used in DuctAPE. Note that any of these methods can be constructed directly or using file inputs, and they will still be compatible with the preallocation and internal reconstruction methods.\n\nThe first is an airfoil based only on angle of attack.  Its associated evaluation function gives the lift and drag as a function of angle of attack only. Thus the lift and drag fields in this type are vectors.\n\nThe next two are provide lift and drag not only as a function of angle of attack but also Reynolds number or Mach number (note that these methods are not quite identical, and therefore they cannot be used interchangeably). The lift and drag fiedls in these types are matrices.\n\nThe last CCBlade-like airfoil type combines the previous ones together. The evaluation function for this type give the lift and drag relative to the angle of attack, Reynolds number, and Mach number.  The lift and drag fields for this type are 3D arrays.\n\nAs mentioned we also have kept most of the airfoil correction methods and airfoil writing methods from CCBlade.  The CCBlade documentation is a good source for how to use them if desired.","category":"section"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.AlphaAF","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.AlphaAF","text":"AlphaAF(alpha, cl, cd)\nAlphaAF(filename::String; radians=true)\n\nAirfoil data that varies with angle of attack.  Data is fit with an Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\ncl::Vector{Float64}: corresponding lift coefficients\ncd::Vector{Float64}: corresponding drag coefficients\n\nor\n\na file\n\nArguments\n\nfilename::String: name/path of file to read in\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.AlphaReAF","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.AlphaReAF","text":"AlphaReAF(alpha, Re, cl, cd)\nread_AlphaReAF(filenames::Vector{String}; radians=true)\n\nAirfoil data that varies with angle of attack and Reynolds number. Data is fit with a recursive Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\nRe::Vector{Float64}: Reynolds numbers\ncl::Matrix{Float64}: lift coefficients where cl[i, j] corresponds to alpha[i], Re[j]\ncd::Matrix{Float64}: drag coefficients where cd[i, j] corresponds to alpha[i], Re[j]\n\nor\n\nfilenames with one file per Reynolds number.\n\nArguments\n\nfilenames::Vector{String}: name/path of files to read in, each at a different Reynolds number in ascending order\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.AlphaMachAF","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.AlphaMachAF","text":"AlphaMachAF(alpha, Mach, cl, cd)\nAlphaMachAF(filenames::Vector{String}; radians=true)\n\nAirfoil data that varies with angle of attack and Mach number. Data is fit with a recursive Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\nMach::Vector{Float64}: Mach numbers\ncl::Matrix{Float64}: lift coefficients where cl[i, j] corresponds to alpha[i], Mach[j]\ncd::Matrix{Float64}: drag coefficients where cd[i, j] corresponds to alpha[i], Mach[j]\n\nor\n\nfilenames with one file per Mach number.\n\nArguments\n\nfilenames::Vector{String}: name/path of files to read in, each at a different Mach number in ascending order\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.AlphaReMachAF","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.AlphaReMachAF","text":"AlphaReMachAF(alpha, Re, Mach, cl, cd)\nAlphaReMachAF(filenames::Matrix{String}; radians=true)\n\nAirfoil data that varies with angle of attack, Reynolds number, and Mach number. Data is fit with a recursive Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\nRe::Vector{Float64}: Reynolds numbers\nMach::Vector{Float64}: Mach numbers\ncl::Array{Float64}: lift coefficients where cl[i, j, k] corresponds to alpha[i], Re[j], Mach[k]\ncd::Array{Float64}: drag coefficients where cd[i, j, k] corresponds to alpha[i], Re[j], Mach[k]\n\nor files with one per Re/Mach combination\n\nArguments\n\nfilenames::Matrix{String}: name/path of files to read in.  filenames[i, j] corresponds to Re[i] Mach[j] with Reynolds number and Mach number in ascending order.\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#Options","page":"Options","title":"Options","text":"There are quite a few options to choose from in DuctAPE. As DuctAPE was developed, various options were added as different approaches were considered. The current defaults were selected as the best set of options for the studies in the publications metioned in DuctAPE's README. However, most of the options implemented during development have been maintained in case of future need. The Options object contains various general options as well as several more detailed option objects. To make the process of setting options easier, the set_options method can be used to make only the desired changes from the defaults without having to define everything in the Options object. Note that the Options object is implemented using the @kwdef macro, so the set_options function doesn't really do anything in the case of a single operating point, but the other dispatch of set_options is especially helpful in initializing several of the sub-option objects to defaults of the correct size. Note that there are several fields in the options that are used for bookkeeping, especially in the case of multiple operating points.\n\nThe major sub-categories of options include general options, pre-processing options, solver options for both determining the wake sheet positions as well as the overall aerodyanmics solve, post-processing options, and bookkeeping options.\n\n","category":"section"},{"location":"DuctAPE/api/options/#Bookkeeping-Options","page":"Options","title":"Bookkeeping Options","text":"These are options that can be changed by the user for development/debugging purposes, but at this point, it would be wise in general usage to not change them. In future revisions, these will likely no longer be accessible to the user.\n\n","category":"section"},{"location":"DuctAPE/api/options/#General-Options","page":"Options","title":"General Options","text":"The verbose and silence warnings options are simply about what get's printed as the analysis runs. Warnings are printed when some sort of automated adjustment is made to the inputs in order to ensure they conform to the format required. The verbose option at this level is for verbose statements that are not within any solvers.  Solver verbosity is constrolled in the individual solver options.\n\nOccasionally, something in the preprocessing will fail, likely the LU decomposition of the linear system defining the bodies' panel system. If such a failure occurs, DuctAPE cannot continue to the main solve and will exit. The hard_fail option dictates what the exit behavior is. If true, DuctAPE will just return nothing immediately, which is quicker for turn-around on single runs. If false, DuctAPE will attempt to return an output object of the correct size and type, which is convenient for some optimization frameworks for which you'll want some output to be available even if passing a failure flag for the specific analysis.\n\n","category":"section"},{"location":"DuctAPE/api/options/#Preprocess-Options","page":"Options","title":"Preprocess Options","text":"","category":"section"},{"location":"DuctAPE/api/options/#Geometry-Interpolation-and-Generation-Options","page":"Options","title":"Geometry Interpolation and Generation Options","text":"The autoshiftduct option may be convenient depending on how the duct coordinates are being input. It allows the user to input the duct coordinates at an arbitrary radial location, for example if a standard airfoil is used with leading edge at (0,0). In the preprocessing, the duct geometry will be shifted to the radial location at which the rotor tip is coincident with the duct surface at the axial location at which the first rotor is situated. If you are already inputting the duct geometry at the correct position, this option may be turned off, but it usually doesn't hurt to be left on.","category":"section"},{"location":"DuctAPE/api/options/#Paneling-Options","page":"Options","title":"Paneling Options","text":"These, in general, do not need to be touched by users; thus we do not include them in the PanelingConstants, but we do make them available.","category":"section"},{"location":"DuctAPE/api/options/#Integration-Options","page":"Options","title":"Integration Options","text":"DuctAPE uses numerical integration to determine the influence of axisymmetric vortex and source panels on the restof the system. There are several options for numerical integration, and the methods can be mixed and matched with their own specific options for the nominal (panel on other panels) and singular (panel on itself) cases. The Gauss-Legendre method is useful in optimization cases to avoid noise in the integration error. The Gauss-Kronrod method is implemented via QuadGK.jl and is more accurate, especially in for the singular cases, but is less useful for optimization purposes due to noise in the error from the adaptive nature. Similarly, the Romberg method similar to that implemented in DFDC is adaptive and can be fast, but is also not usually the best choice. Thus we default to Gauss-Legendre methods.","category":"section"},{"location":"DuctAPE/api/options/#Example","page":"Options","title":"Example","text":"using DuctAPE\n\n# set nominal options using a GaussLegendre object (which is an InterationMethod type)\n# note that a convenience method is used here that takes in the number of points and\n#calculates the appropriate sample locations and weights.\nnominal_integration_method = DuctAPE.GaussLegendre(10)\n\n# set singular options using a GaussKronrod object (which is an InterationMethod type)\n# note that like most option structs, these are defined using @kwdef allowing the fields\n#to be treated as keyword arguments.\n# also note that we haven't changed the evaluation limit (default 10^7)\nsingular_integration_method = DuctAPE.GaussKronrod(; order=7, atol=2e-16)\n\n# put the quadrature options together\nintegration_options = DuctAPE.IntegrationOptions(;\n    nominal=nominal_integration_method, singular=singular_integration_method\n)\n\n# example of calling the set_options function\noptions = DuctAPE.set_options(; integration_options=integration_options)\n\n","category":"section"},{"location":"DuctAPE/api/options/#Solver-Options","page":"Options","title":"Solver Options","text":"","category":"section"},{"location":"DuctAPE/api/options/#Elliptic-Grid-Solver-Options","page":"Options","title":"Elliptic Grid Solver Options","text":"The wake geometry is obtained by solving for approximate streamlines on an elliptic grid with the bodies as boundaries. There are two methods available, a successive line over relaxiation (SLOR) method that can be used in isolation or as a preconditioner to a Newton solve method from the NLsolve.jl package. The default option is to run a few iterations of SLOR to precondition and smooth out the initial grid, and then finish up with the Newton solve, usually within 3-5 iterations. Note that the SLOR method is not implemented using ImplicitAD.jl since there isn't a clean residual definition separate from the solve method. The Newton solve is implemented using ImplicitAD.jl which helps speed up automatic differentiation in an optimization setting, but it still benefits from a few iterations of SLOR beforehand.","category":"section"},{"location":"DuctAPE/api/options/#Example-2","page":"Options","title":"Example","text":"using DuctAPE\n\n# define wake grid solver settings\nwake_solve_options = DuctAPE.GridSolverOptions(; atol=1e-10)\n\n# set all options\noptions = DuctAPE.set_options(; grid_solver_options=wake_solve_options)","category":"section"},{"location":"DuctAPE/api/options/#Aerodynamics-Solver-Options","page":"Options","title":"Aerodynamics Solver Options","text":"Quite a few solve methods were explored in the development of DuctAPE which can be separated into three broad categories: Fixed-point iteration solvers, quasi-Newton solvers, and Newton solvers. In general, the fixed-point solvers have been faster and more robust than other methods, but all the methods have been kept in case they are desired for future development.\n\nThere are two methods that are implemented directly in DuctAPE: the CSOR and ModCSOR methods which are the controlled successive over relaxation fixed-point approach taken in DFDC and a modified version compatible with ImplicitAD.jl that is the current default and is currently the best (fastest/most robust) for optimization.\n\nThe other methods are implemented via external dependencies and some do better than others. In our experience, the other strictly fixed-point methods work relatively well, but are middle of the road.\n\nThe quasi-Newton methods are hit or miss, with Minpack doing well enough to make it into some of the compound solver options discussed below, but we have had very little success wth SIAMFANLEquations up to this point.\n\nNonlinearSolve is generally faster than NLsolve if the problem is large enough, but we find it to be significantly less robust.  NLsolve's Anderson method is perhaps the best external method in terms of speed and robustness, but is just barely edged out by the CSOR methods.\n\nFinally, there are several compound solve methods implemented, the first chaining solvers together.  The solver chain can be defined as the user wishes, but the defaults start with the fixed-point Anderson method, move to the Minpack quasi-Newton method if the fixed-point method doesn't converge in the given number of iterations, and then finishes with a full Newton method if the quasi-newton method doesn't converge. The other compound solver combines solvers in a composite manner, typically starting with a few iterations of a full Newton method to get the solver going in the right direction and then finishing with a fixed-point method. The ChainSolverOptions was at one point the default method, but once the modified CSOR method was developed, the compound solvers weren't used much. Note that due to the way the solvers are implemented and dispatched, it is currently not possible to mix and match the CSOR methods with any of the external package methods.","category":"section"},{"location":"DuctAPE/api/options/#Example-3","page":"Options","title":"Example","text":"using DuctAPE\nusing LineSearches\n\n# Define settings for NLsolve's newton method\naero_solver_options = DuctAPE.NLsolveOptions(;\n    algorithm=:newton,\n    atol=1e-10,\n    iteration_limit=30,\n    linesearch_method=LineSearches.BackTracking, #don't include parentheses on method handle\n    linesearch_kwargs=(; order=3, maxstep=1e6),\n)\n\n# set all the options\nDuctAPE.set_options(; solver_options=aero_solver_options)\n\nnote: Iteration Counters\nThe iterations field (not to be confused with the iterations_limit field) in the solver options should generally not be changed.  They automatically save (in-place) the number of iterations the solver performs and can be accessed after the analysis is run.\n\n","category":"section"},{"location":"DuctAPE/api/options/#Postprocess-Options","page":"Options","title":"Postprocess Options","text":"Most of the postprocess options have to do with writing the outputs to files, with the default behavior being to not write anything.  These options can be useful for debugging purposes or saving outputs, though it is usually more efficient to manually save a select few outputs rather than all the outputs. The one option that is slightly more involved is the boundary layer options. Currently, only Head's method is fully implemented, but there has also been some development started on Green's method. The boundary layer options include choices regarding type of solver, with a simple 2nd-order Runge-Kutta method being the default (and appears to be best for optimization). There is also a 4th-order Runge-Kutta method implemented as well as the RadauIIA5 method from DifferentialEquations.jl which may be more accurate for single runs. Note that the default setting is to not run the boundary layer method. The model_drag option in the boundary layer options needs to be set to true if it is desired to include the drag model.","category":"section"},{"location":"DuctAPE/api/options/#Example-4","page":"Options","title":"Example","text":"using DuctAPE\n\n# Define Boundary Layer Settings\nboundary_layer_options = DuctAPE.HeadsBoundaryLayerOptions(;\n    model_drag=true,\n    separation_penalty_upper=0.1,\n    separation_penalty_lower=0.1,\n    separation_allowance_upper=3,\n    separation_allowance_lower=25,\n)\n\n# set all the options\nDuctAPE.set_options(; boundary_layer_options=boundary_layer_options)\n\n","category":"section"},{"location":"DuctAPE/api/options/#Advanced-Options-for-Multi-point-analyses","page":"Options","title":"Advanced Options for Multi-point analyses","text":"For using advanced options in multi-point analyses, there are various changes that need to be made to avoid run-time errors. Here is an example for setting options with the CSOR solver.\n\nusing DuctAPE\n\n# number of operating points to analyze\nnop = 3\n\noptions = DuctAPE.set_options(;\n    solver_options=DuctAPE.ModCSORSolverOptions(;\n        converged=fill(false, (1, nop)), # need a convergence flag for each operating point\n        iterations=zeros(Int, (1, nop)), # need a iteration count for each operating point\n    ),\n    write_outputs=fill(false, nop), # we need to know which of the operating point outputs to write\n    outfile=fill(\"\", nop), # we need to include names, even if they won't be used.\n    output_tuple_name=fill(\"outs\", nop), # we need to include names, even if they won't be used.\n)\n\nIf using a compound algorithm with a multi-point solve, then each of the solvers needs to have the multiple converged and iterations fields for each operating point, and the overall solve type needs to have a converged and iterations field for each solver and each operating point.\n\noptions = DuctAPE.set_options(;\n    solver_options=DuctAPE.ChainSolverOptions(;\n        solvers=[ # vector of solvers to use in poly-algorithm\n            DuctAPE.NLsolveOptions(;\n                algorithm=:anderson,\n                atol=1e-12,\n                iteration_limit=200,\n                converged=fill(false, (1, nop)), # flags for each operating point\n                iterations=zeros(Int, (1, nop)), # counters for each operating point\n            ),\n            DuctAPE.MinpackOptions(;\n                atol=1e-12,\n                iteration_limit=100,\n                converged=fill(false, (1, nop)),\n                iterations=zeros(Int, (1, nop)),\n            ),\n        ],\n        converged=fill(false, (2, nop)), # flags for each solver and each operating point\n        iterations=zeros(Int, (2, nop)), # counts for each solver and each operating point\n    ),\n)","category":"section"},{"location":"DuctAPE/api/options/#DuctAPE.Options","page":"Options","title":"DuctAPE.Options","text":"struct Options\n\nType containing (nearly) all the available user options.\n\nFields\n\nGeneral Options\n\nverbose::Bool = false : flag to print verbose statements\nsilence_warnings::Bool = true : flag to silence warnings\nhard_fail::Bool = true : flag as to whether DuctAPE should return nothing immediately after a failed initialization of the elliptic grid or a failed decomposition of the body influence matrix.  If set to false, DuctAPE will attempt to return objects of the correct size, but with initialized values only.\n\nPre-processing Options\n\nGeometry Interpolation and Generation Options\n\nfinterp::Interplation Method = FLOWMath.akima : interpolation method used for re-paneling bodies\nautoshiftduct::Bool = true : flag as to whether duct geometry should be shifted based on rotor tip location\n\nPaneling Options\n\nitcpshift::Float = 0.05 : factor for internal trailing edge psuedo-panel placement (default is DFDC hard-coded value)\naxistol::Float = 1e-15 : tolerance for how close the the axis of rotation should be considered on the axis\ntegaptol::Float = 1e1 * eps() : tolerance for how large of a trailing edge gap should be considered a gap\n\nIntegration Options\n\nintegration_options::IntegrationOptions type = IntegrationOptions() : integration options\n\nPost-processing Options\n\nboundary_layer_options::BoundaryLayerOptions : BoundaryLayerOptions object\nwrite_outputs::AbstractArray{Bool} = [false] : Bool for whether to write the outputs of the analysis to an external file (slow)\noutfile::AbstractArray{String} = [\"outputs.jl\"] : External output file name (including path information) for files to write\ncheckoutfileexists::Bool = false : Flag for whether to check if file exists before overwriting\noutput_tuple_name::AbstractArray{String} = [\"outs\"] : variable name for named tuple written to out file\n\nSolving Options\n\ngrid_solver_options::GridSolverOptionsType = GridSolverOptions() : elliptic grid solver options\nsolver_options::SolverOptionsType = ChainSolverOptions() : solver options\n\nBookkeeping Options\n\nmultipoint_index::Int = [1] : holds current index of multi-point solver (no need for user to change this usually)\nlu_decomp_flag::Bool = false : flag indicating if panel method LHS matrix factorization was successful\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.set_options","page":"Options","title":"DuctAPE.set_options","text":"set_options(; kwargs...)\nset_options(multipoint; kwargs...)\n\nSet the options for DuctAPE to use.\n\nNote that the vast majority of the available options are defined through keyword arguments.  See the documentation for the various option types for more information.\n\nArguments\n\nmultipoint::AbstractArray{OperatingPoint} : a vector of operating points to use if running a multi-point analysis.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/options/#DuctAPE.IntegrationOptions","page":"Options","title":"DuctAPE.IntegrationOptions","text":"struct IntegrationOptions\n\nA struct used to hold the integration options for both the nominal and singular cases.\n\nFields\n\nnominal::IntegrationMethod=GaussLegendre(8) : the integration options to use for the nominal case.\nsingular::IntegrationMethod=GaussLegendre(8) : the integration options to use for the self-induced case.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.GaussLegendre","page":"Options","title":"DuctAPE.GaussLegendre","text":"struct GaussLegendre <: IntegrationMethod\n\nOptions for Gauss-Legendre integration method\n\nFields\n\nsample_points::Int : Sample Points\nweights::Int : Gauss weights\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.GaussKronrod","page":"Options","title":"DuctAPE.GaussKronrod","text":"struct GaussKronrod <: IntegrationMethod\n\nOptions for Gauss-Kronrod integration method\n\nFields\n\norder::Int = 7 : order of Legendre polynomial to use on each interval\nmaxevales::Int = 10^7 : maximum number of evaluations in the adaptive method\natol::Float = 0.0 : absolute error tolerance. (note, if zero, QuadGK uses sqrt(eps()) relative tolerance).\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.Romberg","page":"Options","title":"DuctAPE.Romberg","text":"struct Romberg <: IntegrationMethod\n\nOptions for Romberg integration method\n\nFields\n\nmax_subdivisions::Int = 10 : maximum number of subdivisions. Note, total number of internvals is 2^N, where N is number of subdivisions.\natol::Float = 1e-6 : absolute error tolerance.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.SLORGridSolverOptions","page":"Options","title":"DuctAPE.SLORGridSolverOptions","text":"struct SLORGridSolverOptions <: GridSolverOptionsType\n\nOptions for SLOR (successive line over relaxation) elliptic grid solver.\n\nFields\n\niteration_limit::Int = 100 : maximum number of iterations\natol::Float = 1e-9 : absolute convergence tolerance\nconverged::AbstractArray{Bool} = [false]\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.GridSolverOptions","page":"Options","title":"DuctAPE.GridSolverOptions","text":"struct GridSolverOptions <: GridSolverOptionsType\n\nOptions for Newton elliptic grid solver.\n\nFields\n\niteration_limit::Int = 20 : maximum number of iterations\natol::Float = 3e-10 : absolute convergence tolerance\nalgorithm::Symbol = :newton : algorithm to use in NLsolve.jl\nautodiff::Symbol = :forward : differentiation method to use in NLsolve.jl\nprecondition = false : flag to precondition with SLOR\nprecondition_max_iterations = 3 : number of precondition iterations\nconverged::AbstractArray{Bool} = [false]\niterations::AbstractArray{Int} = [0] : iteration counter\nresidual_value::AbstractArray{Int} = [0] : residual value\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.CSORSolverOptions","page":"Options","title":"DuctAPE.CSORSolverOptions","text":"struct CSORSolverOptions <: InternalSolverOptions\n\nType containing all the options for the CSOR (controlled successive over relaxation) solver.\n\nNote that the defaults match DFDC settings.\n\nFields\n\nverbose::Bool = false : flag to print verbose statements\niteration_limit::Float = 1e2 : maximum number of iterations\nnrf::Float = 0.4 : nominal relaxation factor\nbt1::Float = 0.2 : backtracking factor 1\nbt2::Float = 0.6 : backtracking factor 2\npf1::Float = 0.4 : press forward factor 1\npf2::Float = 0.5 : press forward factor 2\nbtw::Float = 0.6 : backtracking factor for wake\npfw::Float = 1.2 : press forward factor for wake\nf_circ::Float = 1e-3 : convergence tolerance for rotor circulation\nf_dgamw::Float = 2e-4 : convergence tolerance for wake vortex strength\nconvergence_type::ConvergenceType = Relative() : dispatch for relative or absolute convergence criteria.\nVconv::AbstractArray{Float} = [1.0] : velocity used in relative convergence criteria (should be set to Vref).\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\nresiduals::AbstractArray{Float} = [-1.0] : final residual values\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.ModCSORSolverOptions","page":"Options","title":"DuctAPE.ModCSORSolverOptions","text":"struct ModCSORSolverOptions <: InternalSolverOptions\n\nType containing all the options for the modified CSOR solver.\n\nFields\n\nverbose::Bool = false : flag to print verbose statements\niteration_limit::Float = 350 : maximum number of iterations\nrelaxation_parameters::NamedTuple = (;\nnrf::Float = 0.4 : nominal relaxation factor\nbt1::Float = 0.2 : backtracking factor 1\nbt2::Float = 0.6 : backtracking factor 2\npf1::Float = 0.4 : press forward factor 1\npf2::Float = 0.5 : press forward factor 2\nbtw::Float = 0.6 : backtracking factor for wake\npfw::Float = 1.2 : press forward factor for wake\n) : parameters for determining relaxation level of states in each iteration.\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\nresiduals::AbstractArray{Float} = [-1.0] : final residual values\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.SpeedMappingOptions","page":"Options","title":"DuctAPE.SpeedMappingOptions","text":"struct SpeedMappingOptions <: ExternalSolverOptions\n\nOptions for the SpeedMapping.jl package solver\n\nFields\n\norders::AbstractArray{Int} = [3, 2]\nsig_min::Int = 0 : maybe set to 1?\nstabilize::Bool = false : stabilizes before extrapolation\ncheck_obj::Bool = false : checks for inf's and nan's and starts from previous finite point\natol::Float = 1e-10 : absolute convergence tolerance\niteration_limit::Float = 1000 : maximum number of iterations\ntime_limit::Float = Inf : time limit in seconds\nlower::Float = nothing : box lower bounds\nupper::Float = nothing : box upper bounds\nbuffer::Float = 0.01 : if using bounds, buffer brings x inside bounds by buffer amountd\nLp::Float = Inf : p value for p-norm for convergence criteria\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\nresiduals::AbstractArray{Float} = [-1.0] : final residual values\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.FixedPointOptions","page":"Options","title":"DuctAPE.FixedPointOptions","text":"struct FixedPointOptions <: ExternalSolverOptions\n\nOptions for the FixedPoint.jl package solver\n\nFields\n\niteration_limit::Int = 1000 : maximum number of iterations\nvel::Float = 0.9 : vel keyword argument, default is package default\nep::Float = 0.01 : ep keyword argument, default is package default\natol::Float = 1e-12 : absolute convergence tolerance\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\nresiduals::AbstractArray{Float} = [-1.0] : final residual values\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.MinpackOptions","page":"Options","title":"DuctAPE.MinpackOptions","text":"struct MinpackOptions <: ExternalSolverOptions\n\nOptions for the MINPACK's HYBRJ solver\n\nFields\n\nalgorithm::Symbol = :hybr : algorithm to use in MINPACK.jl (hybr is HYBRJ when the jacobian is provided)\natol::FLoat = 1e-10 : absolute convergence tolerance\niteration_limit::FLoat = 100 : maximum number of iterations\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\nresiduals::AbstractArray{Float} = [-1.0] : final residual values\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.SIAMFANLEOptions","page":"Options","title":"DuctAPE.SIAMFANLEOptions","text":"struct SIAMFANLEOptions <: ExternalSolverOptions\n\nOptions for the SIAMFANLEquations pacakge solvers\n\nFields\n\nalgorithm::SIAMFANLEquations algorithm = SIAMFANLEquations.nsoli : algorithm to use\nrtol::Float = 0.0 : relative convergence tolerance\natol::Float = 1e-10 : absolute convergence tolerance\niteration_limit::Int = 1000 : maximum number of iterations\nlinear_iteration_limit::Float = 5 : maximum number of linear solve iterations (GMRES)\nadditional_kwargs = (;) : any additional keyword arguments for the solver\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\nresiduals::AbstractArray{Float} = [-1.0] : final residual values\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.NLsolveOptions","page":"Options","title":"DuctAPE.NLsolveOptions","text":"struct NLsolveOptions <: ExternalSolverOptions\n\nOptions for the NLsolve pacakge solvers\n\nFields\n\nalgorithm::Symbol = :anderson : algorithm to use\nadditional_kwargs = (;) : any additional keyword arguments for the solver\natol::Float = 1e-12 : absolute convergence tolerance\niteration_limit::Int = 25 : maximum number of iterations\nlinesearch_method::LineSearches method = LineSearches.MoreThuente : line search method to use\nlinesearch_kwargs = (;) : any additional lineseach keyword arguments\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\nresiduals::AbstractArray{Float} = [-1.0] : final residual values\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.NonlinearSolveOptions","page":"Options","title":"DuctAPE.NonlinearSolveOptions","text":"struct NonlinearSolveOptions <: ExternalSolverOptions\n\nOptions for the SimpleNonlinearSolve pacakge solvers\n\nFields\n\nalgorithm::SimpleNonlinearSolve algorithm = SimpleNonlinearSolve.SimpleNewtonRaphson : algorithm to use\nadditional_kwargs = (;) : any additional keyword arguments for the solver\natol::Float = 1e-12 : absolute convergence tolerance\niteration_limit::Float = 25 : maximum number of iterations\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\nresiduals::AbstractArray{Float} = [-1.0] : final residual values\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.ChainSolverOptions","page":"Options","title":"DuctAPE.ChainSolverOptions","text":"struct ChainSolverOptions <:ExternalPolyAlgorithmOptions\n\nOptions for Chain Solvers (try one solver, if it doesn't converge, try another)\n\nFields\n\nsolvers::AbstractArray{SolverOptionsType} = [       NLsolveOptions(; algorithm=:anderson, atol=1e-10),       MinpackOptions(; atol=1e-10),       NonlinearSolveOptions(;           algorithm=SimpleNonlinearSolve.SimpleNewtonRaphson,           atol=1e-12,           additional_kwargs=(; autodiff=SimpleNonlinearSolve.AutoForwardDiff()),       ),   ] : Vector of solver options to use.\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\nresiduals::AbstractArray{Float} = [-1.0] : final residual values\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.CompositeSolverOptions","page":"Options","title":"DuctAPE.CompositeSolverOptions","text":"struct CompositeSolverOptions <: ExternalPolyAlgorithmOptions\n\nOptions for Composite Solvers (start with a partial solve of one solve, then finish with another starting where the first left off).\n\nFields\n\nsolvers::AbstractArray{SolverOptionsType} = [       NLsolveOptions(; algorithm=:newton, iteration_limit=3),       NLsolveOptions(; algorithm=:anderson, atol=1e-10),   ] : Vector of solver options to use.\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\nresiduals::AbstractArray{Float} = [-1.0] : final residual values\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/options/#DuctAPE.HeadsBoundaryLayerOptions","page":"Options","title":"DuctAPE.HeadsBoundaryLayerOptions","text":"struct HeadsBoundaryLayerOptions\n\nFields:\n\nmodel_drag::Bool=false : flag to turn on viscous drag approximation\ntermiante::Bool=true : flag to terminate solver when separation criteria is met.\nreturn_last_max_shape_factor::Bool=true : return the last maximum shape factor to avoid false drops near the trailing edge.\ncutoff_Hsep::Bool=false : Cutoff returned Hsep vector at separation criteria\nn_steps::Int = Int(5e3) : number of steps to use in boundary layer integration\nfirst_step_size::Float = 1e-6 : size of first step in boundary layer integration\nupper_step_size::Float=nothing : uses fixed step size rather than total number of steps.\nlower_step_size::Float=nothing : uses fixed step size rather than total number of steps.\noffset::Float = 1e-3 : size of offset for (where to initialize) boundary layer integration\nsolver_type::AbstractODESolverType=RK() : type of ODE solver (RK() or DiffEq())\node::Function=RK2 : solver to use for boundary layer integration (RadauIIA5, RK4, or RK2 available)\nseparation_criteria::Float=3.0 : value of H12 after which separation should happen.\nseparation_allowance_upper::Int=10 : upper side allowance for how many steps ahead of the trailing edge we'll allow separation without penalty\nseparation_allowance_lower::Int=10 : lower side allowance for how many steps ahead of the trailing edge we'll allow separation without penalty\nseparation_penalty_upper::Float=0.2 : upper side maximum penalty value for separation (at leading edge)\nseparation_penalty_lower::Float=0.2 : lower side maximum penalty value for separation (at leading edge)\napply_separation_penalty_to_rotor::Bool=false : flag to apply separation penalty to rotor performance.\ndy_eps::Float=0.0 : temporary development parameter.\nH1_eps::Float=1e-4: temporary development parameter.\nH_eps::Float=0.0: temporary development parameter.\nverbose::Bool=false : flag to print verbose statements each iterations (beware; it's a lot)\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/DFDC/#DFDC-Airfoil-Type","page":"DFDC Airfoil Type","title":"DFDC Airfoil Type","text":"The DFDC Airfoil type is very similar to the XROTOR airfoil type, but includes additions for cascade corrections based on stagger and solidity. The cascade corrections aren't particularly accurate, but they do apply ballpark effects resulting from high solidity blade sections. The main benefit to this airfoil type is its simplicity and that the post-stall behavior is already in a format allowing more robust convergence of the DuctAPE solvers.","category":"section"},{"location":"C4Blade/airfoil_types/DFDC/#DuctAPE.C4Blade.DFDCairfoil","page":"DFDC Airfoil Type","title":"DuctAPE.C4Blade.DFDCairfoil","text":"DFDCairfoil\n\nFields\n\nalpha0::Vector{Float} : zero lift angle of attack\nclmax::Vector{Float} : maximum cl\nclmin::Vector{Float} : minimum cl\ndclda::Vector{Float} : lift curve slope (1/radians)\ndclda_stall::Vector{Float} :  lift curve slope post-stall (1/radians)\ndcl_stall::Vector{Float} : cl increment from initial to total stall.\ncdmin::Vector{Float} : minimum cd\ncldmin::Vector{Float} : cl at cdmin\ndcddcl2::Vector{Float} : quadratic curve factor for cl vs cd curve left(fracd(c_d)d(c_l^2)right)\ncmcon::Vector{Float} : pitching moment constant (unused right now)\nRe_ref::Vector{Float} : reference Reynolds number at which cd values apply\nRe_exp::Vector{Float} : Reynolds number exponent scaling left( c_d = c_d(ReRe_ref)^Re_expright) should be 0.2 for fully laminar and 0.5 for fully turbulent\nmcrit::Vector{Float} : critical Mach number\ncorrect_for_mach::Vector{Float} : flag to add Prandtl-Glauert correction\ncorrect_for_cascade::Vector{Float} : flag to add cascade corrections\ncorrect_for_reynolds::Vector{Float} : flag to add reynolds drag correction\ncorrect_for_transonic::Vector{Float} : flag to add drag correction above critical mach number\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/actuator_disk/#Actuator-Disk-Type","page":"Actuator Disk Type","title":"Actuator Disk Type","text":"warning: Warning\nActuator disk types are currently in development and not ready for general use.\n\nDuctAPE currently implements an actuator disk type that can be used to directly define the rotor blade circulation. Note that in the current implementation, values for circulation and source panel strength are set as constants and are unaffected by the solver in general.","category":"section"},{"location":"C4Blade/airfoil_types/actuator_disk/#DuctAPE.C4Blade.ADM","page":"Actuator Disk Type","title":"DuctAPE.C4Blade.ADM","text":"ADM\n\nFields\n\nprescribed_circulation::Float=0.0 : Prescribed circulation strength\nprescribed_source_strength::Float=0.0 : Prescribed source panel strength\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/outputs/#Outputs","page":"Outputs","title":"Outputs","text":"The output tuple contains many items. The post_process function docstring lists them. The purpose of showing this function here is not for you to manually run the fuction, but simply rather for you to see what the available outputs are.","category":"section"},{"location":"DuctAPE/api/outputs/#Returning-the-Pre-process-Objects","page":"Outputs","title":"Returning the Pre-process Objects","text":"Sometimes, it may be desireable to return the pre-process objects, including:\n\npanels which is a named tuple containing the body, rotor, and wake panel objects\nivb which are the unit induced velocities on the body panels\nsolve_parameter_tuple which contains all of the solver parameters\nblade_elements which contains all of the blade element geometry and airfoil information\nlinsys which contains all the linear system objects for the panel method\nidmaps which contains all the index mapping used throughout the solve and post-process.\n\nIn this case, we can use the return_inputs keyword argument when calling the analyze function to return a named tuple containing those pre-process objects.\n\nouts, ins, success_flag = dt.analyze(\n    ducted_rotor, operating_point, reference_parameters; return_inputs=true\n)","category":"section"},{"location":"DuctAPE/api/outputs/#DuctAPE.post_process","page":"Outputs","title":"DuctAPE.post_process","text":"post_process(\n    solver_options,\n    converged_states,\n    prepost_containers,\n    solve_container_caching,\n    solve_parameter_cache_vector,\n    solve_parameter_cache_dims,\n    operating_point,\n    reference_parameters,\n    boundary_layer_options,\n    A_bb_LU,\n    idmaps,\n    problem_dimensions,\n    multipoint_index;\n    write_outputs=options.write_outputs,\n    outfile=options.outfile,\n    checkoutfileexists=options.checkoutfileexists,\n    output_tuple_name=options.output_tuple_name,\n    verbose=options.verbose,\n)\n\nPost-process a converged nonlinear solve solution.\n\nArguments\n\nsolver_options::SolverOptionsType : A SolverOptionsType object (also used for dispatch)\nconverged_states::Vector{Float} : the converged state variables\nprepost_containers::NamedTuple : the named tuple containing pre-allocated containers for the pre- and post-processing intermediate calculations\nsolve_container_cache::NamedTuple : the cache and dimensions for intermediate values in the residual calculation\nsolve_parameter_cache_vector::Vector{Float} : the applicably typed cache vector for the solve parameters\nsolve_parameter_cache_dims::NamedTuple : the dimensions of the solver parameters\noperating_point::OperatingPoint : the operating point being analyzed\nreference_parameters::ReferenceParameters : a ReferenceParameters object\nBoundaryLayerOptions::BoundaryLayerOptions : a BoundaryLayerOptions object\nA_bb_LU::LinearAlgebra.LU : LinearAlgebra LU factorization of the LHS matrix\nairfoils::Vector{AFType} : A matrix of airfoil types associated with each of the blade elements\nidmaps::NamedTuple : A named tuple containing index mapping used in bookkeeping throughout solve and post-process\nproblem_dimensions::ProblemDimensions : A ProblemDimensions object\nmultipoint_index::Vector{Int} : a one-dimensional vector containing the index of which multipoint analysis operating point is being analyzed.\n\nKeyword Arguments\n\nwrite_outputs=options.write_outputs::Vector{Bool} : a vector with the same length as number of multipoints indicating if the outputs should be saved.\noutfile=options.outfile::Vector{String} : a vector of file paths/names for where outputs should be written\ncheckoutfileexists=options.checkoutfileexists::Bool : a flag for whether existing files should be checked for or if blind overwriting is okay.\noutput_tuple_name=options.output_tuple_name::Vector{String} : the variable name(s) of the named tuple of outputs to be written.\nverbose::Bool=false : flag to print verbose statements\n\nReturns\n\nouts::NamedTuple : A named tuple containing all the output values including\n\nExtended help\n\nFull Outputs Information: Each for any level of these outputs with sub-levels, the higher level is a NamedTuple comprised of the of items listed below it. For example: outs.bodies.boundary_layers.stagnation_indices\n\nbodies::NamedTuple : NamedTuple containing outputs related to the duct and center body\npanel_strengths::Vector{Float} : body vortex panel strengths\ninviscid_thrust::Vector{Float} : dimensional force in positive axial direction for duct and center body.\nbody_force_coefficient::Vector{Float} : force coefficients associated with dimensional inviscid thrust components\nviscous_drag::Vector{Float} : dimensional force in negative axial direction for duct and center body (note: zero if boundary layer is turned off, and center body is always zero since no drag method is yet implemented for the center body)\nthrust_comp::Vector{Float} : inviscid_thrust .- viscous_drag\ntotal_thrust::Float : sum(thrust_comp)\ninduced_efficiency::Vector{Float} : body-induced propulsive efficiency\ncp_in::Vector{Float} : inside pressure distribution for all bodies\ncp_out::Vector{Float} : inside pressure distribution for all bodies\ncp_casing_in::Vector{Float} : inside pressure distribution for duct casing\ncp_casing_out::Vector{Float} : outside pressure distribution for duct casing\ncasing_zpts::Vector{Float} : axial component of casing control points\ncp_nacelle_in::Vector{Float} : inside pressure distribution for duct nacelle\ncp_nacelle_out::Vector{Float} : inside pressure distribution for duct nacelle\nnacelle_zpts::Vector{Float} : axial component of nacelle control points\ncp_center_body_in::Vector{Float} : inside pressure distribution for center bodies\ncp_center_body_out::Vector{Float} : inside pressure distribution for center bodies\ncenter_body_zpts::Vector{Float} : axial components of center body control points\nVtot_in::Matrix{Float} : total inner surface velocity distribution for all bodies. row 1 is vz, row 2 is vr, columns are control points.\nVtot_out::Matrix{Float} : total outer surface velocity distribution for all bodies. row 1 is vz, row 2 is vr, columns are control points.\nVtot_prejump::Matrix{Float} : total surface velocity distribution before velocity jumps terms are applied for all bodies. row 1 is vz, row 2 is vr, columns are control points.\nvtot_body::Vector{Float} : body-induced velocity on the body surfaces\nvtot_jump::Vector{Float} : velocity due to jump terms in Fredholm equation\nvtot_wake::Vector{Float} : wake-induced velocity on the body surfaces\nvtot_rotors::Vector{Float} : rotor-induced velocity on the body surfaces\nVtan_in::Vector{Float} : inner surface tangential velocity distribution for all bodies\nVtan_out::Vector{Float} : outer surface tangential velocity distribution for all bodies\nvtan_casing_in::Vector{Float} : inner surface tangential velocity distribution for duct casing\nvtan_casing_out::Vector{Float} : outer surface tangential velocity distribution for duct casing\nvtan_nacelle_in::Vector{Float} : inner surface tangential velocity distribution for duct nacelle\nvtan_nacelle_out::Vector{Float} : outer surface tangential velocity distribution for duct nacelle\nvtan_center_body_in::Vector{Float} : inner surface tangential velocity distribution for center body\nvtan_center_body_out::Vector{Float} : outer surface tangential velocity distribution for center bodies\nboundary_layers::NamedTuple : NamedTuple containing information from the boundary layer solve (if model_drag in boundary_layer_options was set to true).\nstagnation_indices::Vector{Int} : indices surrounding stagnation point\nupper_initial_states::Vector{Float} : upper side initial states\nupper_solved_states::Matrix{Float} : upper side solved states\nupper_solved_steps::Vector{Float} : final steps associated with upper side solved states\nlower_initial_states::Vector{Float} : lower side initial states\nlower_solved_states::Matrix{Float} : lower side solved states\nlower_solved_steps::Vector{Float} : final steps associated with lower side solved states\nsurface_length_upper::Vector{Float} : cumulative panel lengths on upper side\nsurface_length_lower::Vector{Float} : cumulative panel lengths on lower side\nstag_point::Float : curve length at which stagnation point is located\nsplit_ratio::Float : ratio of lower to total surface length\nseparation_point_ratio_upper::Float : ratio of upper side separation point location relative to upper side surface length\nseparation_point_ratio_lower::Float : ratio of lower side separation point location relative to lower side surface length\ncdc_upper::Float : drag coefficient times chord length for upper side\ncdc_lower::Float : drag coefficient times chord length for lower side\nvtdotpv::Vector{Float} : dot product of tangential velocity and panel vector for duct\nboundary_layer_functions_lower::NamedTuple : NamedTuple of functions generated for use in boundary layer solution. For Head's method these are:\nedge_velocity::FLOWMath.Akima : spline of surface velocity relative to surface length\nedge_acceleration::FLOWMath.Akima : spline of derivatives of edge_velocity relative to surface length\nedge_density::FLOWMath.Akima : spline of density relative to surface length (constant for Head's method)\nedge_viscosity::FLOWMath.Akima : spline of viscosity relative to surface length (constant for Head's method)\nboundary_layer_functions_upper::NamedTuple : same as boundary_layer_functions_lower but for upper side.\nrotors::NamedTuple : NamedTuple of items related to rotor(s)\ncirculation::Matrix{Float} : blade element circulation values\npanel_strengths::Matrix{Float} : balde source panel strengths\nefficiency::Vector{Float} : rotor efficiency\ninviscid_thrust::Vector{Float} : inviscid componenets of rotor thrust\ninviscid_thrust_dist::Matrix{Float} : inviscid thrust component for each blade element\nviscous_thrust::Vector{Float} : viscous componenets of rotor thrust\nviscous_thrust_dist::Martix{Float} : viscous trhust component for each blade element\nthrust::Vector{Float} : total rotor thrusts\nCT::Vector{Float} : rotor thrust coefficients\ninviscid_torque::Vector{Float} : inviscid components of rotor torque\ninviscid_torque_dist::Matrix{Float} :inviscid torque component for each blade element\nviscous_torque::Vector{Float} : viscous components of rotor torque\nviscous_torque_dist::Matrix{Float} : viscous torque component for each blade element\ntorque::Vector{Float} : total rotor torques\nCQ::Vector{Float} : rotor torque coefficients\ninviscid_power::Vector{Float} : inviscid components of rotor power\ninviscid_power_dist::Matrix{Float} : inviscid power component for each blade element\nviscous_power::Vector{Float} : viscous components of rotor power\nviscous_power_dist::Matrix{Float} : viscous power component for each blade element\npower::Vector{Float} : total rotor powers\nCP::Vector{Float} : rotor power coefficients\ncl::Matrix{Float} : lift coefficient values for each blade element\ncd::Matrix{Float} : drag coefficient values for each blade element\nalpha::Matrix{Float} : angle of attack values for each blade element\nbeta1::Matrix{Float} : inflow angle values for each blade element\nblade_normal_force_per_unit_span::Matrix{Float} : normal force per unit span values for each blade element\nblade_tangential_force_per_unit_span::Matrix{Float} : tangential force per unit span values for each blade element\nwake::NamedTuple : NamedTuple containing items related to the wake\npanel_strengths::Vector{Float} : wake vortex panel strengths\ntotals::NamedTuple : NamedTuple containing total system values\nthrust::Vector{Float} : total system thrust\ntorque::Vector{Float} : total system torque\npower::Vector{Float} : total system power\nCT::Float : total system thrust coefficient\nCQ::Float : total system torque coefficient\nCP::Float : total system power coefficient\ntotal_efficiency::Vector{Float} : total propulsive efficiency\nideal_efficiency::Vector{Float} : ideal propulsive efficiency\nintermediate_solve_values::NamedTuple : NamedTuple containing items used inside the solver at their converged values.\nvz_rotor::Matrix{Float} : axial velocity induced on rotor blade elements\nvtheta_rotor::Matrix{Float} : swirl velocity induced on rotor blade elements\nreynolds::Matrix{Float} : Reynolds numbers at each blade element\nmach::Matrix{Float} : Mach numbers at each blade element\nCz_rotor::Matrix{Float} : absolute frame axial velocity at rotor blade elements\nCtheta_rotor::Matrix{Float} : absolute frame swirl velocity at rotor blade elements\nCmag_rotor::Matrix{Float} : absolute frame meridional velocity at rotor blade elements\nGamma_tilde::Matrix{Float} : net circulation of upstream and current blade elements\nH_tilde::Matrix{Float} : net enthalpy of upstream and current blade elements\ndeltaGamma2::Matrix{Float} : squared circulation changes between adjacent blade elements\ndeltaH::Matrix{Float} : enthalpy changes between adjacent blade elements\nvz_wake::Vector{Float} : axial velocity induced on wake control points\nvr_wake::Vector{Float} : radial velocity induced on wake control oints\nCm_wake::Vector{Float} : absolute frame meridional velocity at wake control points\nCm_avg::Vector{Float} : absolute frame meridional velocity at wake panel nodes\nreference_values::NamedTuple : NamedTuple containing items used in computing coefficient values\nVinf::Float : Freestream velocity used in coefficient definitions\nVref::Float : Reference velocity used in coefficient definitions\n\n\n\n\n\n","category":"function"},{"location":"C4Blade/airfoil_types/cascade/#Cascade-Types","page":"Cascade Types","title":"Cascade Types","text":"warning: Warning\nCascade types are currently in development and not ready for general use.\n\nCascade types are defined similarly to CCBlade airfoil types. Instead of angle of attack, however, cascade types take in both inflow and stagger angles. In addition, cascade types are dependent on local solidity. Currently only one such method is implemented, taking in inflow, stagger, solidity, Reynolds number, and Mach number.  Thus the lift and drag fields for this type are 5D arrays. Note that since the chord and twist are already fixed inputs to DuctAPE, the solidity and stagger angles are already known a priori.  In many cases, the CCBlade-like airfoil types are sufficient not only for airfoils, but also higher solidity cases.","category":"section"},{"location":"C4Blade/airfoil_types/cascade/#DuctAPE.C4Blade.InReStSoMaCAS","page":"Cascade Types","title":"DuctAPE.C4Blade.InReStSoMaCAS","text":"InReStSoMaCAS(inflow, Re, stagger, solidity, Mach, cl, cd)\nInReStSoMaCAS(filenames::Matrix{String}; radians=true)\n\nData is fit recursively with Akima splines.\n\nArguments\n\ninflow::Vector{Float64}: inflow angles\nRe::Vector{Float64}: Reynolds numbers\nstagger::Vector{Float64}: stagger angles\nsolidity::Vector{Float64}: local solidity\nMach::Vector{Float64}: Mach numbers\ncl::Array{Float64}: lift coefficients where cl[i, j, k, l, m] corresponds to inflow[i],  Re[j], stagger[k], solidity[l], Mach[m]\ncd::Array{Float64}: lift coefficients where cd[i, j, k, l, m] corresponds to inflow[i],  Re[j], stagger[k], solidity[l], Mach[m]\n\nor files with one per Re/Stagger/Solidty/Mach combination\n\nArguments\n\nfilenames::Matrix{String}: name/path of files to read in.  filenames[i, j, k, l] corresponds to Re[i], Stagger[j], Solidity[k], and Mach[l] with each in ascending order.\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/visualization/#Visualization","page":"Visualization","title":"Visualization","text":"There are several convenience plotting methods implemented in DuctAPE based on RecipesBase. In addition a general function for plotting the suite of available plots or animations is provided in the generate_plots function.\n\nThe following generates animations across the given advance ratios.\n\nwarning: Plotting Streamlines\nCurrently, plotting streamlines, especially animations, takes an exceptionally long time.\n\nusing Plots\n\n# - Advance Ratio Range - #\nadvance_ratios = range(0.1, 2.0; step=0.01)\n\n# - Calculate Vinfs - #\nD = 2.0 * rotor.Rtip[1] # rotor diameter\nn = RPM / 60.0 # rotation rate in revolutions per second\nVinfs = advance_ratios * n * D\n\n# - Set Operating Points - #\noperating_points = [deepcopy(operating_point) for i in 1:length(Vinfs)]\nfor (iv, v) in enumerate(Vinfs)\n    operating_points[iv].Vinf[] = v\nend\n\n# - Run Multi-point Analysis - #\nouts, ins, success_flags = DuctAPE.analyze(\n    ducted_rotor,\n    operating_points,\n    reference_parameters,\n    DuctAPE.set_options(\n        operating_points;\n        boundary_layer_options=DuctAPE.HeadsBoundaryLayerOptions(;\n            model_drag=true, n_steps=1000, separation_criteria=3.0\n        ),\n    );\n    return_inputs=true,\n)\n\nDuctAPE.generate_plots(\n    DuctAPE.animatedPlots(),\n    Plots, # Pass in the Plots namespace\n    ins,\n    outs;\n    plot_pressure=true,\n    plot_velocity=true,\n    plot_boundary_layer=true,\n    plot_streamlines=true,\n    save_path=\"../assets/\",\n    static_file_type=\".png\",\n    (;\n        custom_defaults...,\n        # size=(600,400), # causes misalignment issues\n        cp_ylim=(-3, 3), # keyword argument to set ylim for cp plots\n        vtan_ylim=(0, 3), # keyword argument to set ylim for vtan plots\n        bl_ylim=(0.1, 0.25), # keyword argument to set ylim for boundary layer plots\n    )...,\n)\nnothing # hide\n\nnote: Custom Defaults\nAdditional arguments splatted into generate_plots are passed into Plots.plot directly as keyword arguments.  In this case, custom_defaults happens to be the defaults associated with the plot formatting used in these docs.  Any arguments passed in this way will override any options set in the plots recipes for all the plots.  In the plots shown here, we have overridden the color palatte, but nothing else.\n\nwarning: Custom Sizes\nFor some reason, specifying figure size causes misalignment with pressure and velocity distributions and the underlayed geometry.\n\n(Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"section"},{"location":"DuctAPE/visualization/#DuctAPE.generate_plots-DuctAPE-visualization","page":"Visualization","title":"DuctAPE.generate_plots","text":"generate_plots(\n    ::staticPlots, #(or ::animatedPlots)\n    Plots,\n    ins,\n    outs;\n    save_path=\"\",\n    static_file_type=\".pdf\",\n    suffix=nothing,\n    plot_geometry=true,\n    plot_pressure=false,\n    plot_velocity=false,\n    plot_boundary_layer=false,\n    plot_streamlines=false,\n    verbose=false,\n    kwargs...,\n)\n\nGenerate standard suite of plots or animations from input and output objects.\n\nArguments:\n\n::staticPlots (or ::animatedPlots) : Dispatch type\nPlots:: : the Plots package namespace\nins::NamedTuple : returned inputs from analyze function\nouts::Vector{NamedTuple} : retured outputs from analyze function\n\nKeyword Arguments:\n\nsave_path=\"\" : custom save path\nstatic_file_type=\".pdf\" : file type for static files (must be compatible with the desired backend)\nsuffix=nothing : custom suffixes, if unused plots files will be numbered starting from 1.\nplot_geometry=true : flag to generate geometry plot\nplot_panels=false : flag to include markers indicating panel edges in geometry plot\nplot_pressure=false : flag to generate surface pressures plot\nplot_velocity=false : flag to generate surface velocities plot\nplot_boundary_layer=false : flag to generate boundary layer plot\nplot_streamlines=false : flag to generate streamlines plot\nverbose=false : print verbose statements\nkwargs... : arguments passed into the plot functions (Plots keyword arguments/defaults to be used in every plot)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/python_tutorial/#Calling-DuctAPE-from-Python","page":"Python","title":"Calling DuctAPE from Python","text":"In this example we repeat the quick start, but with Python.  We won't repeat all the usage details described in the quick start.  We are using the JuliaCall packages to enable this.","category":"section"},{"location":"DuctAPE/python_tutorial/#Setup","page":"Python","title":"Setup","text":"# optional: point python to a specific julia installation\n# import os\n# os.environ[\"JULIA_BINDIR\"] = path_to_julia\n\nfrom juliacall import Main as jl\n\n# If needed, install DuctAPE into the python julia environment\njl.seval(\"using Pkg\")\njl.Pkg.add(\"DuctAPE\")\n\n# Load DuctAPE\njl.seval(\"using DuctAPE\")\n\nimport numpy as np","category":"section"},{"location":"DuctAPE/python_tutorial/#Example","page":"Python","title":"Example","text":"# - Same Quick Start as Before, but with some minor changes for Python syntax - #\nduct_coordinates = np.array(\n    [\n        [0.304466, 0.158439],\n        [0.294972, 0.158441],\n        [0.28113, 0.158423],\n        [0.266505, 0.158365],\n        [0.251898, 0.158254],\n        [0.237332, 0.158088],\n        [0.222751, 0.157864],\n        [0.208123, 0.157586],\n        [0.193399, 0.157258],\n        [0.178507, 0.156897],\n        [0.16349, 0.156523],\n        [0.148679, 0.156177],\n        [0.134222, 0.155902],\n        [0.12, 0.155721],\n        [0.106044, 0.155585],\n        [0.092531, 0.155498],\n        [0.079836, 0.155546],\n        [0.067995, 0.155792],\n        [0.057025, 0.156294],\n        [0.046983, 0.157103],\n        [0.037937, 0.158256],\n        [0.029956, 0.159771],\n        [0.02311, 0.161648],\n        [0.017419, 0.163862],\n        [0.012842, 0.166404],\n        [0.009324, 0.169289],\n        [0.006854, 0.172546],\n        [0.005484, 0.176154],\n        [0.005242, 0.180005],\n        [0.006112, 0.184067],\n        [0.00809, 0.188086],\n        [0.011135, 0.192004],\n        [0.015227, 0.19579],\n        [0.020339, 0.199393],\n        [0.026403, 0.202735],\n        [0.033312, 0.205736],\n        [0.040949, 0.208332],\n        [0.049193, 0.210487],\n        [0.057935, 0.212174],\n        [0.067113, 0.21339],\n        [0.076647, 0.214136],\n        [0.086499, 0.214421],\n        [0.09661, 0.214255],\n        [0.10695, 0.213649],\n        [0.117508, 0.212618],\n        [0.12838, 0.211153],\n        [0.139859, 0.209267],\n        [0.151644, 0.207051],\n        [0.163586, 0.204547],\n        [0.175647, 0.201771],\n        [0.187807, 0.198746],\n        [0.20002, 0.19549],\n        [0.212269, 0.192017],\n        [0.224549, 0.188335],\n        [0.236794, 0.18447],\n        [0.249026, 0.180416],\n        [0.261206, 0.176188],\n        [0.273301, 0.171796],\n        [0.28524, 0.16727],\n        [0.29644, 0.162842],\n        [0.304542, 0.159526],\n    ]\n)\n\ncenter_body_coordinates = np.array(\n    [\n        [0.0, 0.0],\n        [0.000586, 0.005293],\n        [0.002179, 0.010047],\n        [0.004736, 0.014551],\n        [0.008231, 0.018825],\n        [0.012632, 0.022848],\n        [0.01788, 0.026585],\n        [0.023901, 0.030001],\n        [0.030604, 0.033068],\n        [0.0379, 0.035771],\n        [0.045705, 0.038107],\n        [0.053933, 0.040075],\n        [0.06254, 0.04169],\n        [0.071451, 0.042966],\n        [0.08063, 0.043916],\n        [0.090039, 0.044561],\n        [0.09968, 0.044922],\n        [0.109361, 0.044999],\n        [0.12, 0.044952],\n        [0.135773, 0.04495],\n        [0.151899, 0.04493],\n        [0.16806, 0.044913],\n        [0.184232, 0.044898],\n        [0.200407, 0.044882],\n        [0.21658, 0.044866],\n        [0.232723, 0.044847],\n        [0.248578, 0.044839],\n        [0.262095, 0.044564],\n        [0.274184, 0.043576],\n        [0.285768, 0.041795],\n        [0.296701, 0.039168],\n        [0.306379, 0.035928],\n    ]\n)\n\n# number of rotors\nB = 5\n\n# rotor axial location\nrotor_axial_position = 0.12\n\n# rotor tip radius\nRtip = 0.15572081487373543\n\n# rotor hub radius\nRhub = 0.04495252299071941\n\n# non-dimensional blade element radial stations\nr = (\n    np.array(\n        [\n            0.050491,\n            0.061567,\n            0.072644,\n            0.083721,\n            0.094798,\n            0.10587,\n            0.11695,\n            0.12803,\n            0.13911,\n            0.15018,\n        ]\n    )\n    / Rtip\n)\n\n# dimensional chord lengths\nchords = np.array(\n    [\n        0.089142,\n        0.079785,\n        0.0713,\n        0.063979,\n        0.057777,\n        0.052541,\n        0.048103,\n        0.044316,\n        0.041061,\n        0.038243,\n    ]\n)\n\n# twist angles (from plane of rotation) in radians\ntwists = (\n    np.array(\n        [\n            69.012,\n            59.142,\n            51.825,\n            46.272,\n            41.952,\n            38.509,\n            35.699,\n            33.354,\n            31.349,\n            29.596,\n        ]\n    )\n    * np.pi\n    / 180.0\n)\n\n# DFDC-type airfoil object\nafparams = jl.DuctAPE.c4b.DFDCairfoil(\n    alpha0=0.0,\n    clmax=1.5,\n    clmin=-1.0,\n    dclda=6.28,\n    dclda_stall=0.5,\n    dcl_stall=0.2,\n    cdmin=0.012,\n    clcdmin=0.1,\n    dcddcl2=0.005,\n    cmcon=0.0,\n    Re_ref=2e5,\n    Re_exp=0.35,\n    mcrit=0.7,\n)\n\n# all airfoils are the same\n# NOTE: airfoils are inputs as a vector of vectors rather than a matrix\nairfoils = [[afparams] * len(r)]\n\n# Assemble Rotor object\nrotor = jl.DuctAPE.Rotor(\n    B,\n    rotor_axial_position,\n    r,\n    Rhub,\n    Rtip,\n    chords,\n    twists,\n    [0.0],  # tip gap vector\n    airfoils,  # vector-of-vectors of DFDCairfoil objects\n    [0.0],  # is_stator flag vector\n)\n\n# number of panels for the duct inlet\nnum_duct_inlet_panels = 30\n\n# number of panels for the center body inlet\nnum_center_body_inlet_panels = 30\n\n# number of panels:\n#  - rotor  duct TE\n#  - duct TE  center-body TE\n#  - center-body TE  end of wake\nnum_panels = [30, 1, 30]\n\n# duct TE ahead of center-body TE\ndte_minus_cbte = -1.0\n\n# number of wake sheets (one more than blade elements)\nnum_wake_sheets = 11\n\n# non-dimensional wake length aft of rear-most TE\nwake_length = 0.8\n\n# assemble paneling constants\npaneling_constants = jl.DuctAPE.PanelingConstants(\n    num_duct_inlet_panels,\n    num_center_body_inlet_panels,\n    num_panels,\n    dte_minus_cbte,\n    num_wake_sheets,\n    wake_length,\n)\n\n# assemble ducted rotor object\nducted_rotor = jl.DuctAPE.DuctedRotor(\n    duct_coordinates,\n    center_body_coordinates,\n    rotor,\n    paneling_constants,\n)\n\n# Freestream\nVinf = 30.0\nrhoinf = 1.226\nasound = 340.0\nmuinf = 1.78e-5\n\n# Rotation rate\nRPM = 8000.0\nOmega = RPM * np.pi / 30.0  # rad/s\n\n# assemble operating point\noperating_point = jl.DuctAPE.OperatingPoint(\n    Vinf,\n    Omega,\n    rhoinf,\n    muinf,\n    asound,\n)\n\n# reference velocity (close to average axial velocity at rotor)\nVref = 50.0\n\n# reference radius (usually rotor tip radius)\nRref = Rtip\n\n# assemble reference parameters\nreference_parameters = jl.DuctAPE.ReferenceParameters(\n    [Vref],\n    [Rref],\n)\n\n# set options\noptions = jl.DuctAPE.set_options()\n\n# Run DuctAPE\nouts, success_flag = jl.DuctAPE.analyze(\n    ducted_rotor,\n    operating_point,\n    reference_parameters,\n    options,\n)\n\n# Print some outputs.\nprint(\"CT: \", outs.totals.CT)\nprint(\"CQ: \", outs.totals.CQ)","category":"section"},{"location":"DuctAPE/python_tutorial/#Automatic-Derivatives","page":"Python","title":"Automatic Derivatives","text":"We now continue the example demonstrating how to get derivatives for use in Python (but where the derivative computation occurs in Julia via algorithmic differentiation).  For this functionality we need to load the PythonCall package (which enables us to call back into Python from Julia), and we need the ImplicitAD packages which provides a convenience function for the derivative computation.  Alternatively, for more advanced users you can just use the Julia differentiation packages directly (ForwardDiff, ReverseDiff, etc.).  Note that for Julia AD to work, all the function calls will need to be Julia function calls.  Even though all the setup is happening here in Python, we are only setting up inputs.  All functions are calls to Julia (jl.somefunction())\n\nThe below example demonstrates a forward mode Jacobian and a forward mode Jacobian-vector product.  Other options (reverse Jacobian, reverse vector-Jacobian product) are discussed in ImplicitAD docs.\n\n# load PythonCall BEFORE ImplicitAD\njl.seval(\"using PythonCall\")\n\n# Install ImplicitAD as needed\njl.seval(\"using Pkg\")\njl.Pkg.add(\"ImplicitAD\")\n\n# Load ImplicitAD.derivativesetup\njl.seval(\"using ImplicitAD: derivativesetup\")\n\nnc = len(chords)\n\n# ImplicitAD expects a funciton we want to differentiate in the form f = func(x, p)\n# where f is output vector, x is input vector, and p are parameters we do not differentiate w.r.t.\ndef dtwrap(x, p):\n    chords = x[:nc]\n    twists = x[nc:]\n\n    # Assemble Rotor object\n    rotor = jl.DuctAPE.Rotor(\n        B,\n        rotor_axial_position,\n        r,\n        Rhub,\n        Rtip,\n        chords,\n        twists,\n        [0.0],  # tip gap vector\n        airfoils,  # vector-of-vectors of DFDCairfoil objects\n        [0.0],  # is_stator flag vector\n    )\n\n    # assemble ducted rotor object\n    ducted_rotor = jl.DuctAPE.DuctedRotor(\n        duct_coordinates,\n        center_body_coordinates,\n        rotor,\n        paneling_constants,\n    )\n\n    # Run DuctAPE\n    outs, success_flag = jl.DuctAPE.analyze(\n        ducted_rotor,\n        operating_point,\n        reference_parameters,\n        options,\n    )\n\n    return [outs.totals.CT, outs.totals.CQ]\n\n\nx = np.concatenate([chords, twists])\np = ()\njacobian = jl.derivativesetup(\n    dtwrap, x, p, \"fjacobian\"\n)  # a forward-mode Jacobian is one option\n\n# preallocate Jacobian then evaluate\nJ = np.zeros((2, len(x)))\njacobian(J, x)\nprint(J)\n# can now change x, and evaluate jacobian(J, x) repeatedly at other points\n\n\n# demonstrate a Jacobian-vector product\njvp = jl.derivativesetup(dtwrap, x, p, \"jvp\")\nxdot = np.ones(len(x))\nfdot = np.zeros(2)\njvp(fdot, x, xdot)\nprint(fdot)\n# can continue to call jvp for different x, xdot pairs","category":"section"},{"location":"C4Blade/intro/#C\\textrm{4}Blade-[[C](#)ascade-[C](#)ompatible-[CCBlade](https://flow.byu.edu/CCBlade.jl/stable/)]","page":"Intro","title":"C^textrm4Blade [Cascade Compatible CCBlade]","text":"C^4Blade is a DuctAPE submodule containing a modified version of CCBlade for use in DuctAPE as well as several additional helper functions related to blade section polars.","category":"section"},{"location":"C4Blade/intro/#Airfoil-Types","page":"Intro","title":"Airfoil Types","text":"Type Inputs Status\nAlphaAF angle of attack \nAlphaReAF angle of attack, Reynolds \nAlphaMachAF angle of attack, Mach \nAlphaReMachAF angle of attack, Reynolds, Mach \nDFDCairfoil angle of attack, Reynolds, Mach, solidity, stagger \nADM none \nInReStSoMaCAS inflow angle, Reynolds, stagger, solidity, Mach \n\nKey:\n\n Implemented\n Under Development","category":"section"},{"location":"DuctAPE/theory/#Theory","page":"Theory","title":"Theory","text":"For a brief overview of the theory behind DuctAPE, see:\n\nMehr, J. and Ning, A., \"DuctAPE: A steady-state, axisymmetric ducted fan analysis code designed for gradient-based optimization.,\" AIAA Aviation Forum, July 2024.\n\nFor a more thorough dive into the details see this pdf document.","category":"section"},{"location":"DuctAPE/api/inputs/#Required-Inputs","page":"Required Inputs","title":"Required Inputs","text":"As briefly described in the Quick Start there are three required inputs to the analysis function: a DuctedRotor object, comprised of duct and center body coordinates, a Rotor object, and a PanelingConstants object; an OperatingPoint or vector of operating point objects; and a ReferenceParameters object.","category":"section"},{"location":"DuctAPE/api/inputs/#DuctedRotor","page":"Required Inputs","title":"DuctedRotor","text":"The DuctedRotor input contains all the information related to the geometry of the ducted rotor system and how that geometry will be handled in the preprocessing stage of the analysis.","category":"section"},{"location":"DuctAPE/api/inputs/#Duct-and-Center-Body-Coordinates","page":"Required Inputs","title":"Duct and Center Body Coordinates","text":"The duct and center body coordinates are input into the DuctedRotor type in the order of duct then center body. Both sets of coordinates must be given in a counter-clockwise order. For the duct, that means the coordinates start at the inside trailing edge, and continue clockwise around the leading edge and end at the outside trailing edge. For the center body, that means the coordintes start at the leading edge and end at the trailing edge. In addition, the coordinates are expected to be provided in columns of the format [z r], where z are the axial coordinates and r are the radial coordinates (analogous to x and y common for 2D airfoils). There are several checks in place when the DuctedRotor object is constructed to attempt to ensure the formats are correct, but it would be best to input things correctly in the first place.","category":"section"},{"location":"DuctAPE/api/inputs/#Rotor","page":"Required Inputs","title":"Rotor","text":"The Rotor object contains mostly information about the rotor blade geometry, but also includes details used for the blade section lift and drag polar lookups. For the most part, the inputs are pretty straightforward and the docstring below is sufficient to understand what they are. In general, the blade geometry should be defined from hub to tip, therefore the radial locations should be monotonically increasing. Care should be taken to note which inputs are dimensional and which are non-dimensional. It should also be noted that the rotor inputs are always interpolated as part of the analysis preprocess.","category":"section"},{"location":"DuctAPE/api/inputs/#Airfoils","page":"Required Inputs","title":"Airfoils","text":"The input with the most flexibility in the Rotor object is the airfoils input. These \"airfoils\" are really the methods for looking up the lift and drag polar values given inputs such as angle of attack, Reynolds number, Mach number, etc. Airfoil types for DuctAPE are currently contained in the C^textrm4Blade sub-module of DuctAPE which is exported as c4b and also contains the various airfoil evaluation functions used for the blade element lookups. The available airfoil types include all the airfoil types from CCBlade, as well as DFDCairfoil which is an XROTOR-like parametric cascade polar used in DFDC. In addition there are untested cascade types with similar structure to CCBlades airfoil types called DTCascade. Furthermore, there is an experimental actuator disk model implemented via the ADM airfoil type in C4Blade.  Any airfoil object used needs to be able to be deconstructed into a vector for compatiblity with PreallocationTools (see Precompiled Caches below) and then automatedly reconstructed inside the solve.  This process has been generalized for all the C4Blade airfoil types, and should work without much issue for other types as long as the airfoil type fields are arrays of numbers. In addition, if custom user types are added, they must be of one of the C4Blade abstract airfoil types, otherwise DuctAPE will not know which evalutaion function to use and throw an error.","category":"section"},{"location":"DuctAPE/api/inputs/#PanelingConstants","page":"Required Inputs","title":"PanelingConstants","text":"The PanelingConstants object contains all the information required to dictate how the preprocess repanling will take place and almost all of the information required to generate the precompiled caches.\n\nThe first two inputs dictate the number panels that should be used in repaneling the region of each body from their respective leading edge to the axial position of the first rotor. Note that even though we have called this region the inlet, it really controls the number of panels ahead of the first rotor's axial position. The num_panels input is a vector describing the number of panels to be linearly spaced between each discrete location in the system, where discrete locations are rotor axial positions as well as the axial position of the body trailing edges (in the case of the duct, this is the interior trailing edge, even though the exterior trailing edge could be further back in the case where a trailing edge gap is present).\n\nThe dte_minus_cbte is the duct trailing edge axial position minus the center body trailing edge axial position. If it is zero, the axial positions of duct and center body trailing edge must be exactly equal.\n\nThe num_wake_sheets controls how many blade elements are interpolated from the Rotor input.  The wake sheets are linearly interpolated along the first rotor from center body to duct, so there are one fewer blade elements than wake sheets. Note that there is no way to manually control how the wake aligns with rotors aft of the first rotor, so those rotor inputs will be interpolated at the points at which the wake sheets align.\n\nThe wake_length input defaults to 1.0 and we have found that to be a generally reasonable value. Note that a shorter or longer wake will not lead to a change in number of panels since the last entry in num_panels controls that.","category":"section"},{"location":"DuctAPE/api/inputs/#OperatingPoint","page":"Required Inputs","title":"OperatingPoint","text":"The OperatingPoint inputs contains all the information concering the freestream as well as the rotor rotation rate(s). Note that the pressure and temperature fields in the struct are currently unused. For analyses with multiple operating points a vector of these objects should be used, even though many of the fields will be repeated.","category":"section"},{"location":"DuctAPE/api/inputs/#ReferenceParameters","page":"Required Inputs","title":"ReferenceParameters","text":"The ReferenceParameters are only used in the postprocessing to compute various coefficients. Usually, the reference radius is simply the rotor tip radius. The reference velocity may be selected as the freestream velocity, but often may not be, for example in the case of zero freestream velocity (static conditions), the reference velocity should probably be some non-zero value such that the coefficients don't simply return zeros or infinities.","category":"section"},{"location":"DuctAPE/api/inputs/#DuctAPE.DuctedRotor","page":"Required Inputs","title":"DuctAPE.DuctedRotor","text":"DuctedRotor(\n    duct_coordinates, center_body_coordinates, rotor, paneling_constants; kwargs...\n)\n\nArguments\n\nduct_coordinates::AbstractMatrix : The [z r] coordinates of the duct geometry beginning at the inner (casing) side trailing edge and proceeding clockwise. Note that the duct geometry absolute radial position does not need to be included here if the autoshiftduct option is selected.\ncenter_body_coordinates::AbstractMatrix : The [z r] coordinates of the center_body beginning at the leading edge and ending at the trailing edge. Note that the leading edge is assumed to be placed at a radial distance of 0.0 from the axis of rotation.\nrotor::Rotor : Rotor (and possibly stator) geometric paramters.\npaneling_constants::PanelingConstants : Constants used in re-paneling the geometry.\n\nKeyword Arguments\n\ni_know_what_im_doing::Bool=false : if set to false, performs various checks on the inputs and manually adjusts in some cases with a warning, and errors in cases that cannot be automatically adjusted.\nsilence_warnings::Bool=false : if set to false, prints warnings when automatically adjusting inputs.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/inputs/#DuctAPE.Rotor","page":"Required Inputs","title":"DuctAPE.Rotor","text":"Rotor(\n    B, rotor_axial_position, r, Rhub, Rtip, chords, twists, tip_gap, airfoils, is_stator\n)\n\nComposite type containing the rotor(s) geometric properties.\n\nNote that the actual struct requires the inputs to be arrays, but there is a constructor function that will take in scalars and automatically build the array-based struct.\n\nArguments\n\nB::AbstractVector{Float} : The number of blades for each rotor. May not be an integer, but usually is.\nrotor_axial_position::AbstractVector{Float} : Dimensional, axial position of each rotor.\nr::AbstractArray{Float} : Non-dimensional radial locations of each blade element.\nRhub::AbstractVector{Float} : Dimensional hub radius of rotor. (may be changed if it does not match the radial position of the center_body geometry at the selected rotor_axial_position.\nRtip::AbstractVector{Float} : Dimensional tip radius of rotor. Is used to determine the radial position of the duct if the autoshiftduct option is selected.\nchords::AbstractArray{Float} : Dimensional chord lengths of the blade elements.\ntwists::AbstractArray{Float} : Blade element angles, in radians.\ntip_gap::AbstractVector{Float} : Currently unused, do not set to anything other than zeros.\nairfoils::Vector{Vector{AFType}} : Airfoil types describing the airfoil polars for each rotor and blade element [[rotor 1 airfoils], [rotor 2 airfoils], ...].\nis_stator::AbstractVector{Bool} : Flag to indicate if the airfoil lift values should be flipped or not.\n\nKeyword Arguments\n\ni_know_what_im_doing::Bool=false : if set to false, checks the twist angles, and if greater than 1.75, prints a warning and converts from degrees to radians.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/inputs/#DuctAPE.PanelingConstants","page":"Required Inputs","title":"DuctAPE.PanelingConstants","text":"PanelingConstants(\n    num_duct_inlet_panels,\n    num_center_body_inlet_panels,\n    num_panels,\n    dte_minus_cbte,\n    num_wake_sheets,\n    wake_length=1.0,\n)\n\nConstants used in re-paneling geometry.\n\nNote that unlike other input structures, this one, in general, does not define fields as vectors.  This is because these values should not change throughout an optimization, even if the geometry may change.  Otherwise, discontinuities could be experienced.\n\nArguments\n\nnum_duct_inlet_panels::Int : The number of panels to use for the casing inlet.\nnum_center_body_inlet_panels::Int : The number of panels to use for the center body inlet.\nnum_panels::AbstractVector{Int} : A vector containing the number of panels between discrete locations inside the wake. Specifically, the number of panels between the rotors, between the last rotor and the first body trailing edge, between the body trailing edges (if different), and between the last body trailing edge and the end of the wake.  The length of this vector should be N+1 (where N is the number of rotors) if the duct and center_body trailing edges are aligned, and N+2 if not.\ndte_minus_cbte::Float : An indicator concerning the hub and duct trailing edge relative locations. Should be set to -1 if the duct trailing edge axial position minus the center_body trailing edge axial position is negative, +1 if positive (though any positive or negative number will suffice), and zero if the trailing edges are aligned.\nnum_wake_sheets::Int : The number of wake sheets to use. Note this will also be setting the number of blade elements to use.\nwake_length::Float=1.0 : Non-dimensional (based on the length from the foremost body leading edge and the aftmost body trailing edge) length of the wake extending behind the aftmost body trailing edge.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/inputs/#DuctAPE.OperatingPoint","page":"Required Inputs","title":"DuctAPE.OperatingPoint","text":"OperatingPoint(Vinf, Minf, rhoinf, muinf, asound, Ptot, Ttot, Omega)\nOperatingPoint(\n    Vinf, Omega, rhoinf=nothing, muinf=nothing, asound=nothing; altitude=0.0\n)\nOperatingPoint(\n    ::Imperial, Vinf, Omega, rhoinf=nothing, muinf=nothing, asound=nothing; altitude=0.0\n)\n\nDuctedRotor operating point information.\n\nFunctions that take in altitude will populate undefined thermodynamic properties of the freestream using a standard atmosphere model, ideal gas law, and Sutherland's law; defaulting to SI units. If the ::Imperial dispatch type is input, then the thermodynamic properties will be converted to Imperial units.\n\nFields/Arguments\n\nVinf::AbstractVector{Float} : Freestream velocity magnitude (which is only in the axial direction).\nMinf::AbstractVector{Float} : Freestream Mach number\nrhoinf::AbstractVector{Float} : Freestream density\nmuinf::AbstractVector{Float} : Freestream viscosity\nasound::AbstractVector{Float} : Freestream speed of sound\nPtot::AbstractVector{Float} : Freestream total pressure\nTtot::AbstractVector{Float} : Freestream total temperature\nOmega::AbstractVector{Float} : Rotor rototation rate(s)\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/inputs/#DuctAPE.ReferenceParameters","page":"Required Inputs","title":"DuctAPE.ReferenceParameters","text":"ReferenceParameters(Vref, Rref)\n\nReference parameters for post-process non-dimensionalization.\n\nNote that the actual struct requires the inputs to be arrays, but there is a constructor function that will take in scalars and automatically build the array-based struct.\n\nArguments\n\nVref::AbstractVector{Float} : Reference velocity.\nRref::AbstractVector{Float} : Reference rotor tip radius.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"Since the remaining API references here involve the inputs and outputs of the analysis function, we begin by looking at the analyze function. In general, there are two main dispatches that will be used in the vast majority of use cases. The first is for a single operating point, and the second is for multiple operating points. They are identical, except for the multiple operating point dispatch requiring a vector of operating points and returning a vector of output objects.","category":"section"},{"location":"DuctAPE/api/analysis/#DuctAPE.analyze-Tuple{DuctedRotor, OperatingPoint, ReferenceParameters}","page":"Analysis","title":"DuctAPE.analyze","text":"analyze(\n    ducted_rotor::DuctedRotor,\n    operating_point::OperatingPoint,\n    reference_parameters::ReferenceParameters,\n    options::Options=set_options();\n    prepost_container_caching=nothing,\n    solve_parameter_caching=nothing,\n    solve_container_caching=nothing,\n    return_inputs=false,\n)\n\nAnalyze ducted_rotor, including preprocessing.\n\nArguments\n\nducted_rotor::DuctedRotor : DuctedRotor input object (see docstring for DuctedRotor type)\noperating_point::OperatingPoint : OperatingPoint input object (see docstring for OperatingPoint type)\nreference_parameters::ReferenceParameters : ReferenceParameters input object (see docstring for ReferenceParameters type)\noptions::Options=set_options() : Options object (see set_options and related functions)\n\nKeyword Arguments\n\nprepost_container_caching=nothing : Output of allocate_prepost_container_cache\nsolve_parameter_caching=nothing : Output of allocate_solve_parameter_container_cache\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::NamedTuple : Named Tuple of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\n","category":"method"},{"location":"DuctAPE/api/analysis/#DuctAPE.analyze-Tuple{DuctedRotor, AbstractVector{OperatingPoint}, ReferenceParameters}","page":"Analysis","title":"DuctAPE.analyze","text":"analyze(\n    ducted_rotor::DuctedRotor,\n    operating_point::AbstractVector{OperatingPoint},\n    reference_parameters::ReferenceParameters,\n    options::Options=set_options();\n    prepost_container_caching=nothing,\n    solve_parameter_caching=nothing,\n    solve_container_caching=nothing,\n    return_inputs=false,\n)\n\nAnalyze ducted_rotor, including preprocessing, for a set of operating points.\n\nArguments\n\nducted_rotor::DuctedRotor : DuctedRotor input object\noperating_point::AbstractVector{OperatingPoint} : Vector of Operating Points at which to analyze the ducted_rotor\nreference_parameters::ReferenceParameters : ReferenceParameters input object (see docstring for ReferenceParameters type)\noptions::Options=set_options() : Options object\n\nKeyword Arguments\n\nprepost_container_caching=nothing : Output of allocate_prepost_container_cache\nsolve_parameter_caching=nothing : Output of allocate_solve_parameter_container_cache\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\napply_warm_start=true : flag as to whether or not to apply a warm-start re-run of unconverged operating points from nearby converged ones.\n\nReturns\n\nouts::Vector{NamedTuple} : Vector of named tuples of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\n","category":"method"},{"location":"#DuctAPE.jl-[[Duct](#)ed-[A](#)xisymmetric-[P](#)ropulsor-[E](#)valuation]","page":"Home","title":"DuctAPE.jl [Ducted Axisymmetric Propulsor Evaluation]","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Code Style: Blue)\n\nDuctAPE is a code for the aerodynamic evaluation of axisymmetric ducted rotors designed for incompressible (low mach) applications. It is strongly influenced by the underlying theory of Ducted Fan Design Code (DFDC), utilizing a linear axisymmetric vortex panel method for duct and center body, blade element actuator line rotor representation, and psuedo wake-screw wake model axisymmetrically smeared onto an elliptic grid for efficient computation.\n\nDuctAPE has been developed specifically for applications in gradient-based optimization settings. The default solver methods have been chosen to balance code efficiency as well as robustness while simultaneously allowing for efficient automatic differentiation through DuctAPE employing ImplicitAD.jl.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"pkg> add DuctAPE","category":"section"},{"location":"#Publications","page":"Home","title":"Publications","text":"Mehr, J., and Ning, A., DuctAPE: A steady-state, axisymmetric ducted fan analysis code designed for gradient-based optimization., AIAA Aviation Forum, Las Vegas, Jul. 2024. doi:10.2514/6.2024-4297","category":"section"},{"location":"DuctAPE/tutorial/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"Pages = [\"tutorial.md\"]\nDepth = 5\n\nThe following is a basic tutorial on how to set up and run an analysis of a ducted fan in DuctAPE.\n\nWe begin by loading the package:\n\nusing DuctAPE\nnothing # hide","category":"section"},{"location":"DuctAPE/tutorial/#Assemble-Inputs","page":"Quick Start","title":"Assemble Inputs","text":"The next step is to create the input object of type DuctedRotor, which contains duct and center body coordinates, rotor inputs, as well as several constants related to paneling the geometry.","category":"section"},{"location":"DuctAPE/tutorial/#Body-Geometry","page":"Quick Start","title":"Body Geometry","text":"We begin by defining a matrix of coordinates for the duct and another for the center body geometries.\n\nduct_coordinates = [\n    0.304466  0.158439\n    0.294972  0.158441\n    0.28113   0.158423\n    0.266505  0.158365\n    0.251898  0.158254\n    0.237332  0.158088\n    0.222751  0.157864\n    0.208123  0.157586\n    0.193399  0.157258\n    0.178507  0.156897\n    0.16349   0.156523\n    0.148679  0.156177\n    0.134222  0.155902\n    0.12      0.155721\n    0.106044  0.155585\n    0.092531  0.155498\n    0.079836  0.155546\n    0.067995  0.155792\n    0.057025  0.156294\n    0.046983  0.157103\n    0.037937  0.158256\n    0.029956  0.159771\n    0.02311   0.161648\n    0.017419  0.163862\n    0.012842  0.166404\n    0.009324  0.169289\n    0.006854  0.172546\n    0.005484  0.176154\n    0.005242  0.180005\n    0.006112  0.184067\n    0.00809   0.188086\n    0.011135  0.192004\n    0.015227  0.19579\n    0.020339  0.199393\n    0.026403  0.202735\n    0.033312  0.205736\n    0.040949  0.208332\n    0.049193  0.210487\n    0.057935  0.212174\n    0.067113  0.21339\n    0.076647  0.214136\n    0.086499  0.214421\n    0.09661   0.214255\n    0.10695   0.213649\n    0.117508  0.212618\n    0.12838   0.211153\n    0.139859  0.209267\n    0.151644  0.207051\n    0.163586  0.204547\n    0.175647  0.201771\n    0.187807  0.198746\n    0.20002   0.19549\n    0.212269  0.192017\n    0.224549  0.188335\n    0.236794  0.18447\n    0.249026  0.180416\n    0.261206  0.176188\n    0.273301  0.171796\n    0.28524   0.16727\n    0.29644   0.162842\n    0.304542  0.159526\n]\nnothing # hide\n\ncenter_body_coordinates = [\n    0.0       0.0\n    0.000586  0.005293\n    0.002179  0.010047\n    0.004736  0.014551\n    0.008231  0.018825\n    0.012632  0.022848\n    0.01788   0.026585\n    0.023901  0.030001\n    0.030604  0.033068\n    0.0379    0.035771\n    0.045705  0.038107\n    0.053933  0.040075\n    0.06254   0.04169\n    0.071451  0.042966\n    0.08063   0.043916\n    0.090039  0.044561\n    0.09968   0.044922\n    0.109361  0.044999\n    0.12      0.044952\n    0.135773  0.04495\n    0.151899  0.04493\n    0.16806   0.044913\n    0.184232  0.044898\n    0.200407  0.044882\n    0.21658   0.044866\n    0.232723  0.044847\n    0.248578  0.044839\n    0.262095  0.044564\n    0.274184  0.043576\n    0.285768  0.041795\n    0.296701  0.039168\n    0.306379  0.035928\n]\nnothing # hide\n\npg = plot( # hide\n    duct_coordinates[:, 1], # hide\n    duct_coordinates[:, 2]; # hide\n    aspectratio=1, # hide\n    color=1, # hide\n    linewidth=2, # hide\n    label=\"Duct\", # hide\n    xlabel=\"z\", # hide\n    ylabel=\"r\", # hide\n    legend=:left, # hide\n) # hide\nplot!( # hide\n    pg, # hide\n    center_body_coordinates[:, 1], # hide\n    center_body_coordinates[:, 2]; # hide\n    color=2, # hide\n    linewidth=2, # hide\n    label=\"Center Body\", # hide\n) # hide\n\nnote: Note\nThe body geometry coordinates must be input as columns of z (axial) and r (radial) coordinates, in that order.","category":"section"},{"location":"DuctAPE/tutorial/#Rotor-Geometry","page":"Quick Start","title":"Rotor Geometry","text":"The next step is to assemble an object of type Rotor which contains the geometric information required to define the rotor(s) and their respective blade elements. In this example, we have a single rotor defined as follows.\n\n# number of rotor blades\nB = 5\n\n# rotor axial location\nrotor_axial_position = 0.12\n\n# rotor tip radius\nRtip = 0.15572081487373543\n\n# rotor hub radius\nRhub = 0.04495252299071941\n\n# non-dimensional blade element radial stations\nr = [\n    0.050491\n    0.061567\n    0.072644\n    0.083721\n    0.094798\n    0.10587\n    0.11695\n    0.12803\n    0.13911\n    0.15018\n] ./ Rtip\n\n# dimensional chord lengths\nchords = [\n    0.089142\n    0.079785\n    0.0713\n    0.063979\n    0.057777\n    0.052541\n    0.048103\n    0.044316\n    0.041061\n    0.038243\n]\n\n# twist angles (from plane of rotation) in radians\ntwists = [\n    69.012\n    59.142\n    51.825\n    46.272\n    41.952\n    38.509\n    35.699\n    33.354\n    31.349\n    29.596\n] .* pi / 180.0\n\n# DFDC-type airfoil object\nafparams = DuctAPE.c4b.DFDCairfoil(;\n    alpha0=0.0,\n    clmax=1.5,\n    clmin=-1.0,\n    dclda=6.28,\n    dclda_stall=0.5,\n    dcl_stall=0.2,\n    cdmin=0.012,\n    clcdmin=0.1,\n    dcddcl2=0.005,\n    cmcon=0.0,\n    Re_ref=2e5,\n    Re_exp=0.35,\n    mcrit=0.7,\n)\n\n# all airfoils are the same\n# NOTE: airfoils are inputs as a vector of vectors rather than a matrix\nairfoils = [fill(afparams, length(r))] # specify the airfoil array\n\n# assemble rotor parameters\nrotor = DuctAPE.Rotor(\n    B,\n    rotor_axial_position,\n    r,\n    Rhub,\n    Rtip,\n    chords,\n    twists,\n    [0.0], # tip gap: currently only zero tip gaps work.\n    airfoils,\n    [0.0], # is_stator: can flip the cl lookups on the fly if desired, say, for stator sections\n)\nnothing # hide\n\nplot!( # hide\n    pg, # hide\n    rotor_axial_position * ones(length(r)), # hide\n    r .* Rtip; # hide\n    seriestype=:scatter, # hide\n    markersize=3, # hide\n    markerstrokewidth=0, # hide\n    label=\"Blade Elements\", # hide\n) # hide","category":"section"},{"location":"DuctAPE/tutorial/#Paneling-Constants","page":"Quick Start","title":"Paneling Constants","text":"The PanelingConstants object contains the constants required for DuctAPE to re-panel the provided geometry into a format compatible with the solve structure. Specifically, the DuctAPE solver makes some assumptions on the relative positioning of the body surfaces relative to the wakes and each other; and this is most easily guarenteed by a re-paneling of the provided body surface geometry.\n\n# number of panels for the duct inlet\nnum_duct_inlet_panels = 30\n\n# number of panels for the center body inlet\nnum_center_body_inlet_panels = 30\n\n# number of panels from:\n#  - rotor to duct trailing edge\n#  - duct trailing edge to center body trailing edge\n#  - center body trailing edge to end of wake\nnum_panels = [30, 1, 30]\n\n# the duct trailing edge is ahead of the center_body trailing edge.\ndte_minus_cbte = -1.0\n\n# number of wake sheets (one more than blade elements to use)\nnum_wake_sheets = 11\n\n# non-dimensional wake length aft of rear-most trailing edge\nwake_length = 0.8\n\n# assemble paneling constants\npaneling_constants = DuctAPE.PanelingConstants(\n    num_duct_inlet_panels,\n    num_center_body_inlet_panels,\n    num_panels,\n    dte_minus_cbte,\n    num_wake_sheets,\n    wake_length,\n)\nnothing # hide\n","category":"section"},{"location":"DuctAPE/tutorial/#Assembling-the-DuctedRotor","page":"Quick Start","title":"Assembling the DuctedRotor","text":"We are now posed to construct the DuctedRotor input type.\n\n# assemble ducted_rotor object\nducted_rotor = DuctAPE.DuctedRotor(\n    duct_coordinates,\n    center_body_coordinates,\n    rotor,\n    paneling_constants,\n)\nnothing # hide","category":"section"},{"location":"DuctAPE/tutorial/#Operating-Point","page":"Quick Start","title":"Operating Point","text":"Next we will assemble the operating point which contains information about the freestream as well as the rotor rotation rate(s).\n\n# Freestream\nVinf = 30.0\nrhoinf = 1.226\nasound = 340.0\nmuinf = 1.78e-5\n\n# Rotation Rate\nRPM = 8000.0\nOmega = RPM * pi / 30 # if using RPM, be sure to convert to rad/s\n\n# utilizing the constructor function to put things in vector types\noperating_point = DuctAPE.OperatingPoint(Vinf, Omega, rhoinf, muinf, asound)\nnothing # hide","category":"section"},{"location":"DuctAPE/tutorial/#Reference-Parameters","page":"Quick Start","title":"Reference Parameters","text":"The reference parameters are used in the post-processing non-dimensionalizations.\n\n# reference velocity (close to average axial velocity at rotor in this case)\nVref = 50.0\n\n# reference radius (usually tip radius of rotor)\nRref = Rtip\n\n# assemble reference parameters\nreference_parameters = DuctAPE.ReferenceParameters([Vref], [Rref])\nnothing # hide","category":"section"},{"location":"DuctAPE/tutorial/#Set-Options","page":"Quick Start","title":"Set Options","text":"The default options should be sufficient for just starting out and are set through the set_options function.\n\noptions = DuctAPE.set_options()\n\nFor more advanced option selection, see the examples and API reference.","category":"section"},{"location":"DuctAPE/tutorial/#Run-a-Single-Analysis","page":"Quick Start","title":"Run a Single Analysis","text":"With the ducted_rotor input build, the operation point set, and the options selected, we are now ready to run an analysis. This is done simply with the analyze function which dispatches the appropriate analysis, solve, and post-processing functions based on the selected options.\n\nouts, success_flag = DuctAPE.analyze(\n    ducted_rotor, operating_point, reference_parameters, options\n)\nnothing # hide","category":"section"},{"location":"DuctAPE/tutorial/#Single-Run-Outputs","page":"Quick Start","title":"Single Run Outputs","text":"There are many outputs contained in the named tuple output from the analyze function, but some that may be of immediate interest include:\n\n# Total Thrust Coefficient\nouts.totals.CT\n\n# Total Torque Coefficient\nouts.totals.CQ","category":"section"},{"location":"DuctAPE/tutorial/#Run-a-Multi-Point-Analysis","page":"Quick Start","title":"Run a Multi-Point Analysis","text":"In the case that one wants to run the same geometry at several different operating points, for example: for a range of advance ratios, there is another dispatch of the analyze function that accepts an input, multipoint, that is a vector of operating points. Running a multi-point analysis on the example geometry given there, it might look something like this:\n\n# - Advance Ratio Range - #\nJs = range(0.0, 2.01; step=0.01)\n\n# - Calculate Vinfs - #\nD = 2.0 * rotor.Rtip[1] # rotor diameter\nn = RPM / 60.0 # rotation rate in revolutions per second\nVinfs = Js * n * D\n\n# - Set Operating Points - #\noperating_points = [deepcopy(operating_point) for i in 1:length(Vinfs)]\nfor (iv, v) in enumerate(Vinfs)\n    operating_points[iv].Vinf[] = v\nend\n\n# - Run Multi-point Analysis - #\nouts_vec, success_flags = DuctAPE.analyze(\n    ducted_rotor,\n    operating_points,\n    reference_parameters,\n    DuctAPE.set_options(operating_points),\n)\nnothing #hide\n\nThere are a few things to note here.\n\nWe want to make sure that the operating point objects we put into the input vector are unique instances.\nWe need to use the dispatch of set_options that accepts the operating point vector to set up the right number of things in the background (like convergence flags for each operating point).\nThe outputs of the analysis are vectors of the same outputs for a single analysis.","category":"section"},{"location":"DuctAPE/tutorial/#Multi-point-Outputs","page":"Quick Start","title":"Multi-point Outputs","text":"For multi-point analysis outputs, which are given as a vector of output objects, we might access and plot things as follows. We also take the opportunity to present some verification against DFDC, showing that DuctAPE matches remarkably well (within 0.5%) of DFDC. We therefore first provide data from DFDC analyses of the above example geometry at various advance ratios.\n\n# Verification Data From DFDC\n\ndfdc_jept = [\n    0.0 0.0 0.64763 0.96692\n    0.1 0.1366 0.64716 0.88394\n    0.2 0.2506 0.6448 0.80785\n    0.3 0.3457 0.64044 0.73801\n    0.4 0.4251 0.63401 0.67382\n    0.5 0.4915 0.62534 0.61468\n    0.6 0.547 0.61428 0.56001\n    0.7 0.5935 0.6006 0.50925\n    0.8 0.6326 0.58411 0.46187\n    0.9 0.6654 0.56452 0.41738\n    1.0 0.693 0.54158 0.37531\n    1.1 0.716 0.51499 0.33522\n    1.2 0.7349 0.48446 0.2967\n    1.3 0.7499 0.44966 0.25937\n    1.4 0.7606 0.41031 0.2229\n    1.5 0.7661 0.36604 0.18694\n    1.6 0.7643 0.31654 0.15121\n    1.7 0.7506 0.26153 0.11547\n    1.8 0.7126 0.20061 0.07941\n    1.9 0.61 0.13355 0.04287\n    2.0 0.1861 0.05993 0.00558\n]\n\ndfdc_J = dfdc_jept[:,1]\ndfdc_eta = dfdc_jept[:,2]\ndfdc_cp = dfdc_jept[:,3]\ndfdc_ct = dfdc_jept[:,4]\nnothing #hide\n\nWe can then access the various multi-point analysis outputs however is convenient, we choose a broadcasting approach here:\n\n# - extract efficiency, power, and thrust coefficients - #\n\n# efficiency\neta = (p->p.totals.total_efficiency[1]).(outs_vec)\n\n# power\nc_p = (p->p.totals.CP[1]).(outs_vec)\n\n# thrust\nc_t = (p->p.totals.CT[1]).(outs_vec)\nnothing #hide\n\nAnd then we can plot the data to compare DFDC and DuctAPE.\n\nusing Plots\nusing LaTeXStrings\n\n# set up efficiency plot\npe = plot(; xlabel=\"Advance Ratio\", ylabel=L\"\\eta\")\n\n# plot DFDC data\nscatter!(\n    pe,\n    dfdc_J,\n    dfdc_eta;\n    markersize=5,\n    color=1, # hide\n    label=\"DFDC\",\n)\n\n# Plot DuctAPE outputs\nplot!(\n    pe,\n    Js,\n    eta;\n    linewidth=2,\n    color=2, # hide\n    label=\"DuctAPE\",\n)\n\n# setup c_p/c_t plot\nppt = plot(; xlabel=\"Advance Ratio\")\n\n# plot DFDC data\nscatter!(\n    ppt,\n    dfdc_J,\n    dfdc_cp;\n    markersize=5,\n    color=1, # hide\n    label=L\"\\mathrm{DFDC}~~c_P\",\n)\n\nscatter!(\n    ppt,\n    dfdc_J,\n    dfdc_ct;\n    markersize=5,\n    color=2, # hide\n    label=L\"\\mathrm{DFDC}~~c_T\",\n)\n\n# plot DuctAPE outputs\nplot!(\n    ppt,\n    Js,\n    c_p;\n    linewidth=1.5,\n    color=2, # hide\n    label=L\"\\mathrm{DuctAPE}~~c_P\",\n)\n\nplot!(\n    ppt,\n    Js,\n    c_t;\n    linewidth=1.5,\n    color=1, # hide\n    label=L\"\\mathrm{DuctAPE}~~c_T\",\n)\n\nplot(\n    pe,\n    ppt;\n    size=(700, 350),\n    layout=(1, 2),\n    margin=2mm, # hide\n)","category":"section"},{"location":"DuctAPE/api/api_index/#Index","page":"API Index","title":"Index","text":"Links to all the methods presented in these docs.\n\nModules=[DuctAPE]","category":"section"}]
}
