var documenterSearchIndex = {"docs":
[{"location":"code_framework/#Full-Setup-and-Solution-Overview","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"","category":"section"},{"location":"code_framework/#Setup","page":"Full Setup and Solution Overview","title":"Setup","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Define Duct/Hub Geometry\nDefine Rotor non-dimensional Geometry\nDefine Wake Grid Geometry\nDefine Paneling\nSet first guess for rotor flow conditions using freestream\nFrom flow conditions, get first guess rotor circulations\nFrom rotor circulations, get first guess wake circulations (widetildeGamma), enthalpies (widetildeH), and average V_m at each wake grid point.\nfrom wake circulations and average V_m, get first guess wake vortex sheet strengths (gamma_theta) at each wake panel center.\nFrom wall and wake geometry, calculate influence coefficients of wall and wake panels on wall panels. (qaic, qaic.f)\nFrom gamma_theta and influence coefficients (and freestream), calculate velocities at wake control points (also qaic, qaic.f)\nFrom control point velocities and wake circulations, calculate blade source strengths. (setrotorsrc, rotoper.f line 1615)\nget initial solution for overlinegamma\nupdate control point velocities (sum influence of wall panels, wake panels, and freestream)\nupdate grid flow data (tilde values: H, S ,Gamma)","category":"page"},{"location":"code_framework/#Solution","page":"Full Setup and Solution Overview","title":"Solution","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"In loop, until converged or hit iteration limit:\nSolve for overlinegamma\nupdate control point velocities\nupdate wake grid flow data (all the tilde things in dfdc theory (H, S, Gamma)\nUpdate rotor velocities\nfind new airfoil data based on updated velocities\nfind changes in blade circulation\nget relaxation factors based on changes in blade circulation\nupdate blade circulation with relaxed values\nupdate V_m values on wakes\nupdate gamma_theta values with relaxed values","category":"page"},{"location":"code_framework/#Post-Process","page":"Full Setup and Solution Overview","title":"Post Process","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"calculate surface pressure and forces (qcpfor in vels.f line 32)\nNote that this is actually done in every iteration in dfdc, but it doesn't look like it needs to be called every time, since it doesn't update anything, just post processes.","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"","category":"page"},{"location":"code_framework/#Details","page":"Full Setup and Solution Overview","title":"Details","text":"","category":"section"},{"location":"code_framework/#Setup-2","page":"Full Setup and Solution Overview","title":"Setup","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC: start in GENGEOM, (line 608 in dfdcsubs.f)","category":"page"},{"location":"code_framework/#.-Define-Duct/Hub-Geometry","page":"Full Setup and Solution Overview","title":"1. Define Duct/Hub Geometry","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE: Duct wall and hub (walls) are defined using defineDuctGeometry (in walls.jl)","category":"page"},{"location":"code_framework/#.-Define-Rotor-non-dimensional-Geometry","page":"Full Setup and Solution Overview","title":"2. Define Rotor non-dimensional Geometry","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE: Rotors are non-dimensionally defined using initialize_rotor_geometry (in rotors.jl)","category":"page"},{"location":"code_framework/#.-Define-Wake-Grid-Geometry","page":"Full Setup and Solution Overview","title":"3. Define Wake Grid Geometry","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC: see INIGRD in inigrd.f (line 32)","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE: The rotor wake grid is defined using initialize_wake_grid (in wakegrid.jl) using more or less the same methodology used in DFDC.","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Notes:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Ideally this step should be done using an inviscid panel solution from the duct/hub geometry, which is what the DFDC theory document indicates, but instead a simple constant freestream and conservation of mass is used in practice.\nIf wanting to use an inviscid panel solution for this initialization step, need to figure out how to handle the open hub wall geometry. ","category":"page"},{"location":"code_framework/#.-Define-Paneling","page":"Full Setup and Solution Overview","title":"4. Define Paneling","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC: The rotor source panel and wake vortex panel portions of this is done in DFDC in SETROTWAK in dfdcsubs.f (line 1509) which calls ADDWAKE (line 1637 in the same file). The wall panel portion of this is started in DFDC in ADJPANL in adjpanl.f (line 32) then finised in CVPGEN in geom.f (line 117)","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE: The wall and wake panels are defined in generate_paneling (in panels.jl)","category":"page"},{"location":"code_framework/#.-Set-first-guess-for-rotor-flow-conditions-using-freestream","page":"Full Setup and Solution Overview","title":"5. Set first guess for rotor flow conditions using freestream","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Notes:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Could probably use CCBlade directly for this\nwould probably be more accurate to also use the inviscid panel solution to get distributed, rather than average velocities across blade.","category":"page"},{"location":"code_framework/#.-From-flow-conditions,-get-first-guess-rotor-circulations","page":"Full Setup and Solution Overview","title":"6. From flow conditions, get first guess rotor circulations","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Notes:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Easy to get these from CCBlade outputs (W and cl)","category":"page"},{"location":"code_framework/#.-From-rotor-circulations,-get-first-guess-wake-circulations-(\\widetilde{\\Gamma}),-enthalpies-(\\widetilde{H}),-and-average-V_m-at-each-wake-grid-point.","page":"Full Setup and Solution Overview","title":"7. From rotor circulations, get first guess wake circulations (widetildeGamma), enthalpies (widetildeH), and average V_m at each wake grid point.","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Notes:","category":"page"},{"location":"code_framework/#.-from-wake-circulations-and-average-V_m,-get-first-guess-wake-vortex-sheet-strengths-(\\gamma_\\theta)-at-each-wake-panel-center.","page":"Full Setup and Solution Overview","title":"8. from wake circulations and average V_m, get first guess wake vortex sheet strengths (gamma_theta) at each wake panel center.","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Notes:","category":"page"},{"location":"code_framework/#.-From-wall-and-wake-geometry,-calculate-influence-coefficients-of-wall-and-wake-panels-on-wall-panels.-(qaic,-qaic.f)","page":"Full Setup and Solution Overview","title":"9. From wall and wake geometry, calculate influence coefficients of wall and wake panels on wall panels. (qaic, qaic.f)","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Notes:","category":"page"},{"location":"code_framework/#.-From-\\gamma_\\theta-and-influence-coefficients-(and-freestream),-calculate-velocities-at-wake-control-points-(also-qaic,-qaic.f)","page":"Full Setup and Solution Overview","title":"10. From gamma_theta and influence coefficients (and freestream), calculate velocities at wake control points (also qaic, qaic.f)","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Notes:","category":"page"},{"location":"code_framework/#.-From-control-point-velocities-and-wake-circulations,-calculate-blade-source-strengths.-(setrotorsrc,-rotoper.f-line-1615)","page":"Full Setup and Solution Overview","title":"11. From control point velocities and wake circulations, calculate blade source strengths. (setrotorsrc, rotoper.f line 1615)","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Notes:","category":"page"},{"location":"code_framework/#.-get-initial-solution-for-\\overline{\\gamma}","page":"Full Setup and Solution Overview","title":"12. get initial solution for overlinegamma","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Notes:","category":"page"},{"location":"code_framework/#.-update-control-point-velocities-(sum-influence-of-wall-panels,-wake-panels,-and-freestream)","page":"Full Setup and Solution Overview","title":"13. update control point velocities (sum influence of wall panels, wake panels, and freestream)","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Notes:","category":"page"},{"location":"code_framework/#.-update-grid-flow-data-(tilde-values:-H,-S-,\\Gamma)","page":"Full Setup and Solution Overview","title":"14. update grid flow data (tilde values: H, S ,Gamma)","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DFDC:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"DuctTAPE:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Notes:","category":"page"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"Note that the S values aren't used until the post processing calculation of forces.","category":"page"},{"location":"code_framework/#Solution-2","page":"Full Setup and Solution Overview","title":"Solution","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"In loop, until converged or hit iteration limit:\nSolve for overlinegamma\nupdate control point velocities\nupdate wake grid flow data (all the tilde things in dfdc theory (H, S, Gamma)\nUpdate rotor velocities\nfind new airfoil data based on updated velocities\nfind changes in blade circulation\nget relaxation factors based on changes in blade circulation\nupdate blade circulation with relaxed values\nupdate V_m values on wakes\nupdate gamma_theta values with relaxed values","category":"page"},{"location":"code_framework/#Post-Process-2","page":"Full Setup and Solution Overview","title":"Post Process","text":"","category":"section"},{"location":"code_framework/","page":"Full Setup and Solution Overview","title":"Full Setup and Solution Overview","text":"calculate surface pressure and forces (qcpfor in vels.f line 32)\nNote that this is actually done in every iteration in dfdc, but it doesn't look like it needs to be called every time, since it doesn't update anything, just post processes.","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"At this point, the user is referred to the DFDC documentation for the general theory. Additional theory documentation is in development.","category":"page"},{"location":"examples/#Guided-Examples","page":"Guided Examples","title":"Guided Examples","text":"","category":"section"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Public","page":"API Reference","title":"Public","text":"","category":"section"},{"location":"reference/#Additional-Airfoil-Functions","page":"API Reference","title":"Additional Airfoil Functions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"These functions are nearly identical to CCBlade implementations, but include a solidity factor as one of the inputs.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [DuctTAPE]\nPages = [\"airfoils.jl\"]","category":"page"},{"location":"reference/#DuctTAPE.AlphaReMachsolidityAF","page":"API Reference","title":"DuctTAPE.AlphaReMachsolidityAF","text":"AlphaReMachsolidityAF(alpha, Re, Mach, solidity, cl, cd, info)\nAlphaReMachsolidityAF(alpha, Re, Mach, solidity, cl, cd)\nAlphaReMachsolidityAF(filenames::Matrix{String}; radians=true)\n\nAirfoil data that varies with angle of attack, Reynolds number, and Mach number. Data is fit with a recursive Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\nRe::Vector{Float64}: Reynolds numbers\nMach::Vector{Float64}: Mach numbers\nsolidity::Vector{Float64} : Solidity parameter\ncl::Array{Float64}: lift coefficients where cl[i, j, k] corresponds to alpha[i], Re[j], Mach[k]\ncd::Array{Float64}: drag coefficients where cd[i, j, k] corresponds to alpha[i], Re[j], Mach[k]\ninfo::String: a description of this airfoil data (just informational)\n\nor files with one per Re/Mach combination\n\nArguments\n\nfilenames::Matrix{String}: name/path of files to read in.  filenames[i, j] corresponds to Re[i] Mach[j] with Reynolds number and Mach number in ascending order.\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"reference/#DuctTAPE.AlphaResolidityAF","page":"API Reference","title":"DuctTAPE.AlphaResolidityAF","text":"AlphaResolidityAF(alpha, Re, solidity, cl, cd, info)\nAlphaResolidityAF(alpha, Re, solidity, cl, cd)\nAlphaResolidityAF(filenames::Matrix{String}; radians=true)\n\nAirfoil data that varies with angle of attack, Reynolds number, and solidity number. Data is fit with a recursive Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\nRe::Vector{Float64}: Reynolds numbers\nsolidity::Vector{Float64}: solidity numbers\ncl::Array{Float64}: lift coefficients where cl[i, j, k] corresponds to alpha[i], Re[j], solidity[k]\ncd::Array{Float64}: drag coefficients where cd[i, j, k] corresponds to alpha[i], Re[j], solidity[k]\ninfo::String: a description of this airfoil data (just informational)\n\nor files with one per Re/solidity combination\n\nArguments\n\nfilenames::Matrix{String}: name/path of files to read in.  filenames[i, j] corresponds to Re[i] solidity[j] with Reynolds number and solidity number in ascending order.\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"reference/#DuctTAPE.AlphaSolidityAF","page":"API Reference","title":"DuctTAPE.AlphaSolidityAF","text":"AlphaSolidityAF(alpha, solidity, cl, cd, info, Mach)\nAlphaSolidityAF(alpha, solidity, cl, cd, info)\nAlphaSolidityAF(alpha, solidity, cl, cd)\nread_AlphaSolidityAF(filenames::Vector{String}; radians=true)\n\nAirfoil data that varies with angle of attack and Reynolds number. Data is fit with a recursive Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\nsolidity::Vector{Float64}: solidity parameter\ncl::Matrix{Float64}: lift coefficients where cl[i, j] corresponds to alpha[i], solidity[j]\ncd::Matrix{Float64}: drag coefficients where cd[i, j] corresponds to alpha[i], solidity[j]\ninfo::String: a description of this airfoil data (just informational)\nMach::Float64: Mach number data was taken at (just informational)\n\nor\n\nfilenames with one file per Reynolds number.\n\nArguments\n\nfilenames::Vector{String}: name/path of files to read in, each at a different Reynolds number in ascending order\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"reference/#DuctTAPE.get_clcd-NTuple{5, Any}","page":"API Reference","title":"DuctTAPE.get_clcd","text":"get_clcd(af, alpha, reynolds, mach, solidity)\n\nReturn lift and drag coefficients based on airfoil object type and flow conditions.\n\nArguments:\n\naf::AFType : Airfoil object either of a CCBlade airfoil type or custom type (custom if solidity information is included).\nalpha::Float : angle of attack in degrees\nreynolds::Float : Reynolds number\nmach::Float : Mach number\nsolidity::Float : Solidity factor (local chord length over distance between radial blade stations on adjacent blades). Set to -1 if not being used.\n\nReturns:\n\ncl::Float : section lift coefficient\ncd::Float : section drag coefficient\n\n\n\n\n\n","category":"method"},{"location":"reference/#DuctTAPE.parsefile-Tuple{Any, Any, Any}","page":"API Reference","title":"DuctTAPE.parsefile","text":"overload parsefile function from CCBlade assumes solidity parameter after mach number\n\n\n\n\n\n","category":"method"},{"location":"reference/#DuctTAPE.writefile-NTuple{9, Any}","page":"API Reference","title":"DuctTAPE.writefile","text":"overload writefile function from CCBlade to include solidity parameter in file header\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"reference/#Private","page":"API Reference","title":"Private","text":"","category":"section"},{"location":"reference/#Wake-Grid-Geometry-Functions","page":"API Reference","title":"Wake Grid Geometry Functions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The wake grid initalization function actually calls two functions. The first is a method for initializing the grid geometry based on conservation of mass:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"DuctTAPE.generate_grid_points","category":"page"},{"location":"reference/#DuctTAPE.generate_grid_points","page":"API Reference","title":"DuctTAPE.generate_grid_points","text":"generate_grid_points(ductgeometry, ductsplines, rotors, grid_options, debug=false)\n\nGet grid boundary and initial interior points.\n\nArguments:\n\nductgeometry::DuctTAPE.DuctGeometry : Duct Geometry Object.\nrotors::Array{DuctTAPE.Rotor} : Array of Rotor objects\ngrid_options::DuctTAPE.GridOptions : GridOptions object\n\nReturns:\n\nx_grid_points::Matrix{Float64,2} : 2D Array of x grid points\nr_grid_points::Matrix{Float64,2} : 2D Array of r grid points\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The second is an elliptic grid solver using successive line over relaxation (SLOR) to relax the grid, meaning more accurately place the radial grid points along streamlines:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"DuctTAPE.relax_grid","category":"page"},{"location":"reference/#DuctTAPE.relax_grid","page":"API Reference","title":"DuctTAPE.relax_grid","text":"relax_grid(xg, rg, nxi, neta; max_iterations, tol)\n\nRelax grid using elliptic grid solver.\n\nArguments:\n\nxg::Matrix{Float64} : Initial x grid points guess\nrg::Matrix{Float64} : Initial r grid points guess\nnxi::Int : number of xi (x) stations in the grid\nneta::Int : number of eta (r) stations in the grid\n\nKeyword Arguments:\n\nmax_iterations::Int : maximum number of iterations to run, default=100\ntol::Float : convergence tolerance, default = 1e-9\n\nReturns:\n\nx_relax_points::Matrix{Float64} : Relaxed x grid points guess\nr_relax_points::Matrix{Float64} : Relaxed r grid points guess\n\n\n\n\n\n","category":"function"},{"location":"reference/#Rotor-Geometric-Functions","page":"API Reference","title":"Rotor Geometric Functions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"DuctTAPE.reinterpolate_rotor!","category":"page"},{"location":"reference/#DuctTAPE.reinterpolate_rotor!","page":"API Reference","title":"DuctTAPE.reinterpolate_rotor!","text":"reinterpolate_rotor!(wakegrid, rotor, rotoridx)\n\nSince the wake grid relaxes and is not aligned with aft rotor radial stations, this function reinterpolates rotor data based on updated radial stations.\n\n(The rotor inputs is the only one updated by this function.)\n\nArguments:\n\nwakegrid::DuctTAPE.WakeGridGeometry : wake grid geometry object\nrotor::DuctTAPE.RotorGeometry : the rotor geometry to update\nrotoridx::Int : index in the x direction for where the rotor lies on the wake grid\n\n\n\n\n\n","category":"function"},{"location":"reference/#Rotor-and-Wake-Grid-Aerodynamic-Functions","page":"API Reference","title":"Rotor & Wake Grid Aerodynamic Functions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"DuctTAPE.set_grid_aero!\nDuctTAPE.set_rotor_velocities\nDuctTAPE.calc_gamma_i","category":"page"},{"location":"reference/#DuctTAPE.set_grid_aero!","page":"API Reference","title":"DuctTAPE.set_grid_aero!","text":"set_grid_aero!(\n    b_gamma_grid,\n    delta_enthalpy_grid,\n    delta_entropy_grid,\n    b_circ_rotors,\n    rotor_source_strengths,\n    control_point_velocities,\n    omegas,\n    rotoridxs,\n)\n\nsets grid aero data from rotor disk jump data\n\nArguments:\n\nb_gamma_grid::Matrix{Float} : B*Γ values on wake grid\ndelta_enthalpy_grid::Matrix{Float} : ΔH (enthalpy) values on wake grid\ndelta_entropy_grid::Matrix{Float} : ΔS (entropy) values on wake grid\nb_circ_rotors::Array{Array{Float}} : B*γ values at rotor blades (one array per rotor in increasing order of x location)\nrotor_source_strengths::Array{Array{Float}} : σ (source strength) values at rotor blades (one array per rotor in increasing order of x location)\ncontrol_point_velocities::Matrix{Float} : velocities at control points\nomegas::Array{Float} : rotation rate (rad/s) of the rotors\nrotoridxs::Array{Int} : x-indicies of rotor locations\n\nOther Dispatches:\n\nset_grid_aero!(grid_aerodynamics, omegas, rotoridxs)\n\nSame, but inputs are mostly contained in grid_aerodynamics object.\n\nUnique Arguments:\n\ngrid_aerodynamics::DuctTAPE.SystemAero : circulations, source strengths, velocities, etc. of system grid.\n\nset_grid_aero!(b_gamma_grid, b_circ_rotor, delta_enthalpy_grid, omega, rotoridx)\n\nDoesn't set entropy on grid (used in initializing rotor aerodynamics). Also only does one rotor at a time (so inputs are for only a single rotor).\n\n\n\n\n\n","category":"function"},{"location":"reference/#DuctTAPE.set_rotor_velocities","page":"API Reference","title":"DuctTAPE.set_rotor_velocities","text":"set_rotor_velocities(\n    vax, vrad, vtan, vinf, omega, radialstations, wwa=0.0, wwt=0.0, vfac=1.0\n)\n\nDefine RotorVelocities object.\n\nArguments:\n\nvax::Array{Float} : axial velocities\nvrad::Array{Float} : radial velocities\nvtan::Array{Float} : tangential velocities\nvinf::Array{Float} : freestream velocity\nomega::Float : rotation rate in rad/s\n`wwa::Array{Float} : user defined additional axial velocity (unused)\n`wwt::Array{Float} : user defined additional tangential velocity (unused)\nvfac::Float : user defined velocity factor (unused)\n\nReturns:\n\nrotorvelocities::DuctTAPE.RotorVelocities : induced, absolute, and relative velocities along rotor blades.\n\n\n\n\n\n","category":"function"},{"location":"reference/#DuctTAPE.calc_gamma_i","page":"API Reference","title":"DuctTAPE.calc_gamma_i","text":"equation 45 (or 61) in dfdc theory\n\n\n\n\n\n","category":"function"},{"location":"reference/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The following functions are used as various utility functions throughout the code.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [DuctTAPE]\nPages   = [\"utils.jl\"]","category":"page"},{"location":"reference/#DuctTAPE.calc_normal-Tuple{Any, Any}","page":"API Reference","title":"DuctTAPE.calc_normal","text":"calc_normal(xs, rs)\n\nCalculate unit normal vector of panel with edges defined by xs and rs.\n\nReturns (0.0, 0.0) if panel has zero length.\n\nArguments:\n\nxs::Tuple{Float, Float} : x-coordinates of panel edges\nrs::Tuple{Float, Float} : r-coordinates of panel edges\n\nKeyword Arguments:\n\nreturn_tangent::Bool : if true, return tangent vector (as tuple) as a second output.\n\nReturns:\n\npanel_normal::Tuple{Float} : unit normal vector (x, r) of panel.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DuctTAPE.cosinespace-Tuple{Any}","page":"API Reference","title":"DuctTAPE.cosinespace","text":"cosinespace(n)\n\nCalculates cosine spaced points from 0 to pi/2 (viz. cosin(theta), theta ∈ [0, pi/2])\n\nArguments:\n\nn::Int : Number of points to calculate\n\nReturns:\n\npts::Array{Float} : Array of cosine spaced points\n\n\n\n\n\n","category":"method"},{"location":"reference/#DuctTAPE.get_omega-Tuple{Any}","page":"API Reference","title":"DuctTAPE.get_omega","text":"get_omega(rpm)\n\nCalculates rad/s from RPM\n\nArguments:\n\nrpm::Float : RPM\n\nReturns:\n\nomega::Float : radians per second\n\n\n\n\n\n","category":"method"},{"location":"reference/#DuctTAPE.ismonotonic-Tuple{Any}","page":"API Reference","title":"DuctTAPE.ismonotonic","text":"ismonotonic(A)\n\nChecks if array, A is monotonic\n\nArguments:\n\nA::Array : Array in question\n\nReturns:\n\ntrue::Bool : true or false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DuctTAPE.lintran-NTuple{5, Any}","page":"API Reference","title":"DuctTAPE.lintran","text":"lintran(rb1, rbend, ra1, raend, ra)\n\nLinear transfrom of ra from range (ra1, raend) to (rb1, rbend)\n\nArguments:\n\nrb1::Float : lower bound of range b\nrbend::Float : upper bound of range b\nra1::Float : lower bound of range a\nraend::Float : upper bound of range a\nra::Array{Float} : array of values on range a\n\nReturns:\n\nrb::Array{Float} : array of transformed values on range b\n\n\n\n\n\n","category":"method"},{"location":"reference/#DuctTAPE.sinespace-Tuple{Any}","page":"API Reference","title":"DuctTAPE.sinespace","text":"sinespace(n)\n\nCalculates sine spaced points from 0 to pi/2 (viz. sin(theta), theta ∈ [0, pi/2])\n\nArguments:\n\nn::Int : Number of points to calculate\n\nReturns:\n\npts::Array{Float} : Array of sine spaced points\n\n\n\n\n\n","category":"method"},{"location":"","page":"Intro","title":"Intro","text":"CurrentModule = DuctTAPE","category":"page"},{"location":"#DuctTAPE-([Duct](#)ed-[T](#)wo-dimensional-[A](#)ero[P](#)ropulsor-[E](#)valuation)","page":"Intro","title":"DuctTAPE (Ducted Two-dimensional AeroPropulsor Evaluation)","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Documentation for DuctTAPE.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"DuctTAPE is a code for the aerodynamic evaluation of 2D, axisymmetric, ducted propulsors design for incompressible aerodynamic applications (although hydrodynamic applications could also apply, but aero made the acronym work).","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"It is heavily based on the code DFDC, but has been developed specifically for use in gradient based optimization.","category":"page"},{"location":"tutorial/#Quick-Start-Guide","page":"Quick Start","title":"Quick Start Guide","text":"","category":"section"},{"location":"tutorial/#Setting-up-Duct-Geometry","page":"Quick Start","title":"Setting up Duct Geometry","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"For this example, we are going to set up an example available in the DFDC source files. We have taken one of the case files and transcribed it into a julia file located in the data directory.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"using DuctTAPE\nusing Plots\nusing Measures\n\ndefault()\ndefault(;\n    fontfamily=\"Palatino Roman\",\n    size=(800, 600), #it appears that 100 ≈ 1inch in LaTeX\n    fillalpha=0.125,\n    fillcolor=RGB(128 / 255, 128 / 255, 128 / 255),\n    linewidth=1.0,\n    annotationfontfamily=\"Palatino Roman\",\n    markerstrokewidth=0.1,\n    annotationfontsize=10,\n    background_color_inside=nothing,\n    background_color_legend=nothing,\n    background_color_subplot=nothing,\n    color_palette=[\n        RGB(0.0, 46.0 / 255.0, 93.0 / 255.0), #BYU Blue\n        RGB(155.0 / 255.0, 0.0, 0.0), #\"BYU\" Red\n        RGB(128.0 / 255.0, 128.0 / 255.0, 128.0 / 255.0), #Middle Gray\n        RGB(162.0 / 255.0, 227.0 / 255.0, 162.0 / 255.0), #Light Green\n        RGB(243.0 / 255.0, 209.0 / 255.0, 243.0 / 255.0), #Pink\n        RGB(205.0 / 255.0, 179.0 / 255.0, 0.0), #Yellow\n        RGB(161.0 / 255.0, 161.0 / 255.0, 226.0 / 255.0), #Purple\n    ],\n    foreground_color_legend=nothing,\n    legend=false, # include legend true/false\n    grid=false, # background grid true/false\n    gridlinewidth=0.5,\n    margin = 10mm,\n)\n\nplot(xlabel=\"x\", ylabel=\"r\", aspectratio=:equal)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We'll go ahead and load that file and grab pieces of it as we go.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# --- WALL GEOMETRY DEFINITION\ninclude(\"../../data/dfdc/dstestr2_case.jl\");\n","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The geometry is defined for a complete airfoil as the duct wall. We actually want to split the duct wall coordinates for easier navigation as we set up the flow field.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.split_wall","category":"page"},{"location":"tutorial/#DuctTAPE.split_wall","page":"Quick Start","title":"DuctTAPE.split_wall","text":"split_wall(x,r)\n\nSplits full airfoil coordinates into upper and lower halves.\n\nOnly works based on geometry.  Splits at lowest x-value, does not split based on stagnation point.\n\nArguments:\n\nx::Array{Float} : Array of x-coordinates, assumed to start at the bottom trailing edge and proceed clockwise\nr::Array{Float} : Array of r-coordinates, assumed to start at the bottom trailing edge and proceed clockwise\n\nReturns:\n\nxlower::Array{Float} : Array of lower x-coordinates\nxupper::Array{Float} : Array of upper x-coordinates\nrlower::Array{Float} : Array of lower r-coordinates\nrupper::Array{Float} : Array of upper r-coordinates\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# - Split Wall Coordinates\nouterwallx, innerwallx, outerwallr, innerwallr = DuctTAPE.split_wall(ductx, ductr)\n\n# - Plot Geometry\nplot!(innerwallx, innerwallr, linewidth=2)\nplot!(outerwallx, outerwallr, linestyle=:dash, color=1, linewidth=2)\nplot!(hubx, hubr, color=2, linewidth=2)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Now we want to put all the geometry together in a DuctGeometry object.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.DuctGeometry\nDuctTAPE.defineDuctGeometry","category":"page"},{"location":"tutorial/#DuctTAPE.DuctGeometry","page":"Quick Start","title":"DuctTAPE.DuctGeometry","text":"DuctGeometry{TA,TF}\n\nFields:\n\nwallinnerxcoordinates::Array{Float} : x coordinates of inner (lower) wall geometry\nwallouterxcoordinates::Array{Float} : x coordinates of outer (upper) wall geometry\nwallinnerrcoordinates::Array{Float} : r coordinates of inner (lower) wall geometry\nwallouterrcoordinates::Array{Float} : r coordinates of outer (upper) wall geometry\nhubxcoordinates::Array{Float} : x coordinates of hub geometry\nhubrcoordinates::Array{Float} : r coordinates of hub geometry\nLEx::Float : x-position of leading edge\nTEx::Float : x-position of trailing edge\nchord::Float : chord length\nwallbluntTE::Bool : flag for blunt trailing edge on wall\nhubbluntTE::Bool : flag for blunt trailing edge on hub\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DuctTAPE.defineDuctGeometry","page":"Quick Start","title":"DuctTAPE.defineDuctGeometry","text":"defineDuctGeometry(\n    wallinnerxcoordinates,\n    wallinnerrcoordinates,\n    wallouterxcoordinates,\n    wallouterrcoordinates,\n    hubxcoordinates=nothing,\n    hubrcoordinates=nothing;\n    LEx=nothing,\n    TEx=nothing,\n    chord=nothing,\n    bluntTEtol=1e-9,\n)\n\nConstructor function for the DuctGeometry Object.\n\nRequired Arguments:\n\nwallinnerxcoordinates::Array{Float} : x coordinates of inner (lower) wall geometry\nwallouterxcoordinates::Array{Float} : x coordinates of outer (upper) wall geometry\nwallinnerrcoordinates::Array{Float} : r coordinates of inner (lower) wall geometry\nwallouterrcoordinates::Array{Float} : r coordinates of outer (upper) wall geometry\n\nOptional Arguments:\n\nhubxcoordinates::Array{Float} : x coordinates of hub geometry\nhubrcoordinates::Array{Float} : r coordinates of hub geometry\n\nNote, if hub x and r coordinates are not set, the x coordinates for the inner wall will be used and the r coordinates will be set to zero.  Also note that if one of these is unset, the other must also be unset.\n\nKeyword Arguments:\n\nLEx::Float : x-position of manually defined leading edge.  Set to foremost x-coordinate of duct and hub geometry otherwise.\nTEx::Float : x-position of mannually defined trailing edge.  Set to the rear-most x-coordinate of duct and hub geometry otherwise.\nchord::Float : manually defined chord length.  Set to difference between leading and trailing edges otherwise.\nbluntTEtol::Float : tolerance for how close trailing edge points need to be before being considered a blunt trailing edge.\n\nNotes\n\nThe wall inner and outer and hub coordinates are all saved from leading to trailing edge (this helps with splining things later). It is assumed that the wall is similar to an airfoil that may or may not have a blunt trailing edge.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Using the defineDuctGeometry contructor function, we can input our wall and hub geometries and let the leading and trailing edges and chord length be calculated automatically. Note that this function also outputs a spline object for the inner duct wall and the hub wall. These splines are used throughout the initialization process to help with rotor placement.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# --- DEFINE DUCT OBJECT\nductgeometry, ductsplines = DuctTAPE.defineDuctGeometry(\n    innerwallx,\n    innerwallr,\n    outerwallx,\n    outerwallr,\n    hubx,\n    hubr\n)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The ductgeometry and ductsplines objects now contains all the geometry information we'll need.","category":"page"},{"location":"tutorial/#Defining-Rotors","page":"Quick Start","title":"Defining Rotors","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Along with the duct geometry, we will need to define an array of Rotor objects.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.RotorGeometry","category":"page"},{"location":"tutorial/#DuctTAPE.RotorGeometry","page":"Quick Start","title":"DuctTAPE.RotorGeometry","text":"RotorGeometry{TF, TI, TA, TC, TT, TAF, TR, TM}\n\nFields:\n\nxlocation::Float : x location of rotor plane, non-dimensional based on duct chord (max TE location - min LE location of hub/wall)\nnumblades::Int : number of rotor blades\nradialstations::Array{Float} : array of radial stations defining rotor blade, non-dimensional with hub=0, tip=1\ntipgap::Float : gap between blade tip and duct wall (not implemented yet)\nchords::Array{Float} : array of chord lengths at radial stations defining rotor blade, non-dimensional based on blade tip radius\ntwists::Array{Float} : array of twist values (in degrees) at radial stations defining rotor blade\nskews::Array{Float} : array of skew values (similar to sweep) at radial stations defining rotor blade, non-dimensional based on rotor tip radius. (note: this is for reference only, the solver can't use this information)\nrakes::Array{Float} : array of rake values (similar to dihedral) at radial stations defining rotor blade, non-dimensional based on rotor tip radius. (note: this is for reference only right now. it may be implemented into the grid initialization functions later.)\nairfoils::Array{Airfoil} : array of airfoil data objects at radial stations defining rotor blade\nsolidity:Array{Float} : array of rotor solidity at radial stations defining rotor blade, chord/distance between blade sections\nrpm::Float : RPM of rotor\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Note that we want to create an array, even if we only have one rotor.  When we initialize the grid, it will expect an array. Also, our rotor object has more fields than are used in the original dfdc, for now, we'll set the section skew, rake, and solidity to nothing. For the airfoils, we will use the CCBlade.jl functionality and for our case here, define our airfoils as ccb.AlphaReAF objects (where CCBlade has been included in the DuctTAPE package and renamed 'ccb') using data files from digitized dfdc plots.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We can define rotor objects directly, or we can use the initialize_rotor_geometry function to help us.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.initialize_rotor_geometry","category":"page"},{"location":"tutorial/#DuctTAPE.initialize_rotor_geometry","page":"Quick Start","title":"DuctTAPE.initialize_rotor_geometry","text":"function initialize_rotor_geometry(\n    xlocation,\n    numblades,\n    numstations,\n    chords,\n    twists,\n    airfoils,\n    rpm;\n    radialstations=nothing,\n    tipgap=0.0, #non-dimensional relative to blade length\n    skews=nothing,\n    rakes=nothing,\n    solidities=nothing,\n)\n\nInitialize non-dimensional rotor geometry and other relative information.\n\nArguments:\n\nxlocation::Float : x location of rotor relative to duct chord\nnumblades::Float : number of rotor blades\nnumstations::Float : number of radial stations (the length of the below sectional properties)\nchords::Array{Float} : array of section chord lengths (relative to blade tip radius)\ntwists::Array{Float} : array of section twists (0 degrees is aligned with the axial direction) in degrees\nairfoils::Array{AFType} : airfoil objects at each section\nrpm::Float : RPM of rotor\n\nKeyword Arguments:\n\nradialstations::Array{Float} : non-dimensional radial stations (0 = hub radius, 1 = tip radius)\ntipgap::Float : non-dimensional relative to blade length (Not implemented yet)\nskews::Array{Float} : sectional skew distance relative to tip radius (not implemented yet)\nrakes::Array{Float} : sectional rake distances relative to tip radius (not implemented yet)\nsolidities::Array{Float} or Nothing : sectional rotor solidities, if using.\n\nReturns:\n\nrotorgeometry::DuctTAPE.RotorGeometry : Rotor geometry object\n\nTODOs: if rotor rake is present, need to redo parts of grid initialization (and check that the unused portions of the code work now) to account for different x-locations of start of wake.  NOTE: not sure if rake will work with this solver. Need to think about that more before implementing.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# -- GENERATE ROTOR OBJECT ARRAY\n\n# set datapath for airfoil data files. Remember to grab these files and change the data path for your case.\ndatapath = \"../../data/dfdc/airfoils/\"\n\n# generate airfoils for rotor\naf1 = DuctTAPE.ccb.AlphaReAF([\n    datapath * \"disk1_re5e5.dat\",\n    datapath * \"disk1_re1e6.dat\",\n    datapath * \"disk1_re1.5e6.dat\",\n    datapath * \"disk1_re2e6.dat\",\n])\n\n# generate airfoils for stator\naf2 = DuctTAPE.ccb.AlphaReAF([\n    datapath * \"disk2_re5e5.dat\",\n    datapath * \"disk2_re1e6.dat\",\n    datapath * \"disk2_re1.5e6.dat\",\n    datapath * \"disk2_re2e6.dat\",\n])\n\n#generate rotor object using initialization function\nrotor1 = DuctTAPE.initialize_rotor_geometry(\n    xdisk1, #x position of rotor\n    nblade1, # number of blades\n    length(rnondim1), #number of radial stations\n    chord1, #chords\n    beta1, #twists\n    fill(af1, length(rnondim1)), #airfoils\n    rpm; #RPM\n    radialstations=rnondim1 #radial station locations\n)\n\n#generate stator object (rpm is zero for stator) using direct definition\nrotor2 = DuctTAPE.RotorGeometry(\n    xdisk2, #x position of rotor\n    nblade2, #number of blades\n    rnondim2, #radial stations\n    0.0, #tip gap\n    chord2, #chords\n    beta2, #twists\n    zeros(length(rnondim2)), #skews\n    zeros(length(rnondim2)), #rakes\n    fill(af2, length(rnondim2)), #airfoils\n    -1 .* ones(Int, length(rnondim2)), #solidities\n    0.0, #RPM\n)\n\n#assemble array\nrotors = [rotor1; rotor2]","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Take note that the rotor objects are defined using non-dimensional parameters. If we want to visualize things at this point, we'll have to dimensionalize things, which is done internally in the code using BladeDimensions objects.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.BladeDimensions\nDuctTAPE.initialize_blade_dimensions","category":"page"},{"location":"tutorial/#DuctTAPE.BladeDimensions","page":"Quick Start","title":"DuctTAPE.BladeDimensions","text":"BladeDimensions{TF, TA}\n\nFields:\n\nrhub::Float : hub radius (dimensional)\nrtip::Float : tip radius (dimensional)\nrdim::Array{Float} : array of dimensional radial stations\ncdim::Array{Float} : array of dimensional chords\ntdim::Array{Float} : array of twists (already dimensional in rotorgeometry)\nsweptannulus::Float : area of blade swept annulus\nsweptarea::Float : area of blade tip swept disk\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DuctTAPE.initialize_blade_dimensions","page":"Quick Start","title":"DuctTAPE.initialize_blade_dimensions","text":"initialize_blade_dimensions(ductsplines, Rotor)\n\nInitilialize needed blade information for various calculations during the solution process.\n\nArguments:\n\nductsplines::DuctTAPE.ductsplines : ductsplines object containing splines for duct wall and hub\nRotor::DuctTAPE.Rotor : Rotor object for which to define blade information\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"blade1 = DuctTAPE.initialize_blade_dimensions(ductgeometry, ductsplines, rotor1)\nblade2 = DuctTAPE.initialize_blade_dimensions(ductgeometry, ductsplines, rotor2)\n\nblades = [blade1; blade2]\n\nnr = length(blade1.rdim)\nplot!(rotor1.xlocation.*ductgeometry.chord*ones(nr), blade1.rdim, color=4, linewidth=2)\nplot!(rotor2.xlocation.*ductgeometry.chord*ones(nr), blade2.rdim, color=4, linewidth=2)\n","category":"page"},{"location":"tutorial/#Wake-Grid-Initialization","page":"Quick Start","title":"Wake Grid Initialization","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"With the duct geometry and rotor data defined, we can now initialize the rotor wake grid. We'll begin by setting some grid options.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"note: Note\nThe number of radial stations set for grid options must match the number of radial stations defined for the rotor objects. Furthermore, the rotors must have the same number of radial stations defined.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.GridOptions\nDuctTAPE.defineGridOptions","category":"page"},{"location":"tutorial/#DuctTAPE.GridOptions","page":"Quick Start","title":"DuctTAPE.GridOptions","text":"GridOptions{TF,TI}\n\nFields:\n\nnum_radial_stations::Integer : Number of radial stations (equal to number of rotor blade elements used in analysis)\ninlet_length::Float : inlet length (unused)\nwake_length::Float : length of wake behind duct relative to chord length\nwake_expansion_factor::Float : expansion factor to apply to wake grid generation\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DuctTAPE.defineGridOptions","page":"Quick Start","title":"DuctTAPE.defineGridOptions","text":"defineGridOptions(\n    num_radial_stations;\n    inlet_length=0.5,\n    wake_length=1.0,\n    wake_expansion_factor=1.1\n)\n\nConstructor function for the GridOptions object.\n\nRequired Argument:\n\nnum_radial_stations::Integer : Number of radial stations (equal to number of rotor blade elements used in analysis)\n\nKeyword Arguments:\n\ninlet_length::Float : inlet length (unused)\nwake_length::Float : length of wake behind duct in terms of chord length\nwake_expansion_factor::Float : expansion factor to apply to wake grid generation\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# --- SET GRID OPTIONS\nnum_radial_stations = length(rnondim1)\ngrid_options = DuctTAPE.defineGridOptions(num_radial_stations)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"With options set, rotor location chosen, and the wall and hub geometry available, we're finally ready to initialize the wake grid object.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.initialize_wakegrid\nDuctTAPE.WakeGridGeometry","category":"page"},{"location":"tutorial/#DuctTAPE.initialize_wakegrid","page":"Quick Start","title":"DuctTAPE.initialize_wakegrid","text":"initialize_wakegrid(ductgeometry, ductsplines, rotors, grid_options; max_iterations=-1, tol=1e-9)\n\nInitialize grid via zero-thrust, unit freestream solution.\n\nArguments:\n\nductgeometry::DuctTAPE.DuctGeometry : ductgeometry Geometry Object\nductsplines::DuctTAPE.DuctSplines : ductsplines object\nrotors::Array{DuctTAPE.Rotor} : Array of rotor objects\ngrid_options::DuctTAPE.GridOptions : Grid options object\n\nKeyword Arguments:\n\nmax_iterations::Int : maximum number of iterations to run, default=100\ntol::Float : convergence tolerance, default = 1e-9\n\nReturns:\n\nwakegridgeometry::DuctTAPE.WakeGridGeometry : WakeGridGeometry Object\n\nNOTES:\n\nThe grid is designed such that the grid spacing in the axial direction will line up with the rotor positions as well as the trailing edge positions of the duct wall and hub (as well as the leading edge positions if they happen to be behind a rotor, which is not advised).\nIn addition, the grid axial spacing is taken to be as close as possible to the radial spacing, which is defined directly from the rotor radial station positions.\nThe wake spacing is started at the average of the axial spacing inside the duct area and then expanded by an expansion factor that can be defined by the user and is set to 1.1 by default.  This means that the end of the wake will actually not lie directly at the length input by the user (default 2x duct chord), but should be close enough.\nIf more than one rotor is being analyzed, the rotor radial stations have more than likely changed for aft rotors.  Therefore, rotor information for all but the foremost rotor are reinterpolated so that rotor stations line up with wake grid stations.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#DuctTAPE.WakeGridGeometry","page":"Quick Start","title":"DuctTAPE.WakeGridGeometry","text":"WakeGridGeometry{TF,TI,TA,TW,TH}\n\nWake grid geometry object\n\nFields:\n\nx_grid_points::Matrix{Float} : 2D Array of x grid points\nr_grid_points::Matrix{Float} : 2D Array of radial grid points\nnx::Int : number of x stations\nnr::Int : number of radial stations\nwallTEidx::Int : index of duct wall trailing edge x location\nhubTEidx::Int : index of hub wall trailing edge x location\nrotoridxs::Array{Int} : array of indices of rotor x locations\nwall_xstations::Array{Int} : array of indicies on which duct wall is present in grid\nhub_xstations::Array{Int} : array of indicies on which hub is present in grid\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# --- INITIALIZE GRID\nwakegrid = DuctTAPE.initialize_wakegrid(ductgeometry, ductsplines, rotors, grid_options)\n\nxg = wakegrid.x_grid_points\nrg = wakegrid.r_grid_points\nnx = wakegrid.nx\nnr = wakegrid.nr\n\nplot(; xlabel=\"x\", ylabel=\"r\", aspectratio=:equal)\nplot!(\n    ductgeometry.wallinnerxcoordinates,\n    ductgeometry.wallinnerrcoordinates;\n    color=1,\n    linewidth=2,\n)\nplot!(\n    ductgeometry.wallouterxcoordinates,\n    ductgeometry.wallouterrcoordinates;\n    color=1,\n    linestyle=:dash,\n    linewidth=2,\n)\nplot!(ductgeometry.hubxcoordinates, ductgeometry.hubrcoordinates; color=2, linewidth=2)\n\nplot!(rotor1.xlocation .* ductgeometry.chord * ones(nr), blade1.rdim; color=4, linewidth=2)\nplot!(rotor2.xlocation .* ductgeometry.chord * ones(nr), blade2.rdim; color=4, linewidth=2)\n\nplot!(xg, rg; color=3, linewidth=0.5)\nplot!(xg', rg'; color=3, linewidth=0.5)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"note: Note\nThis process should be relatively robust in that most combinations of wall and hub and rotor position should generate a grid. However, in the case that there is no overlap in the x-positions of the wall and hub, problems may occur later in the solver. In addition if the rotor is positioned somewhere not between the wall and hub, for example, if the rotor is out in front of the duct, then if a solution is found, it will likely be inaccurate. And finally, things will break if the hub and wall overlap in the radial direction, in other words, if the duct is blocked.","category":"page"},{"location":"tutorial/#System-Paneling","page":"Quick Start","title":"System Paneling","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"With the geometry defined and the grid initialized, we can define the system panels and their control points (centers). To do so, we use the generate_paneling function:","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.generate_paneling","category":"page"},{"location":"tutorial/#DuctTAPE.generate_paneling","page":"Quick Start","title":"DuctTAPE.generate_paneling","text":"generate_paneling(ductgeometry, ductsplines, rotors, wakegrid)\n\nGenerate panel edges, centers, and unit normals.\n\nArguments:\n\nductgeometry::DuctTAPE.DuctGeometry : Duct Geometry object\nductsplines::DuctTAPE.DuctSplines : Duct Splines object\nrotors::Array{DuctTAPE.Rotor} : Array of rotor objects\nwakegrid::DuctTAPE.WakeGridGeometry : Wake Grid object\n\nReturns:\n\nwall_panels::DuctTAPE.Panels : Panels object for duct wall\nhub_panels::DuctTAPE.Panels : Panels object for hub\nwake_panels::DuctTAPE.Panels : Panels object for vortex wake sheets\nrotor_source_panels::Array{DuctTAPE.Panels} : Array of Panels objects for each rotor\n\nNOTES:\n\nThe paneling for the rotor sources and the vortex wake sheets is based directly on the wake grid.\nThe paneling of the duct wall and hub are set such that the panels aft of the foremost rotor also align perfectly with the wake grid.\nThe wall panels in front of the foremost rotor are set using cosine spacing such that the last panel before the foremost rotor is roughly similar in length to the average of the panel lengths in the remainder of the duct.\n\n(Note that the estimation process for this is not particularly robust at this point.)\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"For our case here, we are going to use a rough sampling of the geometry data in order to more clearly see the paneling. The generated panels will be contained in Panels objects.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.Panels","category":"page"},{"location":"tutorial/#DuctTAPE.Panels","page":"Quick Start","title":"DuctTAPE.Panels","text":"Panels{TPEx,TPEr,TPC,TPN,TPT}\n\nFields:\n\npanel_edges_x::Array{Tuple{Float, Float}} : Array of sets of x locations for panel edges\npanel_edges_r::Array{Tuple{Float, Float}} : Array of sets of r locations for panel edges\npanel_centers::Array{Tuple{Float, Float}} : Array of sets of x,r locations for panel centers\npanel_normals::Array{Tuple{Float, Float}} : Array of panel unit normal vectors\npanel_tyes::Array{String} : Array of panel types (for use in assembling linear system)\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"using DuctTAPE\nusing Plots\nusing Measures\n\ndefault()\ndefault(;\n    fontfamily=\"Palatino Roman\",\n    size=(800, 600), #it appears that 100 ≈ 1inch in LaTeX\n    fillalpha=0.125,\n    fillcolor=RGB(128 / 255, 128 / 255, 128 / 255),\n    linewidth=1.0,\n    annotationfontfamily=\"Palatino Roman\",\n    markerstrokewidth=0.1,\n    annotationfontsize=10,\n    background_color_inside=nothing,\n    background_color_legend=nothing,\n    background_color_subplot=nothing,\n    color_palette=[\n        RGB(0.0, 46.0 / 255.0, 93.0 / 255.0), #BYU Blue\n        RGB(155.0 / 255.0, 0.0, 0.0), #\"BYU\" Red\n        RGB(128.0 / 255.0, 128.0 / 255.0, 128.0 / 255.0), #Middle Gray\n        RGB(162.0 / 255.0, 227.0 / 255.0, 162.0 / 255.0), #Light Green\n        RGB(243.0 / 255.0, 209.0 / 255.0, 243.0 / 255.0), #Pink\n        RGB(205.0 / 255.0, 179.0 / 255.0, 0.0), #Yellow\n        RGB(161.0 / 255.0, 161.0 / 255.0, 226.0 / 255.0), #Purple\n    ],\n    foreground_color_legend=nothing,\n    legend=false, # include legend true/false\n    grid=false, # background grid true/false\n    gridlinewidth=0.5,\n    margin = 10mm,\n)\n\nplot(xlabel=\"x\", ylabel=\"r\", aspectratio=:equal)\n\ninclude(\"../../data/dfdc/dstestr2_case.jl\");\n\n# - Split Wall Coordinates\nouterwallx, innerwallx, outerwallr, innerwallr = DuctTAPE.split_wall(ductx, ductr)\n\n# --- DEFINE DUCT OBJECT\nductgeometry, ductsplines = DuctTAPE.defineDuctGeometry(\n    innerwallx[1:4:end],\n    innerwallr[1:4:end],\n    outerwallx[1:4:end],\n    outerwallr[1:4:end],\n    hubx[1:4:end],\n    hubr[1:4:end]\n)\n# -- GENERATE ROTOR OBJECT ARRAY\n\n#generate rotor object\nrotor1 = DuctTAPE.RotorGeometry(\n    xdisk1,\n    nblade1,\n    rnondim1[1:2:end],\n    0.0,\n    chord1[1:2:end],\n    beta1[1:2:end],\n    nothing,\n    nothing,\n    nothing,\n    nothing,\n    rpm,\n)\n\n#generate stator object (rpm is zero for stator)\nrotor2 = DuctTAPE.RotorGeometry(\n    xdisk2,\n    nblade2,\n    rnondim2[1:2:end],\n    0.0,\n    chord2[1:2:end],\n    beta2[1:2:end],\n    nothing,\n    nothing,\n    nothing,\n    nothing,\n    0.0,\n)\n\n#assemble array\nrotors = [rotor1; rotor2]\n\n# --- SET GRID OPTIONS\nnum_radial_stations = length(rnondim1[1:2:end])\ngrid_options = DuctTAPE.defineGridOptions(num_radial_stations)\n\n\n# --- INITIALIZE GRID\nwakegrid = DuctTAPE.initialize_wakegrid(ductgeometry, ductsplines, rotors, grid_options)\n\nxg = wakegrid.x_grid_points\nrg = wakegrid.r_grid_points\nnx = wakegrid.nx\nnr = wakegrid.nr\n","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# Get paneling of various objects\n\nwall_panels, hub_panels, wake_panels, rotor_source_panels = DuctTAPE.generate_paneling(\n    ductgeometry, ductsplines, rotors, wakegrid\n)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# PLOT PANELS\n\nplot(; xlabel=\"x\", ylabel=\"r\", aspectratio=:equal, legend=true, label=\"\")\n\n# wall panels:\nfor i in 1:length(wall_panels.panel_edges_x)\n    plot!(\n        [wall_panels.panel_edges_x[i][1]; wall_panels.panel_edges_x[i][2]],\n        [wall_panels.panel_edges_r[i][1]; wall_panels.panel_edges_r[i][2]];\n        color=1,\n        linewidth=0.5,\n        markershape=:diamond,\n        markersize=2,\n        label=\"\",\n    )\nend\n\nscatter!(\n    getindex.(wall_panels.panel_centers, 1),\n    getindex.(wall_panels.panel_centers, 2);\n    color=1,\n    markersize=3,\n    markershape=:circle,\n    label=\"wall panel centers\",\n)\n\n#hub panels:\nfor i in 1:length(hub_panels.panel_edges_x)\n    plot!(\n        [hub_panels.panel_edges_x[i][1]; hub_panels.panel_edges_x[i][2]],\n        [hub_panels.panel_edges_r[i][1]; hub_panels.panel_edges_r[i][2]];\n        markersize=2,\n        markershape=:diamond,\n        color=2,\n        linewidth=0.5,\n        label=\"\",\n    )\nend\n\nscatter!(\n    getindex.(hub_panels.panel_centers, 1),\n    getindex.(hub_panels.panel_centers, 2);\n    markersize=3,\n    markershape=:circle,\n    color=2,\n    label=\"hub panel centers\",\n)\n\n#vortex sheet panels\nfor i in 1:length(wake_panels.panel_centers)\n    plot!(\n        [wake_panels.panel_edges_x[i][1]; wake_panels.panel_edges_x[i][2]],\n        [wake_panels.panel_edges_r[i][1]; wake_panels.panel_edges_r[i][2]];\n        markersize=2,\n        markershape=:diamond,\n        color=3,\n        linewidth=0.5,\n        label=\"\",\n    )\nend\n\nscatter!(\n    getindex.(wake_panels.panel_centers, 1),\n    getindex.(wake_panels.panel_centers, 2);\n    markersize=3,\n    markershape=:circle,\n    color=3,\n    label=\"vortex sheet panel centers\",\n)\n\n#rotor source panels:\nfor i in 1:length(rotor_source_panels[1].panel_centers)\n    plot!(\n        [\n            rotor_source_panels[1].panel_edges_x[i][1]\n            rotor_source_panels[1].panel_edges_x[i][2]\n        ],\n        [\n            rotor_source_panels[1].panel_edges_r[i][1]\n            rotor_source_panels[1].panel_edges_r[i][2]\n        ];\n        markersize=2,\n        markershape=:diamond,\n        color=4,\n        linewidth=0.5,\n        label=\"\",\n    )\nend\n\nscatter!(\n    getindex.(rotor_source_panels[1].panel_centers, 1),\n    getindex.(rotor_source_panels[1].panel_centers, 2);\n    markersize=3,\n    markershape=:circle,\n    color=4,\n    label=\"rotor source panel centers\",\n)\n\n# stator source panels\nfor i in 1:length(rotor_source_panels[2].panel_centers)\n    plot!(\n        [\n            rotor_source_panels[2].panel_edges_x[i][1]\n            rotor_source_panels[2].panel_edges_x[i][2]\n        ],\n        [\n            rotor_source_panels[2].panel_edges_r[i][1]\n            rotor_source_panels[2].panel_edges_r[i][2]\n        ];\n        markersize=2,\n        markershape=:diamond,\n        color=4,\n        linewidth=0.5,\n        label=\"\",\n    )\nend\n\nscatter!(\n    getindex.(rotor_source_panels[2].panel_centers, 1),\n    getindex.(rotor_source_panels[2].panel_centers, 2);\n    markersize=3,\n    markershape=:circle,\n    color=4,\n    label=\"\",\n)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We could also get all the various panels into a single object using the PanelSystem object and associated generate_panel_system function.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.PanelSystem\nDuctTAPE.generate_panel_system","category":"page"},{"location":"tutorial/#DuctTAPE.PanelSystem","page":"Quick Start","title":"DuctTAPE.PanelSystem","text":"PanelSystem{TD,TH,TW,TR}\n\nFields:\n\nwall_panels::DuctTAPE.Panels : panels defining duct wall airfoil\nhub_panels::DuctTAPE.Panels : panels defining hub\nwake_panels::DuctTAPE.Panels : panels defining rotor wake vortex sheets\nrotor_source_panels::DuctTAPE.Panels : panels defining rotor drag source panels\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DuctTAPE.generate_panel_system","page":"Quick Start","title":"DuctTAPE.generate_panel_system","text":"generate_panel_system(ductgeometry, ductsplines, rotors, wakegrid)\n\nPut all the various panel objects together for convenience.\n\nArguments:\n\nductgeometry::DuctTAPE.DuctGeometry : Duct Geometry object\nductsplines::DuctTAPE.DuctSplines : Duct Splines object\nrotors::Array{DuctTAPE.Rotor} : Array of rotor objects\nwakegrid::DuctTAPE.WakeGridGeometry : Wake Grid object\n\nReturns:\n\npanelsystem::DuctTAPE.PanelSystem : All System Panels\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#Initializing-Rotor-Aerodynamics","page":"Quick Start","title":"Initializing Rotor Aerodynamics","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Now that we have all the geometry set up, we're ready to start initializing the aerodynamics of our system. We first will define the freestream conditions by defining a Freestream object.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.Freestream","category":"page"},{"location":"tutorial/#DuctTAPE.Freestream","page":"Quick Start","title":"DuctTAPE.Freestream","text":"Freestream{TVI,TVR,TF}\n\nFields:\n\nvinf::Float : Freestream velocities\nvref::Float : Reference velocities\nrho::Float : Air density value\nvso::Float : Speed of sound value\nmu::Float : Air dynamic viscosity value\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"#define freestream object from example case values\nfreestream = DuctTAPE.Freestream(vinf, vref, rho, vso, rmu)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"After we have created a freestream object, we can initialize the rotor aerodynamics (circulations and velocities) as well as initialize the rotor influence on the rotor wake grid aerodynamics. We'll do so using the initialize_system_aerodynamics function.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.initialize_system_aerodynamics","category":"page"},{"location":"tutorial/#DuctTAPE.initialize_system_aerodynamics","page":"Quick Start","title":"DuctTAPE.initialize_system_aerodynamics","text":"initialize_system_aerodynamics(\n    rotors, blades, wakegrid, freestream; niter=10, rlx=0.5\n)\n\nInitialize system aerodynamics for rotors and wakes.\n\nArguments:\n\nrotors::Array{DuctTAPE.RotorGeometry} : array of rotor geometries\nblades::Array{DuctTAPE.BladeDimensions} : array of dimensional blade geometries\nwakegrid::DuctTAPE.WakeGridGeometry : wake grid geometry\nfreestream::DuctTAPE.Freestream : freestream information\n\nReturns:\n\nsystemaero::DuctTAPE.SystemAero : aerodynamic values for rotor sections and wake grid\nrotorvelocities::DuctTAPE.RotorVelocities : velocities along rotor blades\nVm_avg::Float : initial guess for average axial velocity in the wakes\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The returns of this function include the SystemAero object and the RotorVelocities object (see below), as well as an average axial velocity that is used later.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.SystemAero\nDuctTAPE.RotorVelocities","category":"page"},{"location":"tutorial/#DuctTAPE.SystemAero","page":"Quick Start","title":"DuctTAPE.SystemAero","text":"SystemAero{TG,TH,TS,TC,TR}\n\nFields:\n\nb_gamma_grid::Matrix{Float} : B*Γ values on wake grid\ndelta_enthalpy_grid::Matrix{Float} : ΔH (enthalpy) values on wake grid\ndelta_entropy_grid::Matrix{Float} : ΔS (entropy) values on wake grid\nb_circ_rotors::Array{Array{Float}} : B*γ values at rotor blades (one array per rotor in increasing order of x location)\nrotor_source_strengths::Array{Array{Float}} : σ (source strength) values at rotor blades (one array per rotor in increasing order of x location)\ncontrol_point_velocities::Matrix{Float} : velocities at control points\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DuctTAPE.RotorVelocities","page":"Quick Start","title":"DuctTAPE.RotorVelocities","text":"RotorVelocities{TA}\n\nFields:\n\ninduced_axial_velocities::Array{Float} : local section induced axial velocities\ninduced_radial_velocities::Array{Float} : local section induced radial velocities\ninduced_tangential_velocities::Array{Float} : local section induced tangential (circumferential) velocities\nabsolute_axial_velocities::Array{Float} : local section absolute axial velocities\nabsolute_radial_velocities::Array{Float} : local section absolute radial velocities\nabsolute_tangential_velocities::Array{Float} : local section absolute tangential velocities\nrelative_axial_velocities::Array{Float} : local section relative axial velocities\nrelative_radial_velocities::Array{Float} : local section relative radial velocities\nrelative_tangential_velocities::Array{Float} : local section relateive tangential velocities\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# Get paneling of various objects\nwall_panels, hub_panels, wake_panels, rotor_source_panels = DuctTAPE.generate_paneling(\n    ductgeometry, ductsplines, rotors, wakegrid\n)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# initialize rotor and associated grid aerodynamics\nsystem_aero, rotor_velocities, average_axial_velocity = initialize_system_aerodynamics(\n    rotors, blades, wakegrid, rotor_source_panels, freestream)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Please note that the initialization that takes place here is soley based on the rotor aerodynamics.  At this point, we have not taken into account the duct influence and the wake has only been initialized with some of the rotor influence. To be specific, the entropy and control point velocities are set to zeros in this function as they will be properly initialized later. The circulations, velocities, and enthalpies initialized thus far are soley based on the rotors and simply provide a first guesss so we have somewhere to start in our solution process.","category":"page"}]
}
