var documenterSearchIndex = {"docs":
[{"location":"DuctAPE/api_index/#Index","page":"API Index","title":"Index","text":"","category":"section"},{"location":"DuctAPE/api_index/","page":"API Index","title":"API Index","text":"Modules=[DuctAPE, DuctAPE.C4Blade]","category":"page"},{"location":"C4Blade/api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"C4Blade/api/","page":"API Reference","title":"API Reference","text":"Pages = [\"C4Blade/api.md\"]\nDepth = 5","category":"page"},{"location":"C4Blade/intro/#C\\textrm{4}Blade-[[C](#)ascade-[C](#)ompatible-[CCBlade](https://flow.byu.edu/CCBlade.jl/stable/)]","page":"Intro","title":"C^textrm4Blade [Cascade Compatible CCBlade]","text":"","category":"section"},{"location":"C4Blade/intro/","page":"Intro","title":"Intro","text":"C^4Blade is a DuctAPE submodule containing a modified version of CCBlade that includes capabilities for cascade types.","category":"page"},{"location":"C4Blade/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"DuctAPE/theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"DuctAPE/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"DuctAPE/examples/#Advanced-Option-Selection","page":"Examples","title":"Advanced Option Selection","text":"","category":"section"},{"location":"DuctAPE/examples/","page":"Examples","title":"Examples","text":"(TODO: see src/utilities/options.jl)","category":"page"},{"location":"DuctAPE/examples/#Available-Outputs","page":"Examples","title":"Available Outputs","text":"","category":"section"},{"location":"DuctAPE/examples/#Returning-the-Pre-process-Objects","page":"Examples","title":"Returning the Pre-process Objects","text":"","category":"section"},{"location":"DuctAPE/examples/#Multi-Point-Analyses","page":"Examples","title":"Multi-Point Analyses","text":"","category":"section"},{"location":"DuctAPE/examples/#Pre-compiling-the-Caches","page":"Examples","title":"Pre-compiling the Caches","text":"","category":"section"},{"location":"DuctAPE/examples/","page":"Examples","title":"Examples","text":"There are several available caches that can be precompiled to help speed up multiple analyses. The first is a cache used for intermediate calculations in the pre- and post-processing phases of the analysis. It can be preallocated using allocate_prepost_container_cache","category":"page"},{"location":"DuctAPE/examples/","page":"Examples","title":"Examples","text":"DuctAPE.allocate_prepost_container_cache","category":"page"},{"location":"DuctAPE/examples/#DuctAPE.allocate_prepost_container_cache-DuctAPE-examples","page":"Examples","title":"DuctAPE.allocate_prepost_container_cache","text":"allocate_prepost_container_cache(paneling_constants::PanelingConstants)\nallocate_prepost_container_cache(problem_dimensions::ProblemDimensions)\n\nAllocate the pre- and post-processing cache (used for intermediate calculations) based on paneling constants or problem dimensions.\n\nArguments\n\npaneling_constants::PanelingConstants : a PanelingConstants object\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nReturns\n\nprepost_container_caching::NamedTuple : a Named Tuple containing:\nprepost_container_cache::PreallocationTools.DiffCache : the cache\nprepost_container_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/examples/","page":"Examples","title":"Examples","text":"The second is a cache containing parameters used in the solver, in other words, the results of the pre-processing phase. It can be preallocated using allocate_solve_parameter_cache.","category":"page"},{"location":"DuctAPE/examples/","page":"Examples","title":"Examples","text":"DuctAPE.allocate_solve_parameter_cache","category":"page"},{"location":"DuctAPE/examples/#DuctAPE.allocate_solve_parameter_cache-DuctAPE-examples","page":"Examples","title":"DuctAPE.allocate_solve_parameter_cache","text":"allocate_solve_parameter_cache(\n    solve_type::SolverOptionsType,\n    paneling_constants::PanelingConstants;\n    fd_chunk_size=12,\n    levels=1,\n)\nallocate_solve_parameter_cache(\n    solve_type::SolverOptionsType,\n    problem_dimensions::ProblemDimensions;\n    fd_chunk_size=12,\n    levels=1\n)\n\nAllocate the solve parameter cache for parameters passed into the solver(s).\n\nArguments\n\nsolve_type::SolverOptionsType : Solver options type used for dispatch\npaneling_constants::PanelingConstants : a PanlingConstants object used for sizing\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object used for sizing\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chuck size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nsolve_parameter_caching::NamedTuple : a Named Tuple containing:\nsolve_parameter_cache::PreallocationTools.DiffCache : the cache\nsolve_parameter_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/examples/","page":"Examples","title":"Examples","text":"The final precompileable cache is for intermediate calculations within the solve and can be preallocated using allocate_solve_container_cache","category":"page"},{"location":"DuctAPE/examples/","page":"Examples","title":"Examples","text":"DuctAPE.allocate_solve_container_cache","category":"page"},{"location":"DuctAPE/examples/#DuctAPE.allocate_solve_container_cache-DuctAPE-examples","page":"Examples","title":"DuctAPE.allocate_solve_container_cache","text":"allocate_solve_container_cache(\n    solve_type::SolverOptionsType,\n    paneling_constants::PanelingConstants;\n    fd_chunk_size=12,\n    levels=1,\n)\nallocate_solve_container_cache(\n    solve_type::SolverOptionsType,\n    problem_dimensions::ProblemDimensions;\n    fd_chunk_size=12,\n    levels=1,\n)\n\nAllocate the solve cache (used for intermediate calculations) based on paneling constants or problem dimensions.\n\nArguments\n\npaneling_constants::PanelingConstants : a PanelingConstants object\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chuck size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nsolve_container_caching::NamedTuple : a Named Tuple containing:\nsolve_container_cache::PreallocationTools.DiffCache : the cache\nsolve_container_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/examples/#Circumventing-the-Automated-Geometry-Re-paneling","page":"Examples","title":"Circumventing the Automated Geometry Re-paneling","text":"","category":"section"},{"location":"DuctAPE/private_api/#Private-API","page":"Private API Reference","title":"Private API","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"Pages = [\"private_api.md\"]\nDepth = 5","category":"page"},{"location":"DuctAPE/private_api/#Option-Types","page":"Private API Reference","title":"Option Types","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.DFDC_options\nDuctAPE.ConvergenceType\nDuctAPE.Relative\nDuctAPE.Absolute\nDuctAPE.SolverOptionsType\nDuctAPE.ExternalSolverOptions\nDuctAPE.PolyAlgorithmOptions\nDuctAPE.GridSolverOptionsType\nDuctAPE.IntegrationMethod","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.DFDC_options","page":"Private API Reference","title":"DuctAPE.DFDC_options","text":"function DFDC_options(;\n    grid_solver_options=SLORGridSolverOptions(),\n    solver_options=CSORSolverOptions(),\n    kwargs...,\n)\n\nConvenience function to select options used in DFDC.\n\nArguments\n\ngrid_solver_options=SLORGridSolverOptions() : elliptic grid solver options\nsolver_options=CSORSolverOptions() : solver options\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.ConvergenceType","page":"Private API Reference","title":"DuctAPE.ConvergenceType","text":"abstract type ConvergenceType\n\nUsed in dispatching the CSOR (controlled successive over relaxation) residual as relative or absolute.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/private_api/#DuctAPE.Relative","page":"Private API Reference","title":"DuctAPE.Relative","text":"struct Relative <: ConvergenceType\n\nUsed to dispatch the relative residual for CSOR (controlled successive over relaxation) method\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/private_api/#DuctAPE.Absolute","page":"Private API Reference","title":"DuctAPE.Absolute","text":"struct Absolute <: ConvergenceType\n\nUsed to dispatch the absolute residual for CSOR (controlled successive over relaxation)  method\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/private_api/#DuctAPE.SolverOptionsType","page":"Private API Reference","title":"DuctAPE.SolverOptionsType","text":"abstract type SolverOptionsType\n\nUsed for solver dispatch.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/private_api/#DuctAPE.ExternalSolverOptions","page":"Private API Reference","title":"DuctAPE.ExternalSolverOptions","text":"abstract type ExternalSolverOptions <: SolverOptionsType\n\nUsed for solver dispatch.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/private_api/#DuctAPE.PolyAlgorithmOptions","page":"Private API Reference","title":"DuctAPE.PolyAlgorithmOptions","text":"abstract type PolyAlgorithmOptions <: SolverOptionsType\n\nUsed for solver dispatch.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/private_api/#DuctAPE.GridSolverOptionsType","page":"Private API Reference","title":"DuctAPE.GridSolverOptionsType","text":"abstract type GridSolverOptionsType\n\nUsed for elliptic grid solver dispatch\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/private_api/#DuctAPE.IntegrationMethod","page":"Private API Reference","title":"DuctAPE.IntegrationMethod","text":"abstract type IntegrationMethod\n\nUsed in integration method dispatch\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/private_api/#Bookkeeping","page":"Private API Reference","title":"Bookkeeping","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.get_problem_dimensions","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.get_problem_dimensions","page":"Private API Reference","title":"DuctAPE.get_problem_dimensions","text":"get_problem_dimensions(paneling_constants::PanelingConstants)\nget_problem_dimensions(body_vortex_panels, rotor_source_panels, wake_vortex_panels)\n\nDetermine all relevant dimensions to the problem based either on the paneling_constants or the panels themselves.\n\nArguments\n\npaneling_constants::PanelingConstants : Rotor (and possibly stator) geometric paramters.\n\nReturns\n\nproblem_dimensions::ProblemDimensions : ProblemDimensions object.\n\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Caching","page":"Private API Reference","title":"Caching","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"TODO: go through through the rest of the caching directory and add the remaining files' functions","category":"page"},{"location":"DuctAPE/private_api/#Allocation","page":"Private API Reference","title":"Allocation","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"The following are various helper functions used in preallocating the various caches.","category":"page"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.allocate_wake_panel_container!\nDuctAPE.allocate_panel_containers!\nDuctAPE.allocate_panel_container!\nDuctAPE.allocate_body_panel_container!\nDuctAPE.allocate_rotor_panel_container!\nDuctAPE.allocate_solve_parameter_extras!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.allocate_wake_panel_container!","page":"Private API Reference","title":"DuctAPE.allocate_wake_panel_container!","text":"allocate_wake_panel_containers!(total_length, problem_dimensions::ProblemDimensions)\n\nA helper function is assembling the prepostcontainercache.\n\nArguments\n\ntotal_length::Vector{Int} : a one-element vector used to store the total length in order to know how large of a cache to allocate.  Is updated in place.\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nReturns\n\nwake_vortex_panels::NamedTuple : A named containing the dimensions needed to reshape the cache with regards to the wake vortex panel object\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.allocate_panel_containers!","page":"Private API Reference","title":"DuctAPE.allocate_panel_containers!","text":"allocate_panel_containers!(total_length, problem_dimensions::ProblemDimensions)\n\nA helper function is assembling the prepostcontainercache.\n\nArguments\n\ntotal_length::Vector{Int} : a one-element vector used to store the total length in order to know how large of a cache to allocate.  Is updated in place.\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nReturns\n\npanels::NamedTuple : A named tuple of named tuples containing the dimensions needed to reshape the cache with regards to the panel objects\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.allocate_panel_container!","page":"Private API Reference","title":"DuctAPE.allocate_panel_container!","text":"allocate_panel_container!(total_length, nn, np, tn, tp, nb)\n\nA helper function is assembling the prepostcontainercache.\n\nArguments\n\ntotal_length::Vector{Int} : a one-element vector used to store the total length in order to know how large of a cache to allocate.  Is updated in place.\nnn::Int : number of nodes in each body, rotor, or wake sheet\nnp::Int : number of panels in each body, rotor, or wake sheet\ntn::Int : number of total nodes among the bodies, rotors, or wake sheets\ntp::Int : number of total panels among the bodies, rotors, or wake sheets\nnb::Int : number of bodies, rotors, or wake sheets\n\nReturns\n\npanel::NamedTuple : A named containing the dimensions needed to reshape the cache with regards to an arbitrary panel set\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.allocate_body_panel_container!","page":"Private API Reference","title":"DuctAPE.allocate_body_panel_container!","text":"allocate_body_panel_containers!(total_length, problem_dimensions::ProblemDimensions)\n\nA helper function is assembling the prepostcontainercache.\n\nArguments\n\ntotal_length::Vector{Int} : a one-element vector used to store the total length in order to know how large of a cache to allocate.  Is updated in place.\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nReturns\n\nbody_vortex_panels::NamedTuple : A named tuple containing the dimensions needed to reshape the cache with regards to the body vortex panel object\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.allocate_rotor_panel_container!","page":"Private API Reference","title":"DuctAPE.allocate_rotor_panel_container!","text":"allocate_rotor_panel_containers!(total_length, problem_dimensions::ProblemDimensions)\n\nA helper function is assembling the prepostcontainercache.\n\nArguments\n\ntotal_length::Vector{Int} : a one-element vector used to store the total length in order to know how large of a cache to allocate.  Is updated in place.\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nReturns\n\nrotor_source_panels::NamedTuple : A named containing the dimensions needed to reshape the cache with regards to the rotor source panel object\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.allocate_solve_parameter_extras!","page":"Private API Reference","title":"DuctAPE.allocate_solve_parameter_extras!","text":"allocate_solve_parameter_extras!(\n    solver_options::SolverOptionsType, input_length, total_length\n)\n\nIncludes additional caching for various solvers.  Currently only does anything for SIAMFANLEOptions types.\n\nArguments\n\ninput_length::Int : the number of state variables in the solver\ntotal_length::Vector{Int} : a one-element vector used to store the total length in order to know how large of a cache to allocate.  Is updated in place.\n\nReturns\n\nsolve_parameter_extras::NamedTuple : A named tuple containing dimensions related to extra caching parameters used in various solvers.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Reshaping","page":"Private API Reference","title":"Reshaping","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"The following are used internally to reshape the cache vectors into more usable formats.","category":"page"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.withdraw_prepost_container_cache\nDuctAPE.withdraw_solve_parameter_cache\nDuctAPE.withdraw_solve_container_cache","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.withdraw_prepost_container_cache","page":"Private API Reference","title":"DuctAPE.withdraw_prepost_container_cache","text":"withdraw_prepost_container_cache(vec, dims)\n\nReshape the prepost cache vector using the saved dimensions tuple.\n\nArguments\n\nvec::Vector{Float} : vector cache of pre- and post-processing intermediate containers.\ndims::NamedTuple : Named tuple containing the indices and shape of the various items stored in the cache vector.\n\nReturns\n\nprepost_container_caching::NamedTuple : Named tuple containing reshaped views of sections of the cache vector.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.withdraw_solve_parameter_cache","page":"Private API Reference","title":"DuctAPE.withdraw_solve_parameter_cache","text":"withdraw_solve_parameter_cache(solver_options::SolverOptionsType, vec, dims)\n\nReshape the solve parameter cache vector using the saved dimensions tuple.\n\nArguments\n\nsolver_options::SolverOptionsType : Solver options type for dispatch.\nvec::Vector{Float} : vector cache of pre- and post-processing intermediate containers.\ndims::NamedTuple : Named tuple containing the indices and shape of the various items stored in the cache vector.\n\nReturns\n\nsolve_parameter_caching::NamedTuple : Named tuple containing reshaped views of sections of the cache vector.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.withdraw_solve_container_cache","page":"Private API Reference","title":"DuctAPE.withdraw_solve_container_cache","text":"withdraw_solve_container_cache(solver_options::SolverOptionsType, vec, dims)\n\nReshape the intermediate solve container cache vector using the saved dimensions tuple.\n\nArguments\n\nsolver_options::SolverOptionsType : Solver options type for dispatch.\nvec::Vector{Float} : vector cache of pre- and post-processing intermediate containers.\ndims::NamedTuple : Named tuple containing the indices and shape of the various items stored in the cache vector.\n\nReturns\n\nsolve_container_caching::NamedTuple : Named tuple containing reshaped views of sections of the cache vector.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Preprocess","page":"Private API Reference","title":"Preprocess","text":"","category":"section"},{"location":"DuctAPE/private_api/#General","page":"Private API Reference","title":"General","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.set_index_maps\nDuctAPE.precompute_parameters\nDuctAPE.precompute_parameters!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.set_index_maps","page":"Private API Reference","title":"DuctAPE.set_index_maps","text":"set_index_maps(\n    npanels,\n    ncenterbody_inlet,\n    nwake_sheets,\n    dte_minus_cbte,\n    wnm,\n    wenids,\n    nwp,\n    nwsp,\n    nbn,\n    ndp,\n    riiw,\n    nrotor,\n)\n\nSet values for index map to be used throughout solve and post-process.\n\nArguments\n\nnpanels : paneling_constants.npanels\nncenterbody_inlet : paneling_constants.ncenterbody_inlet\nnwake_sheets : paneling_constants.nwake_sheets\ndte_minus_cbte : paneling_constants.dte_minus_cbte\nwnm : wake_vortex_panels.nodemap\nwenids : wake_vortex_panels.endnodeidxs\nnwp :  problem_dimensions.nwp\nnwsp : problem_dimensions.nwsp\nnbn : problem_dimensions.nbn\nndp : body_vortex_panels.npanel[1]\nriiw : rotor_indices_in_wake\nnrotor : problem_dimensions.nrotor\n\nReturns\n\nidmaps::NamedTuple : A named tuple containing index mapping used in bookkeeping throughout solve and post-process\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.precompute_parameters","page":"Private API Reference","title":"DuctAPE.precompute_parameters","text":"precompute_parameters(\n    propulsor;\n    grid_solver_options=GridSolverOptions(),\n    integration_options=IntegrationOptions(),\n    autoshiftduct=true,\n    itcpshift=0.05,\n    axistol=1e-15,\n    tegaptol=1e1 * eps(),\n    finterp=FLOWMath.akima,\n    silence_warnings=true,\n    verbose=false,\n)\n\nOut of place main pre-processing function that computes all the required parameters for the solve.\n\nArguments\n\npropulsor::Propulsor : A Propuslor object\n\nKeyword Arguments\n\ngrid_solver_options::GridSolverOptionsType=GridSolverOptions() : A GridSolverOptionsType object\nintegration_options::IntegrationMethod=IntegrationOptions() : An IntegrationMethod object\nautoshiftduct::Bool=true : flag to shift duct geometry based on rotor tip radius\nitcpshift::Float=0.05 : value used in positioning the internal pseudo control point in the solid bodies. Default is DFDC hard-coded value.\naxistol::Float=1e-15 : tolerance for how close to the axis of rotation to be considered on the axis.\ntegaptol::Float=1e1 * eps() : tolerance for how large of a trailing edge gap is considered a gap.\nfinterp::Function=FLOWMath.akima : interpolation method for re-interpolating body coordinates\nsilence_warnings::Bool=true : flag to silence warnings\nverbose::Bool=false : flag to print verbose statements\n\nReturns\n\nivr::NamedTuple : A named tuple containing arrays of induced velocities on the rotors\nivw::NamedTuple : A named tuple containing arrays of induced velocities on the wake\nivb::NamedTuple : A named tuple containing arrays of induced velocities on the bodies\nlinsys::NamedTuple : A named tuple containing cacheable data for the linear system, including:\nA_bb::Array{Float} : AIC (LHS) matrix for the panel method system\nb_bf::Array{Float} : Initial system RHS vector based on freestrem magnitude\nA_br::Array{Float} : Unit normal velocity from rotors onto body panels\nA_pr::Array{Float} : Unit normal velocity from rotors onto body internal psuedo control points\nA_bw::Array{Float} : Unit normal velocity from wake onto body panels\nA_pw::Array{Float} : Unit normal velocity from wake onto body internal psuedo control points\nA_bb_LU::LinearAlgebra.LU : LinearAlgebra LU factorization of the LHS matrix\nlu_decomp_flag::Vector{Bool} : flag for whether factorization was successful\nblade_elements::NamedTuple : A named tuple containing cacheable blade element information (see docs for interpolate_blade_elements)\nairfoils::Vector{AFType} : A matrix of airfoil types associated with each of the blade elements\nwakeK::Matrix{Float} : A matrix of precomputed geometric constants used in the calculation of the wake vortex strengths\nidmaps::NamedTuple : A named tuple containing index mapping used in bookkeeping throughout solve and post-process\npanels::NamedTuple : A named tuple of panel objects including:\nbody_vortex_panels::NamedTuple : the named tuple containing the body vortex panel information\nrotor_source_panels::NamedTuple : the named tuple containing the rotor source panel information\nwake_vortex_panels::NamedTuple : the named tuple containing the wake vortex panel information\nproblem_dimensions::ProblemDimensions : A ProblemDimensions object\n\n\n\n\n\nprecompute_parameters(\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    wake_grid,\n    rotor_indices_in_wake,\n    Rtips,\n    Rhubs,\n    rotorstator_parameters,\n    paneling_constants,\n    operating_point,\n    integration_options,\n    problem_dimensions=nothing;\n    itcpshift=0.05,\n    axistol=1e-15,\n    tegaptol=1e1 * eps(),\n    silence_warnings=true,\n    verbose=false,\n)\n\nAn alternate version of precompute_parameters allowing for user defined geometry that does not go through a re-panling step (use with caution).\n\nThe first inputs are the outputs of the reinterpolate_geometry and get_blade_ends_from_body_geometry functions.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.precompute_parameters!","page":"Private API Reference","title":"DuctAPE.precompute_parameters!","text":"precompute_parameters!(\n    ivr,\n    ivw,\n    blade_element_cache,\n    linsys,\n    wakeK,\n    propulsor,\n    prepost_containers,\n    problem_dimensions;\n    grid_solver_options=GridSolverOptions(),\n    integration_options=IntegrationOptions(),\n    autoshiftduct=true,\n    itcpshift=0.05,\n    axistol=1e-15,\n    tegaptol=1e1 * eps(),\n    finterp=fm.akima,\n    silence_warnings=true,\n    verbose=false,\n)\n\nIn-place version of precompute_parameters.\n\n\n\n\n\nprecompute_parameters!(\n    ivr,\n    ivw,\n    blade_element_cache,\n    linsys,\n    wakeK,\n    wake_grid,\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    rotor_indices_in_wake,\n    rotorstator_parameters,\n    paneling_constants,\n    operating_point,\n    prepost_containers,\n    problem_dimensions=nothing;\n    integration_options=IntegrationOptions(),\n    itcpshift=0.05,\n    axistol=1e-15,\n    tegaptol=1e1 * eps(),\n    finterp=fm.akima,\n    silence_warnings=true,\n    verbose=false,\n)\n\nIn-place version of the precompute_parameters function by-passing the geometry reinterpolateion. (Use with caution)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Geometry","page":"Private API Reference","title":"Geometry","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.reinterpolate_geometry\nDuctAPE.reinterpolate_geometry!\nDuctAPE.generate_all_panels\nDuctAPE.generate_all_panels!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.reinterpolate_geometry","page":"Private API Reference","title":"DuctAPE.reinterpolate_geometry","text":"reinterpolate_geometry(\n    problem_dimensions,\n    duct_coordinates,\n    centerbody_coordinates,\n    rotorstator_parameters,\n    paneling_constants;\n    autoshiftduct=true,\n    grid_solver_options=GridSolverOptions(),\n    finterp=FLOWMath.akima,\n    verbose=false,\n    silence_warnings=true,\n)\n\nRe-interpolate the body geometry and return compatible body and way geometry.\n\nArguments\n\nproblem_dimensions::ProblemDimensions : A ProblemDimensions object\nduct_coordinates::Matrix{Float} : [z,r] coordinates of duct geometry\ncenterbody_coordinates::Matrix{Float} : [z,r] coordinates of centerbody geometry\nrotorstator_parameters::RotorStatorParameters : A RotorStatorParameters object\npaneling_constants::PanelingConstants : A PanelingConstants object\n\nKeyword Arguments\n\nautoshiftduct::Bool=true : flag to shift duct geometry based on rotor tip radius\ngrid_solver_options::SolverOptionsType=GridSolverOptions() : options for the wake grid position solver\nfinterp::Function=FLOWMath.akima : interpolation method for re-interpolating body coordinates\nverbose::Bool=false : flag to print verbose statements\nsilence_warnings::Bool=true : flag to silence warnings\n\nReturns\n\nwake_grid::Array{Float} : array containig the z and r elliptic grid points defning the wake geometry.\nrp_duct_coordinates::Matrix{Float} : matrix containing the re-paneled duct coordinates\nrp_centerbody_coordinates::Matrix{Float} : matrix containing the re-paneled centerbody coordinates\nrotor_indices_in_wake::Vector{Int} : vector containing the indices of where in the wake the rotors reside (used later to define the rotor panel edges).\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.reinterpolate_geometry!","page":"Private API Reference","title":"DuctAPE.reinterpolate_geometry!","text":"reinterpolate_geometry!(\n    wake_grid,\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    rotor_indices_in_wake,\n    duct_coordinates,\n    centerbody_coordinates,\n    rotorstator_parameters,\n    blade_element_cache,\n    paneling_constants;\n    autoshiftduct=true,\n    grid_solver_options=GridSolverOptions(),\n    finterp=FLOWMath.akima,\n    verbose=false,\n    silence_warnings=true,\n)\n\nIn-place version of reinterpolate_geometry.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.generate_all_panels","page":"Private API Reference","title":"DuctAPE.generate_all_panels","text":"generate_all_panels(\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    nwake_sheets,\n    rotor_indices_in_wake,\n    rotorzloc,\n    wake_grid;\n    itcpshift=0.05,\n    axistol=1e-15,\n    tegaptol=1e1 * eps(),\n    silence_warnings=true,\n)\n\nFunction that calls all of the various panel generation functions are returns a named tuple containing all the panels\n\nArguments\n\nrp_duct_coordinates::Matrix{Float} : matrix containing the re-paneled duct coordinates\nrp_centerbody_coordinates::Matrix{Float} : matrix containing the re-paneled centerbody coordinates\nnwake_sheets::Int : number of wake sheets\nrotor_indices_in_wake::Vector{Int} : vector containing the indices of where in the wake the rotors reside (used later to define the rotor panel edges).\nrotorzloc:Vector{Float} : axial locations of rotor lifting lines (contained in RotorStatorParameters)\nwake_grid::Array{Float} : array containig the z and r elliptic grid points defning the wake geometry.\n\nKeyword Arguments\n\nitcpshift::Float=0.05 : value used in positioning the internal pseudo control point in the solid bodies. Default is DFDC hard-coded value.\naxistol::Float=1e-15 : tolerance for how close to the axis of rotation to be considered on the axis.\ntegaptol::Float=1e1 * eps() : tolerance for how large of a trailing edge gap is considered a gap.\nsilence_warnings::Bool=true : flag to silence warnings\n\nReturns\n\npanels::NamedTuple : A named tuple of named tuples containing paneling information, including:\nbody_vortex_panels::NamedTuple\nrotor_source_panels::NamedTuple\nwake_vortex_panels::NamedTuple\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.generate_all_panels!","page":"Private API Reference","title":"DuctAPE.generate_all_panels!","text":"generate_all_panels!(\n    panels,\n    wake_grid,\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    rotor_indices_in_wake,\n    rotorzloc,\n    nwake_sheets;\n    itcpshift=0.05,\n    axistol=1e-15,\n    tegaptol=1e1 * eps(),\n    silence_warnings=true,\n)\n\nIn-place version of generate_all_panels.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Wake","page":"Private API Reference","title":"Wake","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.discretize_wake\nDuctAPE.generate_wake_grid\nDuctAPE.generate_wake_grid!\nDuctAPE.initialize_wake_grid\nDuctAPE.initialize_wake_grid!\nDuctAPE.relax_grid!\nDuctAPE.generate_wake_panels\nDuctAPE.generate_wake_panels!\nDuctAPE.get_wake_k\nDuctAPE.get_wake_k!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.discretize_wake","page":"Private API Reference","title":"DuctAPE.discretize_wake","text":"discretize_wake(\n    duct_coordinates,\n    centerbody_coordinates,\n    rotorzloc, # rotor axial locations\n    wake_length,\n    npanels,\n    dte_minus_cbte;\n)\n\nCalculate wake sheet panel node z-coordinates.\n\nArguments\n\nduct_coordinates::Matrix{Float} : Array of input duct coordinates\ncenterbody_coordinates::Matrix{Float} : Array of input centerbody_coordinates coordinates\nrotorzloc ::Vector{Float} : rotor axial locations\nwake_length::Float : non-dimensional length of wake to extend beyond aft-most body trailing edge.\nnpanels::Vector{Int} : A vector of the number of panels between each discrete point.  For example: [number of panels between the rotors; number of panels between the stator and the first trailing edge; number of panels between the trailing edges; number of panels between the last trailing edge and the end of the wake]\ndte_minus_cbte::Float : indicator as to whether the duct trailing edge minus the centerbody trailing edge is positive, zero, or negative.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.generate_wake_grid","page":"Private API Reference","title":"DuctAPE.generate_wake_grid","text":"generate_wake_grid(\n    problem_dimensions,\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    Rhub1,\n    Rtip1,\n    tip_gap1,\n    zwake;\n    grid_solver_options=GridSolverOptions(),\n    verbose=false,\n    silence_warnings=true,\n)\n\nInitialize and solve for elliptic grid on which wake sheets are defined.\n\nArguments\n\nproblem_dimensions:: : A ProblemDimensions object\nrp_duct_coordinates:: : repaneled duct coordinates\nrp_centerbody_coordinates:: : repaneled centerbody coordinates\nRhub1:: : Hub radius of first rotor\nRtip1:: : Tip radius of first rotor\ntip_gap1:: : Tip gap of first rotor (MUST BE ZERO for now)\nzwake:: : axial positions of wake sheet panel nodes\n\nKeyword Arguments\n\ngrid_solver_options::GridSolverOptionsType=GridSolverOptions() : options for solving the elliptic grid.\nverbose::Bool=false : flag to print verbose statements\nsilence_warnings::Bool=true : flag to supress warnings\n\nReturns\n\nwake_grid::Array{Float,3} : 3D Array of axial and radial wake_grid points after solution of elliptic system.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.generate_wake_grid!","page":"Private API Reference","title":"DuctAPE.generate_wake_grid!","text":"generate_wake_grid!(\n    wake_grid,\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    Rhub1,\n    Rtip1,\n    tip_gap1,\n    zwake;\n    grid_solver_options=grid_solver_options,\n    verbose=false,\n    silence_warnings=true,\n)\n\nIn-place version of generate_wake_grid.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.initialize_wake_grid","page":"Private API Reference","title":"DuctAPE.initialize_wake_grid","text":"initialize_wake_grid(rp_duct_coordinates, rp_centerbody_coordinates, zwake, rwake)\n\nIntialize the wake grid.\n\nArguments:\n\nrp_duct_coordinates::Matrix{Float} : The re-paneled duct coordinates\nrp_centerbody_coordinates::Matrix{Float} : The re-paneled centerbody coordinates\nzwake::Vector{Float} : The axial positions of the wake sheet panel nodes\nrwake::Vector{Float} : The radial positions of the blade elements for the foremost rotor\n\nReturns:\n\nwake_grid::Array{Float,3} : 3D Array of axial and radial wake_grid points\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.initialize_wake_grid!","page":"Private API Reference","title":"DuctAPE.initialize_wake_grid!","text":"initialize_wake_grid!(\n    wake_grid, rp_duct_coordinates, rp_centerbody_coordinates, zwake, rwake\n)\n\nIn-place version of initialize_wake_grid.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.relax_grid!","page":"Private API Reference","title":"DuctAPE.relax_grid!","text":"relax_grid!(\n    grid_solver_options::GridSolverOptionsType,\n    wake_grid;\n    verbose=false,\n    silence_warnings=true,\n    tabchar=\"    \",\n    ntab=1,\n)\n\nRelax/Solve initial wake grid according to elliptic system of equations.\n\nArguments\n\n`gridsolveroptions::GridSolverOptionsType' : options for elliptic grid solver\nwake_grid::Array{Float,3} : Initialized wake grid\n\nKeyword Arguments\n\n`verbose=false::' : flag for printing verbose statements\n`silence_warnings=true::' : flag for supressing warnings\n`tabchar::String=\"    \"::' : string to use for tabbing over verbose statements.\n`ntab::Int=1' : number of tabs for printing verbose statements\n\n\n\n\n\nrelax_grid!(xg, rg, nxi, neta; iteration_limit, atol)\n\nRelax wakegrid using elliptic wakegrid solver.\n\nArguments:\n\nKeyword Arguments:\n\niteration_limit::Int : maximum number of iterations to run, default=100\natol::Float : convergence tolerance, default = 1e-9\n\nReturns:\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.generate_wake_panels","page":"Private API Reference","title":"DuctAPE.generate_wake_panels","text":"generate_wake_panels(wake_grid)\n\nGenerate paneling for each wake sheet emanating from the rotor blade elements.\n\nArguments:\n\nwake_grid::Array{Float,3} : axial and radial locations of each wake_grid point (after relaxation/solution)\n\nReturns:\n\nwake_vortex_panels::NamedTuple : A named tuple of panel values describing the wake vortex panels\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.generate_wake_panels!","page":"Private API Reference","title":"DuctAPE.generate_wake_panels!","text":"generate_wake_panels!(wake_panels, wake_grid)\n\nIn-place version of generate_wake_panels.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.get_wake_k","page":"Private API Reference","title":"DuctAPE.get_wake_k","text":"get_wake_k(r, nwn)\n\nCalculate geometric constant for use in later calculation of wake panel node strengths.\n\nArguments\n\nr::Vector{Float} : Vector of wake panel node radial positions\n\nReturns\n\nK::Vector{Float} : Vector of geometric constants used in calculation of panel node strengths.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.get_wake_k!","page":"Private API Reference","title":"DuctAPE.get_wake_k!","text":"get_wake_k!(K, r)\n\nIn-place version of get_wake_k.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Bodies","page":"Private API Reference","title":"Bodies","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.reinterpolate_bodies!\nDuctAPE.place_duct!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.reinterpolate_bodies!","page":"Private API Reference","title":"DuctAPE.reinterpolate_bodies!","text":"reinterpolate_bodies!(\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    duct_coordinates,\n    centerbody_coordinates,\n    zwake,\n    ncenterbody_inlet,\n    nduct_inlet;\n    finterp=FLOWMath.akima,\n)\n\nReinterpolate duct and centerbody coordinates in order to make them compatible with the calculated wake sheet panel axial positions.\n\nArguments\n\nrp_duct_coordinates::Matrix{Float} : the re-paneled duct coordinates\nrp_centerbody_coordinates::Matrix{Float} : the re-paneled centerbody coordinates\nduct_coordinates::Matrix{Float} : the input duct coordinates\ncenterbody_coordinates::Matrix{Float} : the input centerbody coordinates\nzwake::Matrix{Float} : the wake sheet panel node axial positions\nncenterbody_inlet::Matrix{Float} : the number of panels to use for the centerbody inlet\nnduct_inlet::Matrix{Float} : the number of panels to use for the duct inlet\n\nKeyword Arguments\n\nfinterp::Function=FLOWMath.akima : interpolation method\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.place_duct!","page":"Private API Reference","title":"DuctAPE.place_duct!","text":"place_duct!(rp_duct_coordinates, Rtip, rotorzloc, tip_gap)\n\nTransform the duct radial coordinates such that the leading rotor radius touches the duct wall.\n\nNote that this function is called AFTER the repanling function is called, such that the rotorzloc locations should line up directly with the duct and centerbody coordinates.\n\nArguments\n\nrp_duct_coordinates::Matrix{Float} : the re-paneled duct coordinates\nRtip::Vector{Float} : Tip radii for the rotor(s)\nrotorzloc::Vector{Float} : axial position(s) of the rotor(s)\ntip_gap::Vector{Float} : tip gap for the fore-most rotor (MUST BE ZERO for now)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Rotors","page":"Private API Reference","title":"Rotors","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.interpolate_blade_elements\nDuctAPE.interpolate_blade_elements!\nDuctAPE.get_blade_ends_from_body_geometry\nDuctAPE.get_blade_ends_from_body_geometry!\nDuctAPE.get_local_solidity\nDuctAPE.get_stagger\nDuctAPE.generate_rotor_panels\nDuctAPE.generate_rotor_panels!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.interpolate_blade_elements","page":"Private API Reference","title":"DuctAPE.interpolate_blade_elements","text":"interpolate_blade_elements(\n    rsp, Rtips, Rhubs, rotor_panel_centers, nbe; finterp=FLOWMath.linear\n)\n\nInterpolate blade elements based on RotorStatorParameters inputs and number of desired blade elements (from number of wake sheet in PanelingConstants input)\n\nArguments\n\nrsp::RotorStatorParameters : A RotorStatorParameters object\n`Rtips::Vector{Float}' : Vector of rotor tip radii\n`Rhubs::Vector{Float}' : Vector of rotor hub radii\n`rotorpanelcenters::Vector{Float}' : Vector of rotor panel centers\nnbe::Int : number of blade elements per rotor\n\nKeyword Arguments\n\nfinterp::Function=FLOWMath.linear : interpolation method (note, using Akima splines as is done for the body geometry can lead to negative chord in some cases)\n\nReturns\n\nblade_element_cache::NamedTuple : A named tuple containing the cacheable blade element information excluding the airfoil data.\nairfoils::NamedTuple : A named tuple containing vectors of inner and outer airfoil polar data for each blade element, used in interpolating the input data at blade element locations.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.interpolate_blade_elements!","page":"Private API Reference","title":"DuctAPE.interpolate_blade_elements!","text":"interpolate_blade_elements!(\n    blade_element_cache, rsp, rotor_panel_centers, nbe; finterp=FLOWMath.linear\n)\n\nIn-place version of interpolate_blade_elements.\n\nReturns\n\nairfoils::NamedTuple : A named tuple containing vectors of inner and outer airfoil polar data for each blade element, used in interpolating the input data at blade element locations.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.get_blade_ends_from_body_geometry","page":"Private API Reference","title":"DuctAPE.get_blade_ends_from_body_geometry","text":"get_blade_ends_from_body_geometry(\n    rp_duct_coordinates, rp_centerbody_coordinates, tip_gaps, rotorzloc\n)\n\nObtain rotor hub and tip radii based on duct and centerbody geometry.\n\nArguments\n\nvar::type :\nrp_duct_coordinates::Matrix{Float} : re-paneled duct coordinates\nrp_centerbody_coordinates::Matrix{Float} : re-paneled centerbody coordinates\ntip_gaps::Vector{Float} : gaps between blade tips and duct surface (MUST BE ZEROS for now)\nrotorzloc::Vector{Float} : rotor lifting line axial positions.\n\nReturns\n\nRtips::Vector{Float} : rotor tip radii\nRhubs::Vector{Float} : rotor hub radii\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.get_blade_ends_from_body_geometry!","page":"Private API Reference","title":"DuctAPE.get_blade_ends_from_body_geometry!","text":"get_blade_ends_from_body_geometry!(\n    Rtip,\n    Rhub,\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    tip_gaps,\n    rotorzloc;\n    silence_warnings=true,\n)\n\nIn-place version of get_blade_ends_from_body_geometry.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.get_local_solidity","page":"Private API Reference","title":"DuctAPE.get_local_solidity","text":"get_local_solidity(B, chord, r)\n\nCalculate local solidity from local chord, radial position, and number of blades.\n\nArguments\n\nB::Float : number of blades on rotor (usually an integer, but not necessarily).\nchord::Vector{Float} : chord lengths at each radial station.\nr::Vector{Float} : dimensional radial positions.\n\nReturns\n\nsolidity::Vector{Float} : local solidity at each radial station\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.get_stagger","page":"Private API Reference","title":"DuctAPE.get_stagger","text":"get_stagger(twists)\n\nConvert twist angle to stagger angle\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.generate_rotor_panels","page":"Private API Reference","title":"DuctAPE.generate_rotor_panels","text":"generate_rotor_panels(rotorzloc, wake_grid, rotor_indices_in_wake, nwake_sheets)\n\nGenerate rotor panel objects.\n\nArguments\n\nrotorzloc::Vector{Float} : rotor lifting line axial position\nwake_grid::Array{Float,3} : wake elliptic grid axial and radial locations\nrotor_indices_in_wake::Vector{Int} : indices of where along wake the rotors are placed\nnwake_sheets::Int : number of wake sheets\n\nReturns\n\nrotor_source_panels::NamedTuple : A named tuple containing the rotor source panel variables.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.generate_rotor_panels!","page":"Private API Reference","title":"DuctAPE.generate_rotor_panels!","text":"generate_rotor_panels!(\n    rotor_source_panels, rotorzloc, wake_grid, rotor_indices_in_wake, nwake_sheets\n)\n\nIn-place version of generate_rotor_panels.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Induced-Velocities","page":"Private API Reference","title":"Induced Velocities","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.calculate_unit_induced_velocities\nDuctAPE.calculate_unit_induced_velocities!\nDuctAPE.initialize_linear_system\nDuctAPE.initialize_linear_system!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.calculate_unit_induced_velocities","page":"Private API Reference","title":"DuctAPE.calculate_unit_induced_velocities","text":"calculate_unit_induced_velocities(problem_dimensions, panels, integration_options)\n\nCalculate all the unit-induced velocties of all panels on all control points\n\nArguments\n\nproblem_dimensions::ProblemDimensions : A ProblemDimensions object\npanels::NamedTuple : A named tuple containing all the paneling information\nintegration_options::IntegrationOptions : Options used for integration of velocity kernals across panels\n\nReturns\n\nivr::NamedTuple : A named tuple containing arrays of induced velocities on the rotors\nivw::NamedTuple : A named tuple containing arrays of induced velocities on the wake\nivb::NamedTuple : A named tuple containing arrays of induced velocities on the bodies\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.calculate_unit_induced_velocities!","page":"Private API Reference","title":"DuctAPE.calculate_unit_induced_velocities!","text":"calculate_unit_induced_velocities!(ivr, ivw, ivb, panels, integration_options)\n\nIn-place version of calculate_unit_induced_velocities.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.initialize_linear_system","page":"Private API Reference","title":"DuctAPE.initialize_linear_system","text":"initialize_linear_system(\n    ivb,\n    body_vortex_panels,\n    rotor_source_panels,\n    wake_vortex_panels,\n    Vinf,\n    integration_options,\n)\n\nSet up the linear system used in the panel method solve.\n\nArguments\n\nivb::NamedTuple : the named tuple containing all the unit induced velocities on the bodies\nbody_vortex_panels::NamedTuple : the named tuple containing the body vortex panel information\nrotor_source_panels::NamedTuple : the named tuple containing the rotor source panel information\nwake_vortex_panels::NamedTuple : the named tuple containing the wake vortex panel information\nVinf::Vector{Float} : the one-element vector containing the Freestream velocity magnitude\nintegration_options::IntegrationOptions : the integration options used in integrating the panel induced velocities\n\nReturns\n\nlinsys::NamedTuple : A named tuple containing cacheable data for the linear system, including:\nA_bb::Array{Float} : AIC (LHS) matrix for the panel method system\nb_bf::Array{Float} : Initial system RHS vector based on freestrem magnitude\nA_br::Array{Float} : Unit normal velocity from rotors onto body panels\nA_pr::Array{Float} : Unit normal velocity from rotors onto body internal psuedo control points\nA_bw::Array{Float} : Unit normal velocity from wake onto body panels\nA_pw::Array{Float} : Unit normal velocity from wake onto body internal psuedo control points\nA_bb_LU::LinearAlgebra.LU : LinearAlgebra LU factorization of the LHS matrix\nlu_decomp_flag::Vector{Bool} : flag for whether factorization was successful\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.initialize_linear_system!","page":"Private API Reference","title":"DuctAPE.initialize_linear_system!","text":"initialize_linear_system!(\n    linsys,\n    ivb,\n    body_vortex_panels,\n    rotor_source_panels,\n    wake_vortex_panels,\n    Vinf,\n    intermediate_containers,\n    integration_options,\n)\n\nIn-place version of initialize_linear_system.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Unit-Induced-Velocities","page":"Private API Reference","title":"Unit Induced Velocities","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.calculate_xrm\nDuctAPE.calculate_xrm!\nDuctAPE.get_elliptics\nDuctAPE.vortex_ring_vz\nDuctAPE.vortex_ring_vz!\nDuctAPE.smoke_ring_vz\nDuctAPE.vortex_ring_vr\nDuctAPE.vortex_ring_vr!\nDuctAPE.source_ring_vz\nDuctAPE.source_ring_vz!\nDuctAPE.source_ring_vr\nDuctAPE.source_ring_vr!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.calculate_xrm","page":"Private API Reference","title":"DuctAPE.calculate_xrm","text":"calculate_xrm(controlpoint, node)\n\nCalculate xi, rho, and m for vortex and/or source ring induced velocity calculation.\n\nReturns zeros if ring is on (or approximately on) the axis of rotation (zero radius).\n\nArguments\n\ncontrolpoint::Vector{Float} [z r] coordinates of point being influenced\nnode::Vector{Float} : [z r] coordinates of singularity ring\n\nReturns\n\nxi::Float : normalized relative axial position\nrho::Float : normalized relative radial position\nm::Float : Elliptic integral input\nrj::Float : radial position of the ring\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.calculate_xrm!","page":"Private API Reference","title":"DuctAPE.calculate_xrm!","text":"calculate_xrm!(cache_vec, controlpoint, node)\n\nIn-place version of calculate_xrm.\n\nCache_vec is a vector used to hold intermediate values as well as the outputs.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.get_elliptics","page":"Private API Reference","title":"DuctAPE.get_elliptics","text":"get_elliptics(m)\n\nCalculate value of elliptic functions for the given geometry parameter.\n\nArguments\n\nm::Float : Elliptic Function parameter\n\nReturns\n\nK::Float : K(m), value of elliptic function of the first kind at m.\nE::Float : E(m), value of eeliptic function of the second kind at m.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.vortex_ring_vz","page":"Private API Reference","title":"DuctAPE.vortex_ring_vz","text":"vortex_ring_vz(xi, rho, m, r_influence, influence_length)\n\nAxial velocity induced by axisymmetric vortex ring.\n\nUses equivalent smoke ring induced velocity for self-induction, and returns zero if vortex ring is on axis of rotation (zero radius).\n\nArguments\n\nxi::Float : normalized z-coordinate, (z-zo)/ro\nrho::Float : normalized r-coordinate, r/ro\nm::Float : Elliptic Integral parameter, 4rho/sqrt(xi^2+(rho+1)^2)\nr_influence::Float : radial location of vortex ring, ro\ninfluence_length::Float : length of panel used in calculating self-induction\n\nReturns\n\nvz::Float : axially induced velocity of vortex ring\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.vortex_ring_vz!","page":"Private API Reference","title":"DuctAPE.vortex_ring_vz!","text":"vortex_ring_vz!(xi, rho, m, r_influence, influence_length, cache_vec)\n\nSame as vortexringvz, but uses the cache_vec to store intermediate calculations.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.smoke_ring_vz","page":"Private API Reference","title":"DuctAPE.smoke_ring_vz","text":"smoke_ring_vz(r_influence, influence_length)\n\nEquivalent \"smoke\" ring self-induced velocity.\n\nArguments\n\nr_influence::Float : radial position of ring (i.e. the ring raidus)\ninfluence_length::Float : length of influencing panel\n\nReturs\n\nvz::Float : axially induced velocity of vortex ring\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.vortex_ring_vr","page":"Private API Reference","title":"DuctAPE.vortex_ring_vr","text":"vortex_ring_vr(xi, rho, m, r_influence)\n\nRadial velocity induced by axisymmetric vortex ring.\n\nReturns zero if vortex ring is on axis of rotation (zero radius), the point of influence is on the axis, or if self-inducing velocity.\n\nArguments\n\nxi::Float : normalized z-coordinate, (z-zo)/ro\nrho::Float : normalized r-coordinate, r/ro\nm::Float : Elliptic Integral parameter, 4rho/sqrt(xi^2+(rho+1)^2)\nr_influence::Float : radial location of vortex ring, ro\n\nReturns\n\nvr::Float : radially induced velocity of vortex ring\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.vortex_ring_vr!","page":"Private API Reference","title":"DuctAPE.vortex_ring_vr!","text":"vortex_ring_vr!(xi, rho, m, r_influence, cache_vec)\n\nSame as vortexringvr, but uses the cache_vec to store intermediate calculations.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.source_ring_vz","page":"Private API Reference","title":"DuctAPE.source_ring_vz","text":"source_ring_vz(xi, rho, m, r_influence)\n\nAxial velocity induced by axisymmetric source ring.\n\nReturns zero if source ring is on axis of rotation (zero radius), the point of influence is on the axis, or if self-inducing velocity.\n\nArguments:\n\nxi::Float : normalized z-coordinate, (z-zo)/ro\nrho::Float : normalized r-coordinate, r/ro\nm::Float : Elliptic Integral parameter, 4rho/sqrt(xi^2+(rho+1)^2)\nr_influence::Float : radial location of vortex ring, ro\n\nReturns:\n\nvz::Float : axially induced velocity of source ring\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.source_ring_vz!","page":"Private API Reference","title":"DuctAPE.source_ring_vz!","text":"source_ring_vz!(xi, rho, m, r_influence, cache_vec)\n\nSame as sourceringvz, but uses cache_vec to store intermediate values.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.source_ring_vr","page":"Private API Reference","title":"DuctAPE.source_ring_vr","text":"source_ring_vr(xi, rho, m, r_influence)\n\nRadial velocity induced by axisymmetric source ring.\n\nReturns zero if source ring is on axis of rotation (zero radius), the point of influence is on the axis, or if self-inducing velocity.\n\nArguments:\n\nxi::Float : normalized z-coordinate, (z-zo)/ro\nrho::Float : normalized r-coordinate, r/ro\nm::Float : Elliptic Integral parameter, 4rho/sqrt(xi^2+(rho+1)^2)\nr_influence::Float : radial location of vortex ring, ro\n\nReturns:\n\nvr::Float : radially induced velocity of source ring\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.source_ring_vr!","page":"Private API Reference","title":"DuctAPE.source_ring_vr!","text":"source_ring_vr!(xi, rho, m, r_influence, cache_vec)\n\nSame as sourceringvr, but uses cache_vec to store intermediate values.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Unit-Induced-Velocity-Matrices","page":"Private API Reference","title":"Unit Induced Velocity Matrices","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.induced_velocities_from_vortex_panels_on_points\nDuctAPE.induced_velocities_from_vortex_panels_on_points!\nDuctAPE.induced_velocities_from_source_panels_on_points\nDuctAPE.induced_velocities_from_source_panels_on_points!\nDuctAPE.induced_velocities_from_trailing_edge_gap_panel!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.induced_velocities_from_vortex_panels_on_points","page":"Private API Reference","title":"DuctAPE.induced_velocities_from_vortex_panels_on_points","text":"induced_velocities_from_vortex_panels_on_points(\n    controlpoints,\n    nodes,\n    nodemap,\n    influence_lengths,\n    strengths,\n    integration_options;\n    integration_caches=nothing,\n)\n\nCalculate axial and radial components of induced velocity for a set of control points due to a set of axisymmetric vortex panels (bands).\n\nUsed for getting the unit induced velocities due to the body panels on the rotor/wake as well as the unit induced velocity due to the wake on the body/rotor.\n\nArguments\n\ncontrolpoints::Matrix{Float} [z r] coordinates of points being influenced\nnodes::Matrix{Float} : [z r] coordinates of vortex rings\nnodemap::Matrix{Int} : mapping from panel index to associated node indices\ninfluence_lengths::Vector{Float} : lengths over which vortex ring influence is applied on the surface.\nstrengths::Matrix{Float} : vortex constant circulation values\nintegration_options::IntegrationOptions : integration options\n\nKeyword Arguments\n\nintegration_caches::NamedTuple=nothing : cache used in in-place quadrature functions.\n\nReturns\n\nVEL::Array{Float} : N-controlpoint x N-node x [vz, vr] array of induced velocity components\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.induced_velocities_from_vortex_panels_on_points!","page":"Private API Reference","title":"DuctAPE.induced_velocities_from_vortex_panels_on_points!","text":"induced_velocities_from_vortex_panels_on_points!(\n    VEL,\n    controlpoint,\n    node,\n    nodemap,\n    influence_length,\n    strength,\n    integration_options;\n    integration_caches=nothing,\n)\n\nIn-place version of induced_velocities_from_vortex_panels_on_points.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.induced_velocities_from_source_panels_on_points","page":"Private API Reference","title":"DuctAPE.induced_velocities_from_source_panels_on_points","text":"induced_velocities_from_source_panels_on_points(\n    controlpoints,\n    nodes,\n    nodemap,\n    influence_lengths,\n    strengths,\n    integration_options;\n    integration_caches=nothing,\n)\n\nCalculate axial and radial components of induced velocity for a set of control points due to a set of axisymmetric source panels (bands)\n\nUsed for getting the unit induced velocities due to the body panels on the rotor/wake as well as the unit induced velocity due to the wake on the body/rotor.\n\nArguments\n\ncontrolpoints::Matrix{Float} [z r] coordinates of points being influenced\nnodes::Matrix{Float} : [z r] coordinates of vortex rings\nnodemap::Matrix{Int} : mapping from panel index to associated node indices\ninfluence_lengths::Vector{Float} : lengths over which vortex ring influence is applied on the surface.\nstrengths::Matrix{Float} : source constant strength values\nintegration_options::IntegrationOptions : integration options\n\nReturns:\n\nVEL::Array{Float} : N-controlpoint x N-node x [vz, vr] array of induced velocity components\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.induced_velocities_from_source_panels_on_points!","page":"Private API Reference","title":"DuctAPE.induced_velocities_from_source_panels_on_points!","text":"induced_velocities_from_source_panels_on_points!(\n    VEL,\n    controlpoint,\n    node,\n    nodemap,\n    influence_length,\n    strength,\n    integration_options;\n    integration_caches=nothing,\n)\n\nIn-place version of induced_velocities_from_source_panels_on_points.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.induced_velocities_from_trailing_edge_gap_panel!","page":"Private API Reference","title":"DuctAPE.induced_velocities_from_trailing_edge_gap_panel!","text":"induced_velocities_from_trailing_edge_gap_panel!(\n    VEL,\n    controlpoint,\n    tenode,\n    teinfluence_length,\n    tendotn,\n    tencrossn,\n    teadjnodeidxs,\n    integration_options;\n    wake=false,\n    integration_caches=nothing,\n)\n\nCalculate axial and radial components of induced velocity for a set of control points due to any trailing edge gap panels.\n\nUsed for getting the unit induced velocities due to the body body trailing edge gap panels on the body/rotor/wake.\n\nNote, this function is also used to calculate the influence of the wake ends rather than modeling a semi-infinite fortex sheet.\n\nArguments\n\nVEL::Array{Float} : N-controlpoint x N-node x [vz, vr] array of induced velocity components (modified in place)\ncontrolpoints::Matrix{Float} [z r] coordinates of points being influenced\nnodes::Matrix{Float} : [z r] coordinates of vortex rings\nnodemap::Matrix{Int} : mapping from panel index to associated node indices\ninfluence_lengths::Vector{Float} : lengths over which vortex ring influence is applied on the surface.\nstrengths::Matrix{Float} : vortex constant circulation values\nintegration_options::IntegrationOptions : integration options\n\nKeyword Arguments\n\nwake::Bool=false : flag to indicate if this is being used for a wake sheet.\nintegration_caches::NamedTuple=nothing : cache used in in-place quadrature functions.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Panel-Method-Velocity-Functions","page":"Private API Reference","title":"Panel Method Velocity Functions","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.vortex_aic_boundary_on_boundary\nDuctAPE.vortex_aic_boundary_on_boundary!\nDuctAPE.vortex_aic_boundary_on_field\nDuctAPE.vortex_aic_boundary_on_field!\nDuctAPE.add_kutta!\nDuctAPE.add_te_gap_aic!\nDuctAPE.source_aic\nDuctAPE.source_aic!\nDuctAPE.freestream_influence_vector\nDuctAPE.freestream_influence_vector!\nDuctAPE.assemble_lhs_matrix\nDuctAPE.assemble_lhs_matrix!\nDuctAPE.factorize_LHS\nDuctAPE.factorize_LHS!\nDuctAPE.assemble_rhs_matrix\nDuctAPE.assemble_rhs_matrix!\nDuctAPE.calculate_normal_velocity\nDuctAPE.calculate_normal_velocity!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.vortex_aic_boundary_on_boundary","page":"Private API Reference","title":"DuctAPE.vortex_aic_boundary_on_boundary","text":"vortex_aic_boundary_on_boundary(\n    controlpoint, normal, node, nodemap, influence_length, integration_options\n)\n\nCalculate panel method influence coefficients (V dot nhat) for a set of control points (on panels) due to a set of axisymmetric vortex rings (also on body surface)\n\nCan be used for constructing the LHS influence Matrix for the panel method system.\n\nArguments\n\ncontrolpoint::Matrix{Float} [z r] coordinates of points being influenced\nnormal::Matrix{Float} : unit normal vectors of the panels on which the control points are situated.\nnode::Matrix{Float} : [z r] coordinates of panel nodes (edges)\nnodemap::Matrix{Int} : [1 2] node indices for each panel\ninfluence_length::Vector{Float} : lengths of influencing panels\nintegration_options::IntegrationOptions : integration options\n\nReturns\n\nAICn::Matrix{Float} : N controlpoint x N+1 node  array of V dot nhat values\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.vortex_aic_boundary_on_boundary!","page":"Private API Reference","title":"DuctAPE.vortex_aic_boundary_on_boundary!","text":"vortex_aic_boundary_on_boundary!(\n    AICn,\n    controlpoint,\n    normal,\n    node,\n    nodemap,\n    influence_length,\n    integration_options;\n    integration_caches=nothing,\n)\n\nIn-place verion of vortex_aic_boundary_on_boundary.\n\nintegration_caches is a named tuple containing caching for intermediate calculation values.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.vortex_aic_boundary_on_field","page":"Private API Reference","title":"DuctAPE.vortex_aic_boundary_on_field","text":"vortex_aic_boundary_on_field(\n    controlpoint,\n    normal,\n    node,\n    nodemap,\n    influence_length,\n    integration_options;\n    integration_caches=nothing,\n)\n\nCalculate panel method influence coefficients (V dot nhat) for a set of control points (NOT on panels) due to a set of axisymmetric vortex rings (on body surface)\n\nUsed for constructing portions of the panel method LHS matrix related to the pseudo control points in the bodies.\n\nArguments:\n\ncontrolpoint::Matrix{Float} [z r] coordinates of points being influenced\nnormal::Matrix{Float} : unit normal vectors of the panels on which the control points are situated.\nnode::Matrix{Float} : [z r] coordinates of panel nodes (edges)\nnodemap::Matrix{Int} : [1 2] node indices for each panel\ninfluence_length::Vector{Float} : lengths of influencing panels\nintegration_options::IntegrationOptions : integration options\n\nKeyword Arguments\n\nintegration_caches::NamedTuple=nothing : caches for intermediate values in integration.\n\nReturns:\n\nAICn::Matrix{Float} : N controlpoint x N+1 node  array of V dot nhat values\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.vortex_aic_boundary_on_field!","page":"Private API Reference","title":"DuctAPE.vortex_aic_boundary_on_field!","text":"vortex_aic_boundary_on_field!(\n    AICn,\n    controlpoint,\n    normal,\n    node,\n    nodemap,\n    influence_length,\n    integration_options;\n    integration_caches=nothing,\n)\n\nIn-place version of vortex_aic_boundary_on_field.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.add_kutta!","page":"Private API Reference","title":"DuctAPE.add_kutta!","text":"add_kutta!(LHS, AICn, kids)\n\nAdd Kutta condition (1 + N = 0) to LHS matrix.\n\nLHS::Matrix{Float} : a pre-allocated (zeros) full size left-hand side matrix\nAICn::Matrix{Float} :  influence coefficients for panels/nodes\nkids::Vector{Int} : [1 2] indices of where to put 1's for kutta condition\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.add_te_gap_aic!","page":"Private API Reference","title":"DuctAPE.add_te_gap_aic!","text":"add_te_gap_aic!(\n    AICn,\n    controlpoint,\n    normal,\n    tenode,\n    teinfluence_length,\n    tendotn,\n    tencrossn,\n    teadjnodeidxs,\n    integration_options;\n    wake=false,\n    integration_caches=nothing,\n)\n\nAdd trailing edge gap aerodynmic influence coefficient contributions to the AIC matrix.\n\nArguments\n\nAICn::Matrix{Float} : N controlpoint x N+1 node  array of V dot nhat values\ncontrolpoint::Matrix{Float} [z r] coordinates of points being influenced\nnormal::Matrix{Float} : unit normal vectors of the panels on which the control points are situated.\ntenode::Matrix{Float} : [z r] coordinates of trailing edge panel nodes (edges)\nteinfluence_length::Vector{Float} : lengths of influencing trailing edge panels\ntendotn::Matrix{Float} : nhat of trailing edge panel dotted with nhat of adjacent panels\ntencrossn::Matrix{Float} : nhat of trailing edge panel crossed with nhat of adjacent panels\nteadjnodeidxs::Matrix{Float} : indices of nodes adjacent to trailing edge panel\nintegration_options::IntegrationOptions : integration options\n\nKeyword Arguments\n\nwake::Bool=false : flag as to whether this function is being applied to a wake sheet.\nintegration_caches::NamedTuple=nothing : caches for intermediate values in integration.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.source_aic","page":"Private API Reference","title":"DuctAPE.source_aic","text":"source_aic(\n    controlpoint,\n    normal,\n    node,\n    nodemap,\n    influence_length,\n    integration_options;\n    integration_caches=nothing,\n)\n\nCalculate panel method influence coefficients (V dot nhat) for a set of control points (on panels) due to a set of axisymmetric source rings not on body surface.\n\nCan be used for constructing the RHS boundary conditions due to rotor source panels.\n\nArguments\n\ncontrolpoint::Matrix{Float} [z r] coordinates of points being influenced\nnormal::Matrix{Float} : unit normal vectors of the panels on which the control points are situated.\nnode::Matrix{Float} : [z r] coordinates of panel nodes (edges)\nnodemap::Matrix{Int} : [1 2] node indices for each panel\ninfluence_length::Vector{Float} : lengths of influencing panels\nintegration_options::IntegrationOptions : integration options\n\nKeyword Arguments\n\nintegration_caches::NamedTuple=nothing : caches for intermediate values in integration.\n\nReturns\n\nAICn::Matrix{Float} : N controlpoint x N+1 node  array of V dot nhat values\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.source_aic!","page":"Private API Reference","title":"DuctAPE.source_aic!","text":"source_aic!(\n    AICn,\n    controlpoint,\n    normal,\n    node,\n    nodemap,\n    influence_length,\n    integration_options;\n    integration_caches=nothing,\n)\n\nIn-place version of source_aic.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.freestream_influence_vector","page":"Private API Reference","title":"DuctAPE.freestream_influence_vector","text":"freestream_influence_vector(normals, Vinfmat)\n\nCalculate RHS contributions due to freestream.\n\nNote that the freestream is assumed to have zero radial component in the underlying theory, but here we allow an arbitrary 2D vector for velocity for taking the dot product easier.\n\nArguments\n\nnormals::Matrix{Float} : unit normal vectors of the panels on which the control points are situated.\nVinfmat::Matrix{Float} : [z r] components of freestream velocity (r's should be zero)\n\nReturns\n\nRHS::Vector{Float} : vector of normal components of freestream velocity on input panels\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.freestream_influence_vector!","page":"Private API Reference","title":"DuctAPE.freestream_influence_vector!","text":"freestream_influence_vector!(RHS, normals, Vinfmat)\n\nIn-place version of freestream_influence_vector.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.assemble_lhs_matrix","page":"Private API Reference","title":"DuctAPE.assemble_lhs_matrix","text":"assemble_lhs_matrix(\n    AICn, AICpcp, npanel, nnode, totpanel, totnode, prescribednodeidxs; dummyval=1.0\n)\n\nAssemble the LHS matrix of the panel method.\n\nArguments\n\nAICn::Matrix{Float} : N controlpoint x N+1 node  array of V dot nhat values\nAICpcp::Matrix{Float} : Nbodies controlpoint x N+1 node  array of V dot nhat values (influence on psuedo control points)\nnpanel::Vector{Int} : number of panels comprising each body\nnnode::Vector{Int} : number of nodes comprising each body\ntotpanel::Int : total number of panels\ntotnode::Int : total number of nodes\nprescribednodeidxs::Vector{Int} : indices of nodes with prescribed strengths (those on the axis of rotation).\n\nKeyword Arguments\n\ndummyval::Float=1.0 : value for dummy input for prescribed and internal control points in the system. Do not change except for debugging purposes.\n\nReturns\n\nLHS::Matrix{Float} : The full LHS matrix for the panel method.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.assemble_lhs_matrix!","page":"Private API Reference","title":"DuctAPE.assemble_lhs_matrix!","text":"assemble_lhs_matrix!(\n    LHS, AICn, AICpcp, npanel, nnode, totpanel, totnode, prescribednodeidxs; dummyval=1.0\n)\n\nIn-place version of assemble_lhs_matrix.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.factorize_LHS","page":"Private API Reference","title":"DuctAPE.factorize_LHS","text":"factorize_LHS(A::AbstractMatrix)\n\nReturns the LU decomposition of A.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.factorize_LHS!","page":"Private API Reference","title":"DuctAPE.factorize_LHS!","text":"factorize_LHS!(Apivot::AbstractMatrix, A::AbstractMatrix)\n\nReturns the LU decomposition of A using Apivot as storage memory to pivot leaving A unchanged.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.assemble_rhs_matrix","page":"Private API Reference","title":"DuctAPE.assemble_rhs_matrix","text":"assemble_rhs_matrix(\n    vdnb, vdnpcp, npanel, nnode, totpanel, totnode, prescribednodeidxs\n)\n\nArguments\n\nvdnb::Vector{Float} : V dot nhat for body panels\nvdnpcp::Vector{Float} : V dot nhat for pseudo control points\nnpanel::Vector{Int} : number of panels comprising each body\nnnode::Vector{Int} : number of nodes comprising each body\ntotpanel::Int : total number of body panels\ntotnode::Int : total number of body nodes\nprescribednodeidxs::Vector{Int} : indices of nodes with prescribed strengths (those on the axis of rotation)\n\nReturns\n\nRHS::Vector{Float} : the RHS vector of the panel method.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.assemble_rhs_matrix!","page":"Private API Reference","title":"DuctAPE.assemble_rhs_matrix!","text":"assemble_rhs_matrix!(\n    RHS, vdnb, vdnpcp, npanel, nnode, totpanel, totnode, prescribednodeidxs\n)\n\nIn-place version of assemble_rhs_matrix.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.calculate_normal_velocity","page":"Private API Reference","title":"DuctAPE.calculate_normal_velocity","text":"calculate_normal_velocity(velocity_vector, normal)\n\nCalculate normal velocity_vector (V dot nhat).\n\nArguments\n\nvelocity_vector::Matrix{Float} : velocity vector [z r] on each panel\nnormal::Matrix{Float} : the panel unit normals\n\nReturns\n\nAIC::Matrix{Float} : V dot n on each panel\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.calculate_normal_velocity!","page":"Private API Reference","title":"DuctAPE.calculate_normal_velocity!","text":"calculate_normal_velocity!(AIC, velocity_vector, normal)\n\nIn-place version of calculate_normal_velocity.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Quadrature","page":"Private API Reference","title":"Quadrature","text":"","category":"section"},{"location":"DuctAPE/private_api/#Integrands","page":"Private API Reference","title":"Integrands","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.nominal_vortex_induced_velocity_sample\nDuctAPE.nominal_vortex_induced_velocity_sample!\nDuctAPE.subtracted_singular_vortex_influence\nDuctAPE.subtracted_singular_vortex_influence!\nDuctAPE.analytically_integrated_vortex_influence\nDuctAPE.analytically_integrated_vortex_influence!\nDuctAPE.self_vortex_induced_velocity_sample\nDuctAPE.self_vortex_induced_velocity_sample!\nDuctAPE.nominal_source_induced_velocity_sample\nDuctAPE.nominal_source_induced_velocity_sample!\nDuctAPE.subtracted_singular_source_influence\nDuctAPE.subtracted_singular_source_influence!\nDuctAPE.analytically_integrated_source_influence\nDuctAPE.analytically_integrated_source_influence!\nDuctAPE.self_source_induced_velocity_sample\nDuctAPE.self_source_induced_velocity_sample!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.nominal_vortex_induced_velocity_sample","page":"Private API Reference","title":"DuctAPE.nominal_vortex_induced_velocity_sample","text":"nominal_vortex_induced_velocity_sample(\n    t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nCalculate the velocity induced by a linear vortex panel on a point.\n\nArguments\n\nt::Float : sample point in range (0,1) selected by quadrature method.\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncache_vec::Vector{Float} : cache for intermediate calculations\n\nKeyword Arguments\n\nnondimrange::Tuple=(0.0,1.0) : Non-dimensional range describing the panel length.  Do not change excpet for debugging purposes. Note, can also be a vector.\n\nReturns\n\nV::Matrix{Float} : 2x2 matrix of axial and radial induced velocities from each of the nodes.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.nominal_vortex_induced_velocity_sample!","page":"Private API Reference","title":"DuctAPE.nominal_vortex_induced_velocity_sample!","text":"nominal_vortex_induced_velocity_sample!(\n    V, t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nIn-place version of nominal_vortex_induced_velocity_sample.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.subtracted_singular_vortex_influence","page":"Private API Reference","title":"DuctAPE.subtracted_singular_vortex_influence","text":"subtracted_singular_vortex_influence(node, controlpoint)\n\nCalculate the singular portions of the self-induced vortex panel influence to subtract off the integral in the separation of singularity method.\n\nArguments\n\nnode::Vector{Float} : node position\ncontrolpoint::Vector{Float} : controlpoint position\n\nReturns\n\naxial::Float : axial direction influence\nradial::Float : radial direction influence\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.subtracted_singular_vortex_influence!","page":"Private API Reference","title":"DuctAPE.subtracted_singular_vortex_influence!","text":"subtracted_singular_vortex_influence!(node, controlpoint, cache_vec)\n\nSomewhat in-place version of subtracted_singular_vortex_influence.\n\nArguments\n\nnode::Vector{Float} : node position\ncontrolpoint::Vector{Float} : controlpoint position\ncache_vec::Vector{Float} : used to store intermediate values.\n\nReturns\n\naxial::Float : axial direction influence\nradial::Float : radial direction influence\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.analytically_integrated_vortex_influence","page":"Private API Reference","title":"DuctAPE.analytically_integrated_vortex_influence","text":"analytically_integrated_vortex_influence(r, influence_length)\n\nAnalytical approximation of the singular portions of the self-induced vortex panel velocities to be added back in as part of the separation of singularity method.\n\nArguments\n\nr::Float : radial position of self-induced control point\ninfluence_length::Float : dimensional length of the panel\n\nReturns\n\nV::Vector{Float} : axial and radial induced velocities\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.analytically_integrated_vortex_influence!","page":"Private API Reference","title":"DuctAPE.analytically_integrated_vortex_influence!","text":"analytically_integrated_vortex_influence!(V, r, influence_length)\n\nIn-place version of analytically_integrated_vortex_influence.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.self_vortex_induced_velocity_sample","page":"Private API Reference","title":"DuctAPE.self_vortex_induced_velocity_sample","text":"self_vortex_induced_velocity_sample(\n    t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nCalculate the velocity induced by a linear vortex panel on a point at the midpoint between the panel edges.\n\nArguments\n\nt::Float : sample point in range (0,1) selected by quadrature method.\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncache_vec::Vector{Float} : cache for intermediate calculations\n\nKeyword Arguments\n\nnondimrange::Tuple=(0.0,1.0) : Non-dimensional range describing the panel length.  Do not change excpet for debugging purposes. Note, can also be a vector.\n\nReturns\n\nV::Matrix{Float} : 2x2 matrix of axial and radial induced velocities from each of the nodes.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.self_vortex_induced_velocity_sample!","page":"Private API Reference","title":"DuctAPE.self_vortex_induced_velocity_sample!","text":"self_vortex_induced_velocity_sample!(\n    V, t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nIn-place version of self_vortex_induced_velocity_sample.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.nominal_source_induced_velocity_sample","page":"Private API Reference","title":"DuctAPE.nominal_source_induced_velocity_sample","text":"nominal_source_induced_velocity_sample(\n    t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nCalculate the velocity induced by a source panel on a point.\n\nArguments\n\nt::Float : sample point in range (0,1) selected by quadrature method.\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncache_vec::Vector{Float} : cache for intermediate calculations\n\nKeyword Arguments\n\nnondimrange::Tuple=(0.0,1.0) : Non-dimensional range describing the panel length.  Do not change excpet for debugging purposes. Note, can also be a vector.\n\nReturns\n\nV::Matrix{Float} : 2x2 matrix of axial and radial induced velocities from each of the nodes.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.nominal_source_induced_velocity_sample!","page":"Private API Reference","title":"DuctAPE.nominal_source_induced_velocity_sample!","text":"nominal_source_induced_velocity_sample!(\n    V, t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0,1.0)\n)\n\nIn-place version of nominal_source_induced_velocity_sample.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.subtracted_singular_source_influence","page":"Private API Reference","title":"DuctAPE.subtracted_singular_source_influence","text":"subtracted_singular_source_influence(node, controlpoint)\n\nCalculate the singular portions of the self-induced source panel influence to subtract off the integral in the separation of singularity method.\n\nArguments\n\nnode::Vector{Float} : node position\ncontrolpoint::Vector{Float} : controlpoint position\n\nReturns\n\naxial::Float : axial direction influence\nradial::Float : radial direction influence\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.subtracted_singular_source_influence!","page":"Private API Reference","title":"DuctAPE.subtracted_singular_source_influence!","text":"subtracted_singular_source_influence!(node, controlpoint, cache_vec)\n\nIn-place version of subtracted_singular_source_influence.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.analytically_integrated_source_influence","page":"Private API Reference","title":"DuctAPE.analytically_integrated_source_influence","text":"analytically_integrated_source_influence(r, influence_length)\n\nIn-place version of analytically_integrated_source_influence.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.analytically_integrated_source_influence!","page":"Private API Reference","title":"DuctAPE.analytically_integrated_source_influence!","text":"analytically_integrated_source_influence(r, influence_length)\n\nAnalytical approximation of the singular portions of the self-induced source panel velocities to be added back in as part of the separation of singularity method.\n\nArguments\n\nr::Float : radial position of self-induced control point\ninfluence_length::Float : dimensional length of the panel\n\nReturns\n\nV::Vector{Float} : axial and radial induced velocities\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.self_source_induced_velocity_sample","page":"Private API Reference","title":"DuctAPE.self_source_induced_velocity_sample","text":"self_source_induced_velocity_sample(\n    t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nCalculate the velocity induced by a linear source panel on a point at the midpoint between the panel edges.\n\nArguments\n\nt::Float : sample point in range (0,1) selected by quadrature method.\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncache_vec::Vector{Float} : cache for intermediate calculations\n\nKeyword Arguments\n\nnondimrange::Tuple=(0.0,1.0) : Non-dimensional range describing the panel length.  Do not change excpet for debugging purposes. Note, can also be a vector.\n\nReturns\n\nV::Matrix{Float} : 2x2 matrix of axial and radial induced velocities from each of the nodes.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.self_source_induced_velocity_sample!","page":"Private API Reference","title":"DuctAPE.self_source_induced_velocity_sample!","text":"self_source_induced_velocity_sample!(\n    V, t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nIn-place version of self_source_induced_velocity_sample.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Integrals","page":"Private API Reference","title":"Integrals","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.nominal_vortex_panel_integration\nDuctAPE.nominal_vortex_panel_integration!\nDuctAPE.self_vortex_panel_integration\nDuctAPE.self_vortex_panel_integration!\nDuctAPE.nominal_source_panel_integration\nDuctAPE.nominal_source_panel_integration!\nDuctAPE.self_source_panel_integration\nDuctAPE.self_source_panel_integration!\nDuctAPE.extrapolate!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.nominal_vortex_panel_integration","page":"Private API Reference","title":"DuctAPE.nominal_vortex_panel_integration","text":"nominal_vortex_panel_integration(\n    integration_options,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIntegration of vortex panel induced velocity on a point far away.\n\nArguments\n\nintegration_options::IntegrationMethod : options for itegration methods\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncontainers::NamedTuple : cache for intermediate calculations\n\nKeyword Arguments\n\ndebug::Bool=false : if true, some methods will return the estimation error.\n\nReturns\n\nV::Matrix{Float} : velocity components due to the jth and j+1th nodes in the format: [vz_j vr_j; vz_{j+1} vr_{j+1}]\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.nominal_vortex_panel_integration!","page":"Private API Reference","title":"DuctAPE.nominal_vortex_panel_integration!","text":"nominal_vortex_panel_integration!(\n    integration_options,\n    V,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIn-place version of nominal_vortex_panel_integration.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.self_vortex_panel_integration","page":"Private API Reference","title":"DuctAPE.self_vortex_panel_integration","text":"self_vortex_panel_integration(\n    integration_options,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIntegration of linear vortex panel self-induced velocity.\n\nArguments\n\nintegration_options::IntegrationMethod : options for itegration methods\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncontainers::NamedTuple : cache for intermediate calculations\n\nKeyword Arguments\n\ndebug::Bool=false : if true, some methods will return the estimation error.\n\nReturns\n\nV::Matrix{Float} : velocity components due to the jth and j+1th nodes in the format: [vz_j vr_j; vz_{j+1} vr_{j+1}]\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.self_vortex_panel_integration!","page":"Private API Reference","title":"DuctAPE.self_vortex_panel_integration!","text":"self_vortex_panel_integration!(\n    integration_options,\n    V,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIn-place version of self_vortex_panel_integration.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.nominal_source_panel_integration","page":"Private API Reference","title":"DuctAPE.nominal_source_panel_integration","text":"nominal_source_panel_integration(\n    integration_options,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIntegration of source panel induced velocity on a point far away.\n\nArguments\n\nintegration_options::IntegrationMethod : options for itegration methods\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncontainers::NamedTuple : cache for intermediate calculations\n\nKeyword Arguments\n\ndebug::Bool=false : if true, some methods will return the estimation error.\n\nReturns\n\nV::Matrix{Float} : velocity components due to the jth and j+1th nodes in the format: [vz_j vr_j; vz_{j+1} vr_{j+1}]\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.nominal_source_panel_integration!","page":"Private API Reference","title":"DuctAPE.nominal_source_panel_integration!","text":"nominal_source_panel_integration!(\n    integration_options,\n    V,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIn-place version of nominal_source_panel_integration.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.self_source_panel_integration","page":"Private API Reference","title":"DuctAPE.self_source_panel_integration","text":"self_source_panel_integration(\n    integration_options,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIntegration of linear source panel self-induced velocity.\n\nArguments\n\nintegration_options::IntegrationMethod : options for itegration methods\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncontainers::NamedTuple : cache for intermediate calculations\n\nKeyword Arguments\n\ndebug::Bool=false : if true, some methods will return the estimation error.\n\nReturns\n\nV::Matrix{Float} : velocity components due to the jth and j+1th nodes in the format: [vz_j vr_j; vz_{j+1} vr_{j+1}]\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.self_source_panel_integration!","page":"Private API Reference","title":"DuctAPE.self_source_panel_integration!","text":"self_source_panel_integration!(\n    integration_options,\n    V,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIn-place version of self_source_panel_integration.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.extrapolate!","page":"Private API Reference","title":"DuctAPE.extrapolate!","text":"extrapolate!(V, err, fh; power=2, atol=1e-6)\n\nPerforms Richardson extrapolation on an array fh for use in Romberg integration.\n\nArguments\n\nV::Matrix{Float} : velocity components due to the jth and j+1th nodes in the format: [vz_j vr_j; vz_{j+1} vr_{j+1}]\nerr::Vector{Float} : estimated errors in velocity approximation\nfh::Tuple : (f(h), h) tuples (in order of decreasing |h|)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#State-Initialization","page":"Private API Reference","title":"State Initialization","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.initialize_velocities\nDuctAPE.initialize_velocities!\nDuctAPE.initialize_strengths!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.initialize_velocities","page":"Private API Reference","title":"DuctAPE.initialize_velocities","text":"initialize_velocities(\n    solver_options::SolverOptionsType,\n    operating_point,\n    blade_elements,\n    linsys,\n    ivr,\n    ivw,\n    body_totnodes,\n    wake_panel_sheet_be_map,\n)\n\nInitialize velocity state variables.\n\nArguments\n\nsolver_options::SolverOptionsType : solver options type for dispatch\noperating_point::OperatingPoint : an OperatingPoint object\nblade_elements::NamedTuple : A named tuple containing the blade element geometry and airfoil information.\nlinsys::NamedTuple : A named tuple containing the panel method linear system information.\nivr::NamedTuple : A named tuple containing the unit induced velocities on the rotors\nivw::NamedTuple : A named tuple containing the unit induced velocities on the wake\nbody_totnodes::Int : the total number of panel nodes comprising the duct and centerbody geometry\nwake_panel_sheet_be_map::Matrix{Int} : An index map from the wake panels to the nearest ahead rotor blade element along the wake sheets\n\nReturns\n\nvz_rotor::Vector{Float} : a vector of the velocity state variables associated with the rotor axially induced velocity\nvtheta_rotor::Vector{Float} : a vector of the velocity state variables associated with the rotor tangentially induced velocity\nCm_wake::Vector{Float} : a vector of the velocity state variables associated with the wake control point meridional velocity\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.initialize_velocities!","page":"Private API Reference","title":"DuctAPE.initialize_velocities!","text":"function initializevelocities!(     solveroptions::SolverOptionsType,     vzrotor,     vthetarotor,     Cmwake,     operatingpoint,     bladeelements,     linsys,     ivr,     ivw,     bodytotnodes,     wakepanelsheetbemap, )\n\nIn-place version of initialize_velocities.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.initialize_strengths!","page":"Private API Reference","title":"DuctAPE.initialize_strengths!","text":"initialize_strengths!(\n    solver_options::SolverOptionsType,\n    Gamr,\n    sigr,\n    gamw,\n    operating_point,\n    blade_elements,\n    linsys,\n    ivr,\n    ivw,\n    wakeK,\n    body_totnodes,\n    wake_nodemap,\n    wake_endnodeidxs,\n    wake_panel_sheet_be_map,\n    wake_node_sheet_be_map,\n    wake_node_ids_along_casing_wake_interface,\n    wake_node_ids_along_centerbody_wake_interface,\n)\n\nInitialize strength state variables.\n\nArguments\n\nsolver_options::SolverOptionsType : solver options type for dispatch\nGamr::Vector{Float} : Rotor circulation state variables (modified in place)\nsigr::Vector{Float} : Rotor panel strength state variables (modified in place)\ngamw::Vector{Float} : Wake panel strength state variables (modified in place)\noperating_point::OperatingPoint : an OperatingPoint object\nblade_elements::NamedTuple : A named tuple containing the blade element geometry and airfoil information.\nlinsys::NamedTuple : A named tuple containing the panel method linear system information.\nivr::NamedTuple : A named tuple containing the unit induced velocities on the rotors\nivw::NamedTuple : A named tuple containing the unit induced velocities on the wake\nwakeK::Vector{Float} : geometric constants of wake nodes used in calculating wake strengths\nbody_totnodes::Int : the total number of panel nodes comprising the duct and centerbody geometry\nwake_nodemap::Matrix{Int} : an index map of wake panel to the associated node indices\nwake_endnodeidxs::Matrix{Int} : the node indices of the start and end of the wake sheets.\nwake_panel_sheet_be_map::Matrix{Int} : An index map from the wake panels to the nearest ahead rotor blade element along the wake sheets\nwake_node_sheet_be_map::Matrix{Int} : An index map from the wake nodes to the nearest ahead rotor blade element along the wake sheets\nwake_node_ids_along_casing_wake_interface::type : An index map indicating which wake nodes interface with the duct wall\nwake_node_ids_along_centerbody_wake_interface::type : An index map indicating which wake nodes interface with the centerbody wall\n\n\n\n\n\nfunction initialize_strengths!(\n    solver_options::CSORSolverOptions,\n    Gamr,\n    sigr,\n    gamw,\n    solve_containers,\n    operating_point,\n    blade_elements,\n    wakeK,\n    wake_nodemap,\n    wake_endnodeidxs,\n    wake_panel_sheet_be_map,\n    wake_node_sheet_be_map,\n    wake_node_ids_along_casing_wake_interface,\n    wake_node_ids_along_centerbody_wake_interface;\n    niter=10,\n    rlx=0.5,\n)\n\nRefactored from DFDC SUBROUTINE ROTINITBLD\n\nFrom the subroutine notes: Sets reasonable initial circulation using current rotor blade geometry (chord, beta). Initial circulations are set w/o induced effects An iteration is done using the self-induced velocity from momentum theory to converge an approximate induced axial velocity\n\nArguments\n\nsolver_options::SolverOptionsType : solver options type for dispatch\nGamr::Vector{Float} : Rotor circulation state variables (modified in place)\nsigr::Vector{Float} : Rotor panel strength state variables (modified in place)\ngamw::Vector{Float} : Wake panel strength state variables (modified in place)\noperating_point::OperatingPoint : an OperatingPoint object\nblade_elements::NamedTuple : A named tuple containing the blade element geometry and airfoil information.\nwakeK::Vector{Float} : geometric constants of wake nodes used in calculating wake strengths\nwake_nodemap::Matrix{Int} : an index map of wake panel to the associated node indices\nwake_endnodeidxs::Matrix{Int} : the node indices of the start and end of the wake sheets.\nwake_panel_sheet_be_map::Matrix{Int} : An index map from the wake panels to the nearest ahead rotor blade element along the wake sheets\nwake_node_sheet_be_map::Matrix{Int} : An index map from the wake nodes to the nearest ahead rotor blade element along the wake sheets\nwake_node_ids_along_casing_wake_interface::type : An index map indicating which wake nodes interface with the duct wall\nwake_node_ids_along_centerbody_wake_interface::type : An index map indicating which wake nodes interface with the centerbody wall\n\nKeyword Arguments\n\nrlx::Float=0.5 : factor for under-relaxation to reduce transients in CL\n\nReturns\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Analysis","page":"Private API Reference","title":"Analysis","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.analyze_multipoint","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.analyze_multipoint","page":"Private API Reference","title":"DuctAPE.analyze_multipoint","text":"analyze_multipoint(\n    operating_point::OperatingPoint,\n    propulsor::Propulsor,\n    prepost_containers,\n    solve_parameter_cache_vector,\n    solve_parameter_cache_dims,\n    airfoils,\n    A_bb_LU,\n    idmaps,\n    problem_dimensions,\n    options::Options;\n    solve_container_caching=nothing,\n    return_inputs=false,\n)\n\nIdentical to the single analyze function assuming setup_analysis has been called; except here we are running a single operating point for a multipoint analysis, and overwriting the operating point in the propulsor with the explicit operating point input.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Process","page":"Private API Reference","title":"Process","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.process\nDuctAPE.solve","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.process","page":"Private API Reference","title":"DuctAPE.process","text":"process(\n    solver_options::SolverOptionsType,\n    solve_parameter_cache_vector,\n    solve_parameter_cache_dims,\n    airfoils,\n    A_bb_LU,\n    solve_container_caching,\n    idmaps,\n    options,\n)\n\nProcess (the step between pre-process and post-process) the solution, in other words: call the solver(s).\n\nArguments\n\nsolver_options::SolverOptionsType : the solver options contained in the options object, used for dispatch.\nsolve_parameter_cache_vector::Vector{Float} : The vector cache for parameters used in the solve.\nsolve_parameter_cache_dims::NamedTuple : A named tuple containing the dimensions of the solve parameters.\nairfoils::NamedTuple : The airfoils to be interpolated that are associated with each blade element\nA_bb_LU::LinearAlgebra.LU : The LU decomposition of the panel method LHS matrix\nsolve_container_caching::NamedTuple : A named tuple containing the cache and dimensions for the intermediate solve values.\nidmaps::NamedTuple : The set of index maps used in various solve sub-functions\noptions::Options : User options\n\nReturns\n\nconverged_states::Vector{Float} : The output of a call to ImplicitAD.implicit\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.solve","page":"Private API Reference","title":"DuctAPE.solve","text":"solve(sensitivity_parameters, const_cache; initial_guess=nothing)\n\nA compact dispatch of solve that automatically dispatches based on the solveroptions contained in constcache.\n\n\n\n\n\nsolve(\n    solver_options::SolverOptionsType,\n    sensitivity_parameters,\n    const_cache;\n    initial_guess=nothing,\n)\n\nConverge the residual, solving for the state variables that do so.\n\nArguments\n\nsolver_options::SolverOptionsType : SolverOptionsType used for dispatch\nsensitivity_parameters::Vector{Float} : Sensitivity parameters for solve (parameters passed in through ImplicitAD)\nconst_cache::NamedTuple : A named tuple containing constants and caching helpers.\n\nKeyword Arguments\n\ninitial_guess=nothing::Vector{Float} : An optional manually provided initial guess (contained in the sensitivity parameters anyway).\n\nReturns\n\nconverged_states::Vector{Float} : the states for which the residual has converged.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Residuals","page":"Private API Reference","title":"Residuals","text":"","category":"section"},{"location":"DuctAPE/private_api/#CSOR","page":"Private API Reference","title":"CSOR","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.CSOR_residual!\nDuctAPE.compute_CSOR_residual!\nDuctAPE.relax_Gamr!\nDuctAPE.relax_gamw!\nDuctAPE.apply_relaxation_schedule\nDuctAPE.update_CSOR_residual_values!\nDuctAPE.check_CSOR_convergence!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.CSOR_residual!","page":"Private API Reference","title":"DuctAPE.CSOR_residual!","text":"CSOR_residual!(resid, state_variables, sensitivity_parameters, constants)\n\nThe in-place residual used for the CSOR solve method.\n\nArguments\n\nresid::Vector{Float} : In-place residual.\nstate_variables::Vector{Float} : The state variables\nsensitivity_parameters::Vector{Float} : The parameters to which the solution is sensitive.\nconstants::NamedTuple : Various constants required in the solve\n\nReturns\n\nstate_variables::Vector{Float} : The state variables (modified in place)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.compute_CSOR_residual!","page":"Private API Reference","title":"DuctAPE.compute_CSOR_residual!","text":"compute_CSOR_residual!(\n    resid,\n    solver_options,\n    solve_containers,\n    Gamr,\n    sigr,\n    gamw,\n    operating_point,\n    ivr,\n    ivw,\n    linsys,\n    blade_elements,\n    wakeK,\n    idmaps;\n    verbose=false,\n)\n\nDescription\n\nArguments\n\nresid::type :\nsolver_options::type :\nsolve_containers::type :\nGamr::type :\nsigr::type :\ngamw::type :\noperating_point::type :\nivr::type :\nivw::type :\nlinsys::type :\nblade_elements::type :\nwakeK::type :\nidmaps::type :;\n\nKeyword Arguments\n\nverbose::Bool=false : Flag to print verbose statements\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.relax_Gamr!","page":"Private API Reference","title":"DuctAPE.relax_Gamr!","text":"relax_Gamr!(\n    Gamr,\n    delta_prev_mat,\n    delta_mat,\n    maxBGamr,\n    maxdeltaBGamr,\n    B;\n    nrf=0.4,\n    bt1=0.2,\n    bt2=0.6,\n    pf1=0.4,\n    pf2=0.5,\n    test=false,\n)\n\nApply relaxed step to Gamr.\n\nArguments\n\nGamr::Array{Float} : Array of rotor circulations (columns = rotors, rows = blade elements), updated in place\ndelta_prev_mat::Array{Float} : Array of previous iteration's differences in circulation values, updated in place\ndelta_mat::Array{Float} : Array of current iteration's differences in circulation values\nB::Vector{Float} : number of blades on each rotor\nnrf::Float=0.4 : nominal relaxation factor\nbt1::Float=0.2 : backtrack factor 1\nbt2::Float=0.6 : backtrack factor 2\npf1::Float=0.4 : press forward factor 1\npf2::Float=0.5 : press forward factor 2\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.relax_gamw!","page":"Private API Reference","title":"DuctAPE.relax_gamw!","text":"relax_gamw!(\n    gamw, delta_prev, delta, maxdeltagamw; nrf=0.4, btw=0.6, pfw=1.2, test=false\n)\n\nApply relaxed step to gamw.\n\nArguments\n\ngamw::Array{Float} : Array of rotor circulations (columns = rotors, rows = blade elements), updated in place\ndelta_prev_mat::Array{Float} : Array of previous iteration's differences in circulation values, updated in place\ndelta_mat::Array{Float} : Array of current iteration's differences in circulation values\nB::Vector{Float} : number of blades on each rotor\nnrf::Float=0.4 : nominal relaxation factor\nbt1::Float=0.2 : backtrack factor 1\nbt2::Float=0.6 : backtrack factor 2\npf1::Float=0.4 : press forward factor 1\npf2::Float=0.5 : press forward factor 2\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.apply_relaxation_schedule","page":"Private API Reference","title":"DuctAPE.apply_relaxation_schedule","text":"apply_relaxation_schedule(\n    resid::AbstractVector, solver_options::TS\n) where {TS<:SolverOptionsType}\n\nApply custom relaxation schedule to all relaxation factor inputs based on residual values.\n\nArguments\n\nresid::AbstractVector{Float} : current residual values\nsolver_options::SolverOptionsType : SolverOptions containing relaxation schedule\n\nReturns\n\nnrf::Float : nominal relaxation factor\nbt1::Float : backtrack factor 1\nbt2::Float : backtrack factor 2\npf1::Float : press forward factor 1\npf2::Float : press forward factor 2\n\n\n\n\n\napply_relaxation_schedule(resid, nominal, schedule)\n\nApply custom relaxation schedule to a single relaxation factor input.\n\nArguments\n\nresid::Float : residual value\nnominal::Float : nominal relaxation value\nschedule::AbstractVector{AbstractVector{Float}} : values between which to interpolate to scale the nominal relaxation value.\n\nReturns\n\nrf::Float : the updated relaxation factor\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.update_CSOR_residual_values!","page":"Private API Reference","title":"DuctAPE.update_CSOR_residual_values!","text":"update_CSOR_residual_values!(\n    convergence_type::ConvergenceType, resid, maxBGamr, maxdeltaBGamr, maxdeltagamw, Vconv\n)\n\nUpdate CSOR residual values in place.\n\nArguments\n\nconvergence_type::ConvergenceType : used for dispatch of relative or absolute residual values.\nresid::Vector{Float} : residual values modified in place\nmaxBGamr::Float : Maximum value of B*Gamr among all blade elements\nmaxdeltaBGamr::Float : Maximum change in B*Gamr between iterations among all blade elements\nmaxdeltagamw::Vector{Float} : Maximum change in gamw among all wake nodes (one element)\nVconv::Vector{Float} : Reference velocity upon which the relative convergence criteria is based (one element)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.check_CSOR_convergence!","page":"Private API Reference","title":"DuctAPE.check_CSOR_convergence!","text":"check_CSOR_convergence!(\n    conv, resid; f_circ=1e-3, f_dgamw=2e-4, convergence_type=Relative(), verbose=false\n)\n\nDescription\n\nArguments\n\nconv::Vector{Float} : container holding convergence flag\nresid::Vector{Float} : residual vector\n\nKeyword Arguments\n\nf_circ::Float=1e-3 : convergence criteria for circulation residual\nf_dgamw::Float=2e-4 : convergence criteria for wake strength residual\nconvergence_type::ConvergenceType=Relative() : convergence type (absolute or relative) for print statements\nverbose::Bool=false : flag for verbose print statements\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#External-Solvers","page":"Private API Reference","title":"External Solvers","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.system_residual\nDuctAPE.system_residual!\nDuctAPE.update_system_residual!\nDuctAPE.estimate_states!","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.system_residual","page":"Private API Reference","title":"DuctAPE.system_residual","text":"system_residual(state_variables, sensitivity_parameters, constants)\n\nThe residual function for external solvers.\n\nArguments\n\nstate_variables::Vector{Float} : the state variables\nsensitivity_parameters::Vector{Float} : parameters to which the solution derivatives are sensitive\nconstants::NamedTuple : parameters to which the solution derivatives are constant\n\nReturs\n\nresid::Vector{Float} : residual vector\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.system_residual!","page":"Private API Reference","title":"DuctAPE.system_residual!","text":"system_residual!(resid, state_variables, sensitivity_parameters, constants)\n\nIn-place version of system_residual.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.update_system_residual!","page":"Private API Reference","title":"DuctAPE.update_system_residual!","text":"update_system_residual!(\n    solver_options::SolverOptionsType\n    resid,\n    vz_est,\n    vz_rotor,\n    vtheta_est,\n    vtheta_rotor,\n    Cm_est,\n    Cm_wake,\n    solve_parameter_cache_dims,\n)\n\nUpdate the residual for external solvers.\n\nArguments\n\n`solver_options::SolverOptionsType\nresid::Vector{Float} : residual vector\nvz_est::Vector{Float} : axial induced rotor velocity estimate container\nvz_rotor::Vector{Float} : axial induced rotor velocity state container\nvtheta_est::Vector{Float} : tangential induced rotor velocity estimate container\nvtheta_rotor::Vector{Float} : tangential induced rotor velocity state container\nCm_est::Vector{Float} : absolute meridional wake control point velocity estimate container\nCm_wake::Vector{Float} : absolute meridional wake control point velocity state container\nsolve_parameter_cache_dims::Vector{Float} : dimensions of state vectors to use in accessing the residual vector\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.estimate_states!","page":"Private API Reference","title":"DuctAPE.estimate_states!","text":"estimate_states!(\n    solve_containers,\n    vz_rotor,\n    vtheta_rotor,\n    Cm_wake,\n    operating_point,\n    ivr,\n    ivw,\n    linsys,\n    blade_elements,\n    wakeK,\n    idmaps;\n    verbose=false,\n)\n\nEstimate velocity states.\n\nArguments\n\nsolve_containers::NamedTuple : cache for intermediate values in solve\nvz_rotor::Vector{Float} : axial induced rotor velocity state container\nvtheta_rotor::Vector{Float} : tangential induced rotor velocity state container\nCm_wake::Vector{Float} : absolute meridional wake control point velocity state container\noperating_point::NamedTuple : Named tuple containing operating_point information\nivr::NamedTuple : unit induced velocities on rotor(s)\nivw::NamedTuple : unit induced velocities on wake\nlinsys::NamedTuple : vectors and matricies comprising the panel method linear system\nblade_elements::NamedTuple : blade element geometry and airfoil polar information\nwakeK::Vector{Float} : geometric constants used in caculating wake strengths\nidmaps::NamedTuple : index maps used throughout solve\n\nKeyword Arguments\n\nverbose::Bool=false : flag for verbose print statements\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Solve-Utilities","page":"Private API Reference","title":"Solve Utilities","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.extract_initial_guess\nDuctAPE.extract_state_variables","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.extract_initial_guess","page":"Private API Reference","title":"DuctAPE.extract_initial_guess","text":"extract_initial_guess(\n    solver_options::SolverOptionsType, sensitivity_parameters, state_dims\n)\n\nExtract initial guess from the solve parameters cache vector.\n\nArguments\n\nsolver_options::SolverOptionsType : used for dispatch\nsensitivity_parameters::Vector{Float} : vector form of solve parameter cache passed into the solver.\nstate_dims::NamedTuple : dimensions and indices of state variables within the solve parameter cache vector\n\nReturns\n\ninitial_guess::Vector{Float}` : a vector of the solver initial guess\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#DuctAPE.extract_state_variables","page":"Private API Reference","title":"DuctAPE.extract_state_variables","text":"extract_state_variables(solver_options::SolverOptionsType, vars, dims)\n\nReshape the state variables from a single vector, to multiple arrays.\n\nArguments\n\nReturns if solver_options <: CSORSolverOptions\n\nGamr::type : Blade element circulation strengths\nsigr::type : Rotor source panel strengths\ngamw::type : Wake vortex panel strengths\n\nReturns if solver_options <: Union{ExternalSolverOptions, PolyAlgorithmOptions}\n\nvz_rotor::Vector{Float} : axial induced rotor velocity state container\nvtheta_rotor::Vector{Float} : tangential induced rotor velocity state container\nCm_wake::Vector{Float} : absolute meridional wake control point velocity state container\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Post-process","page":"Private API Reference","title":"Post-process","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.post_process","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.post_process","page":"Private API Reference","title":"DuctAPE.post_process","text":"\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/#Utility-Functions","page":"Private API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"DuctAPE.promote_propulosor_type","category":"page"},{"location":"DuctAPE/private_api/#DuctAPE.promote_propulosor_type","page":"Private API Reference","title":"DuctAPE.promote_propulosor_type","text":"promote_propulosor_type(propulsor)\n\nConvenience function for promoting types based on any potential elements of the propulsor object dependent on optimization design variables.\n\nArguments\n\npropulsor::Propulsor : the propulsor input\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/private_api/","page":"Private API Reference","title":"Private API Reference","text":"TODO; add contents of update-propulsor.jl here TODO; add contents of misc.jl","category":"page"},{"location":"#DuctAPE.jl-[[Duct](#)ed-[A](#)xisymmetric-[P](#)ropulsor-[E](#)valuation]","page":"Home","title":"DuctAPE.jl [Ducted Axisymmetric Propulsor Evaluation]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Authors: Judd Mehr,","category":"page"},{"location":"","page":"Home","title":"Home","text":"DuctAPE is a code for the aerodynamic evaluation of axisymmetric ducted propulsors designed for incompressible (low mach) applications. It is strongly influenced by the underlying theory of Ducted Fan Design Code (DFDC), utilizing a linear axisymmetric vortex panel method for duct and center body, blade element lifting line rotor representation, and psuedo wake-screw wake model axisymmetrically smeared onto an elliptic grid for efficient computation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DuctAPE has been developed specifically for applications in gradient-based optimization settings. <! add citations later > The selected solver methods have been chosen to balance code efficiency as well as robustness while simultaneously allowing for efficient automatic differentiation through DuctAPE employing ImplicitAD.jl. At the same time, the basic functionality of a DFDC-like solve approach has been maintained for the interested user.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As DuctAPE is not yet a registered package, if you have access to the development repository at this time you can add the package through Julia's package manager as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add \"https://github.com/byuflowlab/DuctAPE.jl\"","category":"page"},{"location":"DuctAPE/public_api/#Public-API","page":"Public API Reference","title":"Public API","text":"","category":"section"},{"location":"DuctAPE/public_api/","page":"Public API Reference","title":"Public API Reference","text":"Pages = [\"public_api.md\"]\nDepth = 5","category":"page"},{"location":"DuctAPE/public_api/#Input-Types","page":"Public API Reference","title":"Input Types","text":"","category":"section"},{"location":"DuctAPE/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.Propulsor\nDuctAPE.RotorStatorParameters\nDuctAPE.OperatingPoint\nDuctAPE.PanelingConstants\nDuctAPE.ReferenceParameters","category":"page"},{"location":"DuctAPE/public_api/#DuctAPE.Propulsor","page":"Public API Reference","title":"DuctAPE.Propulsor","text":"Propulsor(duct_coordinates, centerbody_coordinates, rotorstator_parameters, operating_point, paneling_constants, reference_parameters)\n\nArguments\n\nduct_coordinates::AbstractMatrix : The [z, r] coordinates of the duct geometry beginning at the inner (casing) side trailing edge and proceeding clockwise. Note that the duct geometry absolute radial position does not need to be included here if the autoshiftduct option is selected.\ncenterbody_coordinates::AbstractMatrix : The [z, r] coordinates of the centerbody beginning at the leading edge and ending at the trailing edge. Note that the leading edge is assumed to be placed at a radial distance of 0.0 from the axis of rotation.\noperating_point::OperatingPoint : The operating point values.\npaneling_constants::PanelingConstants : Constants used in re-paneling the geometry.\nrotorstator_parameters::RotorStatorParameters : Rotor (and possibly stator) geometric paramters.\nreference_parameters::ReferenceParameters : Reference Parameters.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.RotorStatorParameters","page":"Public API Reference","title":"DuctAPE.RotorStatorParameters","text":"RotorStatorParameters(\n    B, rotorzloc, r, Rhub, Rtip, chords, twists, tip_gap, airfoils, fliplift\n)\n\nComposite type containing the rotor(s) geometric properties.\n\nNote that the actual struct requires the inputs to be arrays, but there is a constructor function that will take in scalars and automatically build the array-based struct.\n\nArguments\n\nB::AbstractVector{Float} : The number of blades for each rotor. May not be an integer, but usually is.\nrotorzloc::AbstractVector{Float} : Dimensional, axial position of each rotor.\nr::AbstractArray{Float} : Non-dimensional radial locations of each blade element.\nRhub::AbstractVector{Float} : Dimensional hub radius of rotor. (may be changed if it does not match the radial position of the centerbody geometry at the selected rotorzloc.\nRtip::AbstractVector{Float} : Dimensional tip radius of rotor. Is used to determine the radial position of the duct if the autoshiftduct option is selected.\nchords::AbstractArray{Float} : Dimensional chord lengths of the blade elements.\ntwists::AbstractArray{Float} : Blade element angles, in radians.\ntip_gap::AbstractVector{Float} : Currently unused, do not set to anything other than zeros.\nairfoils::AbstractArray{AFType} : Airfoil types describing the airfoil polars for each blade element. Currently only fully tested with C4Blade.DFDCairfoil types.\nfliplift::AbstractVector{Bool} : flag to indicate if the airfoil lift values should be flipped or not.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.OperatingPoint","page":"Public API Reference","title":"DuctAPE.OperatingPoint","text":"OperatingPoint(Vinf, rhoinf, muinf, asound, Omega)\n\nPropulsor operating point information.\n\nNote that the actual struct requires the inputs to be arrays, but there is a constructor function that will take in scalars and automatically build the array-based struct.\n\nAlso note that even though each field is required to be a vector, only Omega should have more than one entry, and only then if there are more than one rotor.  The purpose behind having vector rather than constant scalar inputs here is for ease of redefinition in an optimization setting when freestream design variables may be present.\n\nArguments\n\nVinf::AbstractVector{Float} : Freestream velocity magnitude (which is only in the axial direction).\nrhoinf::AbstractVector{Float} : Freestream density\nmuinf::AbstractVector{Float} : Freestream viscosity\nasound::AbstractVector{Float} : Freestream speed of sound\nOmega::AbstractVector{Float} : Rotor rototation rate(s)\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.PanelingConstants","page":"Public API Reference","title":"DuctAPE.PanelingConstants","text":"PanelingConstants(\n    nduct_inlet,\n    ncenterbody_inlet,\n    npanels,\n    dte_minus_cbte,\n    nwake_sheets,\n    wake_length=1.0,\n)\n\nConstants used in re-paneling geometry.\n\nNote that unlike other input structures, this one, in general, does not define fields as vectors.  This is because these values should not change throughout an optimization, even if the geometry may change.  Otherwise, discontinuities could be experienced.\n\nArguments\n\nnduct_inlet::Int : The number of panels to use for the duct inlet (this number is used for both the casing and nacelle re-paneling)\nncenterbody_inlet::Int : The number of panels to use for the centerbody inlet.\nnpanels::AbstractVector{Int} : A vector containing the number of panels between discrete locations inside the wake. Specifically, the number of panels between the rotors, between the last rotor and the first body trailing edge, between the body trailing edges (if different), and between the last body trailing edge and the end of the wake.  The length of this vector should be N+1 (where N is the number of rotors) if the duct and centerbody trailing edges are aligned, and N+2 if not.\ndte_minus_cbte::Float : An indicator concerning the hub and duct trailing edge relative locations. Should be set to -1 if the duct trailing edge axial position minus the centerbody trailing edge axial position is negative, +1 if positive (though any positive or negative number will suffice), and zero if the trailing edges are aligned.\nnwake_sheets::Int : The number of wake sheets to use. Note this will also be setting the number of blade elements to use.\nwake_length::Float=1.0 : Non-dimensional (based on the length from the foremost body leading edge and the aftmost body trailing edge) length of the wake extending behind the aftmost body trailing edge.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.ReferenceParameters","page":"Public API Reference","title":"DuctAPE.ReferenceParameters","text":"ReferenceParameters(Vref, Rref)\n\nReference parameters for post-process non-dimensionalization.\n\nNote that the actual struct requires the inputs to be arrays, but there is a constructor function that will take in scalars and automatically build the array-based struct.\n\nArguments\n\nVref::AbstractVector{Float} : Reference velocity.\nRref::AbstractVector{Float} : Reference rotor tip radius.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#Preallocations","page":"Public API Reference","title":"Preallocations","text":"","category":"section"},{"location":"DuctAPE/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.allocate_prepost_container_cache\nDuctAPE.allocate_solve_parameter_cache\nDuctAPE.allocate_solve_container_cache","category":"page"},{"location":"DuctAPE/public_api/#DuctAPE.allocate_prepost_container_cache","page":"Public API Reference","title":"DuctAPE.allocate_prepost_container_cache","text":"allocate_prepost_container_cache(paneling_constants::PanelingConstants)\nallocate_prepost_container_cache(problem_dimensions::ProblemDimensions)\n\nAllocate the pre- and post-processing cache (used for intermediate calculations) based on paneling constants or problem dimensions.\n\nArguments\n\npaneling_constants::PanelingConstants : a PanelingConstants object\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nReturns\n\nprepost_container_caching::NamedTuple : a Named Tuple containing:\nprepost_container_cache::PreallocationTools.DiffCache : the cache\nprepost_container_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/public_api/#DuctAPE.allocate_solve_parameter_cache","page":"Public API Reference","title":"DuctAPE.allocate_solve_parameter_cache","text":"allocate_solve_parameter_cache(\n    solve_type::SolverOptionsType,\n    paneling_constants::PanelingConstants;\n    fd_chunk_size=12,\n    levels=1,\n)\nallocate_solve_parameter_cache(\n    solve_type::SolverOptionsType,\n    problem_dimensions::ProblemDimensions;\n    fd_chunk_size=12,\n    levels=1\n)\n\nAllocate the solve parameter cache for parameters passed into the solver(s).\n\nArguments\n\nsolve_type::SolverOptionsType : Solver options type used for dispatch\npaneling_constants::PanelingConstants : a PanlingConstants object used for sizing\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object used for sizing\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chuck size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nsolve_parameter_caching::NamedTuple : a Named Tuple containing:\nsolve_parameter_cache::PreallocationTools.DiffCache : the cache\nsolve_parameter_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/public_api/#DuctAPE.allocate_solve_container_cache","page":"Public API Reference","title":"DuctAPE.allocate_solve_container_cache","text":"allocate_solve_container_cache(\n    solve_type::SolverOptionsType,\n    paneling_constants::PanelingConstants;\n    fd_chunk_size=12,\n    levels=1,\n)\nallocate_solve_container_cache(\n    solve_type::SolverOptionsType,\n    problem_dimensions::ProblemDimensions;\n    fd_chunk_size=12,\n    levels=1,\n)\n\nAllocate the solve cache (used for intermediate calculations) based on paneling constants or problem dimensions.\n\nArguments\n\npaneling_constants::PanelingConstants : a PanelingConstants object\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chuck size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nsolve_container_caching::NamedTuple : a Named Tuple containing:\nsolve_container_cache::PreallocationTools.DiffCache : the cache\nsolve_container_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/public_api/#Options","page":"Public API Reference","title":"Options","text":"","category":"section"},{"location":"DuctAPE/public_api/#General-Options","page":"Public API Reference","title":"General Options","text":"","category":"section"},{"location":"DuctAPE/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.Options\nDuctAPE.set_options","category":"page"},{"location":"DuctAPE/public_api/#DuctAPE.Options","page":"Public API Reference","title":"DuctAPE.Options","text":"struct Options{\n    TB,\n    TBwo,\n    TF,\n    TI,\n    TSf,\n    TSt,\n    Tin,\n    TIo<:IntegrationOptions,\n    TSo<:SolverOptionsType,\n    WS<:GridSolverOptionsType,\n}\n\nType containing (nearly) all the available user options.\n\nFields\n\nGeneral Options\n\nverbose::TB = false : flag to print verbose statements\nsilence_warnings::TB = true : flag to silence warnings\nmultipoint_index::TI = [1] : holds current index of multi-point solver (no need for user to change this usually)\n\nGeometry Re-interpolation and generation options` :\n\nfinterp::Tin = FLOWMath.akima : interpolation method used for re-paneling bodies\nautoshiftduct::TB = true : flag as to whether duct geometry should be shifted based on rotor tip location\nlu_decomp_flag::TB = false : flag indicating if panel method LHS matrix factorization was successful\n\npaneling options\n\nitcpshift::TF = 0.05 : factor for internal trailing edge psuedo-panel placement (default is DFDC hard-coded value)\naxistol::TF = 1e-15 : tolerance for how close the the axis of rotation should be considered on the axis\ntegaptol::TF = 1e1 * eps() : tolerance for how large of a trailing edge gap should be considered a gap\n\nIntegration Options\n\nintegration_options::TIo = IntegrationOptions() : integration options\n\nPost-processing Options\n\nwrite_outputs::TBwo = [false] : Bool for whether to write the outputs of the analysis to an external file (slow)\noutfile::TSf = [\"outputs.jl\"] : External output file name (including path information) for files to write\ncheckoutfileexists::TB = false : Flag for whether to check if file exists before overwriting\noutput_tuple_name::TSt = [\"outs\"] : variable name for named tuple written to out file\n\nSolving Options\n\ngrid_solver_options::WS = GridSolverOptions() : elliptic grid solver options\nsolver_options::TSo = ChainSolverOptions() : solver options\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.set_options","page":"Public API Reference","title":"DuctAPE.set_options","text":"set_options(; kwargs...)\nset_options(multipoint; kwargs...)\n\nSet the options for DuctAPE to use.\n\nNote that the vast majority of the available options are defined through keyword arguments.  See the documentation for the various option types for more information.\n\nArguments\n\nmultipoint::AbstractVector{OperatingPoint} : a vector of operating points to use if running a multi-point analysis.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/public_api/#Integration-Options","page":"Public API Reference","title":"Integration Options","text":"","category":"section"},{"location":"DuctAPE/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.IntegrationOptions\nDuctAPE.GaussLegendre\nDuctAPE.GaussKronrod\nDuctAPE.Romberg","category":"page"},{"location":"DuctAPE/public_api/#DuctAPE.IntegrationOptions","page":"Public API Reference","title":"DuctAPE.IntegrationOptions","text":"struct IntegrationOptions{TN<:IntegrationMethod,TS<:IntegrationMethod}\n\nA struct used to hold the integration options for both the nominal and singular cases.\n\nFields\n\nnominal::IntegrationMethod=GaussLegendre(8) : the integration options to use for the nominal case.\nsingular::IntegrationMethod=GaussLegendre(8) : the integration options to use for the self-induced case.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.GaussLegendre","page":"Public API Reference","title":"DuctAPE.GaussLegendre","text":"struct GaussLegendre{TN,TW} <: IntegrationMethod\n\nOptions for Gauss-Legendre integration method\n\nFields\n\nsample_points::TN : Sample Points\nweights::TW : Gauss weights\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.GaussKronrod","page":"Public API Reference","title":"DuctAPE.GaussKronrod","text":"struct GaussKronrod{TF,TI} <: IntegrationMethod\n\nOptions for Gauss-Kronrod integration method\n\nFields\n\norder::TI = 7 : order of Legendre polynomial to use on each interval\nmaxevales::TI = 10^7 : maximum number of evaluations in the adaptive method\natol::TF = 0.0 : absolute error tolerance. (note, if zero, QuadGK uses sqrt(eps()) relative tolerance).\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.Romberg","page":"Public API Reference","title":"DuctAPE.Romberg","text":"struct Romberg{TF,TI} <: IntegrationMethod\n\nOptions for Romberg integration method\n\nFields\n\nmax_subdivisions::TI = 10 : maximum number of subdivisions. Note, total number of internvals is 2^N, where N is number of subdivisions.\natol::TF = 1e-6 : absolute error tolerance.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#Solver-Options","page":"Public API Reference","title":"Solver Options","text":"","category":"section"},{"location":"DuctAPE/public_api/#Elliptic-Grid-Solve","page":"Public API Reference","title":"Elliptic Grid Solve","text":"","category":"section"},{"location":"DuctAPE/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.SLORGridSolverOptions\nDuctAPE.GridSolverOptions","category":"page"},{"location":"DuctAPE/public_api/#DuctAPE.SLORGridSolverOptions","page":"Public API Reference","title":"DuctAPE.SLORGridSolverOptions","text":"struct SLORGridSolverOptions{TB,TF,TI} <: GridSolverOptionsType\n\nOptions for SLOR (successive line over relaxation) elliptic grid solver.\n\nFields\n\niteration_limit::TI = 100 : maximum number of iterations\natol::TF = 1e-9 : absolute convergence tolerance\n`converged::AbstractVector{TB} = [false]\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.GridSolverOptions","page":"Public API Reference","title":"DuctAPE.GridSolverOptions","text":"struct GridSolverOptions{TB,TF,TI,TSym} <: GridSolverOptionsType\n\nOptions for Newton elliptic grid solver.\n\nFields\n\niteration_limit::TI = 10 : maximum number of iterations\natol::TF = 1e-14 : absolute convergence tolerance\nalgorithm::TSym = :newton : algorithm to use in NLsolve.jl\nautodiff::TSym = :forward : differentiation method to use in NLsolve.jl\n`converged::AbstractVector{TB} = [false]\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#Aerodynamics-Solve","page":"Public API Reference","title":"Aerodynamics Solve","text":"","category":"section"},{"location":"DuctAPE/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.ChainSolverOptions\nDuctAPE.CompositeSolverOptions\nDuctAPE.NLsolveOptions\nDuctAPE.NonlinearSolveOptions\nDuctAPE.MinpackOptions\nDuctAPE.SIAMFANLEOptions\nDuctAPE.SpeedMappingOptions\nDuctAPE.FixedPointOptions\nDuctAPE.CSORSolverOptions","category":"page"},{"location":"DuctAPE/public_api/#DuctAPE.ChainSolverOptions","page":"Public API Reference","title":"DuctAPE.ChainSolverOptions","text":"struct ChainSolverOptions{TB,TS<:Union{ExternalSolverOptions,PolyAlgorithmOptions}} <:PolyAlgorithmOptions\n\nOptions for Chain Solvers (try one solver, if it doesn't converge, try another)\n\nFields\n\n`solvers::AbstractVector{TS} = [       NLsolveOptions(; algorithm=:anderson, atol=1e-12),       MinpackOptions(; atol=1e-12),       NonlinearSolveOptions(;           algorithm=SimpleNonlinearSolve.SimpleNewtonRaphson,           atol=1e-12,           additional_kwargs=(; autodiff=SimpleNonlinearSolve.AutoForwardDiff()),       ),   ] : Vector of solver options to use.\nconverged::AbstractVector{TB} = [false] : flag to track if convergence took place.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.CompositeSolverOptions","page":"Public API Reference","title":"DuctAPE.CompositeSolverOptions","text":"struct CompositeSolverOptions{\n    TB,TS<:Union{ExternalSolverOptions,PolyAlgorithmOptions}\n} <: PolyAlgorithmOptions\n\nOptions for Composite Solvers (start with a partial solve of one solve, then finish with another starting where the first left off).\n\nFields\n\n`solvers::AbstractVector{TS} = [       NLsolveOptions(; algorithm=:newton, iteration_limit=3),       NLsolveOptions(; algorithm=:anderson, atol=1e-12),   ]' : Vector of solver options to use.\nconverged::AbstractVector{TB} = [false] : flag to track if convergence took place.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.NLsolveOptions","page":"Public API Reference","title":"DuctAPE.NLsolveOptions","text":"struct NLsolveOptions{TB,TF,TK,Tls,Tlsk,TSym} <: ExternalSolverOptions\n\nOptions for the NLsolve pacakge solvers\n\nFields\n\nalgorithm::TSym = :anderson : algorithm to use\nadditional_kwargs::TK = (;) : any additional keyword arguments for the solver\natol::TF = 1e-12 : absolute convergence tolerance\niteration_limit::TF = 25 : maximum number of iterations\nlinesearch_method::Tls = LineSearches.MoreThuente : line search method to use\nlinesearch_kwargs::Tlsk = (;) : any additional lineseach keyword arguments\nconverged::AbstractVector{TB} = [false] : flag to track if convergence took place.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.NonlinearSolveOptions","page":"Public API Reference","title":"DuctAPE.NonlinearSolveOptions","text":"struct NonlinearSolveOptions{TA,TB,TF,TI,TT} <: ExternalSolverOptions\n\nOptions for the SimpleNonlinearSolve pacakge solvers\n\nFields\n\nalgorithm::TA = SimpleNonlinearSolve.SimpleNewtonRaphson : algorithm to use\nadditional_kwargs::TK = (;) : any additional keyword arguments for the solver\natol::TF = 1e-12 : absolute convergence tolerance\niteration_limit::TF = 25 : maximum number of iterations\nconverged::AbstractVector{TB} = [false] : flag to track if convergence took place.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.MinpackOptions","page":"Public API Reference","title":"DuctAPE.MinpackOptions","text":"struct MinpackOptions{TB,TF,TI,TSym} <: ExternalSolverOptions\n\nOptions for the MINPACK's HYBRJ solver\n\nFields\n\nalgorithm::TSym = :hybr : algorithm to use in MINPACK.jl (hybr is HYBRJ when the jacobian is provided)\natol::TF = 1e-12 : absolute convergence tolerance\niteration_limit::TF = 100 : maximum number of iterations\nconverged::AbstractVector{TB} = [false] : flag to track if convergence took place.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.SIAMFANLEOptions","page":"Public API Reference","title":"DuctAPE.SIAMFANLEOptions","text":"struct SIAMFANLEOptions{TA,TB,TF,TI,TK} <: ExternalSolverOptions\n\nOptions for the SIAMFANLEquations pacakge solvers\n\nFields\n\nalgorithm::TA = SIAMFANLEquations.nsoli : algorithm to use\nrtol::TF = 0.0 : relative convergence tolerance\natol::TF = 1e-10 : absolute convergence tolerance\niteration_limit::TF = 1000 : maximum number of iterations\nlinear_iteration_limit::TF = 5 : maximum number of linear solve iterations (GMRES)\nadditional_kwargs::TK = (;) : any additional keyword arguments for the solver\nconverged::AbstractVector{TB} = [false] : flag to track if convergence took place.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.SpeedMappingOptions","page":"Public API Reference","title":"DuctAPE.SpeedMappingOptions","text":"struct SpeedMappingOptions{TB,TF,TI,TL,TSm,TU} <: ExternalSolverOptions\n\nOptions for the SpeedMapping.jl package solver\n\nFields\n\n`orders::AbstractVector{TI} = [3, 2]\nsig_min::TSm = 0 : maybe set to 1?\nstabilize::TB = false : stabilizes before extrapolation\ncheck_obj::TB = false : checks for inf's and nan's and starts from previous finite point\natol::TF = 1e-10 : absolute convergence tolerance\niteration_limit::TF = 1000 : maximum number of iterations\ntime_limit::TF = Inf : time limit in seconds\nlower::TL = nothing : box lower bounds\nupper::TU = nothing : box upper bounds\nbuffer::TF = 0.01 : if using bounds, buffer brings x inside bounds by buffer amountd\nLp::TF = Inf : p value for p-norm for convergence criteria\nconverged::AbstractVector{TB} = [false] : flag to track if convergence took place.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.FixedPointOptions","page":"Public API Reference","title":"DuctAPE.FixedPointOptions","text":"struct FixedPointOptions{TB,TF,TI} <: ExternalSolverOptions\n\nOptions for the FixedPoint.jl package solver\n\nFields\n\niteration_limit::TF = 1000 : maximum number of iterations\nvel::TF = 0.9 : vel keyword argument, default is package default\nep::TF = 0.01 : ep keyword argument, default is package default\natol::TF = 1e-12 : absolute convergence tolerance\nconverged::AbstractVector{TB} = [false] : flag to track if convergence took place.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#DuctAPE.CSORSolverOptions","page":"Public API Reference","title":"DuctAPE.CSORSolverOptions","text":"struct CSORSolverOptions{TB,TC<:ConvergenceType,TF,TS} <: SolverOptionsType\n\nType containing all the options for the CSOR (controlled successive over relaxation) solver.\n\nNote that the defaults match DFDC with the exception of the relaxation schedule, which is an experimental feature.\n\nFields\n\nvar::type :\nverbose::TB = false : flag to print verbose statements\niteration_limit::TF = 1e2 : maximum number of iterations\nnrf::TF = 0.4 : nominal relaxation factor\nbt1::TF = 0.2 : backtracking factor 1\nbt2::TF = 0.6 : backtracking factor 2\npf1::TF = 0.4 : press forward factor 1\npf2::TF = 0.5 : press forward factor 2\nbtw::TF = 0.6 : backtracking factor for wake\npfw::TF = 1.2 : press forward factor for wake\nrelaxation_schedule::TS = [[0.0;1e-14;1e-13;1e10]), [1.0;1.0;0.0;0.0])] : values used in spline definition for scaling the relaxation factors (second vector) after various convergence values (first vector).\nf_circ::TF = 1e-3 : convergence tolerance for rotor circulation\nf_dgamw::TF = 2e-4 : convergence tolerance for wake vortex strength\nconvergence_type::TC = Relative() : dispatch for relative or absolute convergence criteria.\nVconv::TF = 1.0 : velocity used in relative convergence criteria (should be set to Vref).\nconverged::AbstractVector{TB} = [false] : flag to track if convergence took place.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/public_api/#Preprocess","page":"Public API Reference","title":"Preprocess","text":"","category":"section"},{"location":"DuctAPE/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.setup_analysis","category":"page"},{"location":"DuctAPE/public_api/#DuctAPE.setup_analysis","page":"Public API Reference","title":"DuctAPE.setup_analysis","text":"setup_analysis(\n    propulsor::Propulsor,\n    options::Options=set_options();\n    prepost_container_caching=nothing,\n    solve_parameter_caching=nothing,\n    solve_container_caching=nothing,\n)\n\nPerform pre-processing and cache setup (as needed) for propuslor analysis.\n\nArguments\n\npropulsor::Propulsor : Propulsor input object (see docstring for Propulsor type)\noptions::Options=set_options() : Options object (see set_options and related functions)\n\nKeyword Arguments\n\nprepost_container_caching=nothing : Output of allocate_prepost_container_cache\nsolve_parameter_caching=nothing : Output of allocate_solve_parameter_container_cache\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\n\nReturns\n\nproblem_dimensions::NamedTuple : Named Tuple contiaining bookkeeping information (problem dimensions)\nprepost_containers::NamedTuple : Named Tuple containing reshaped views into the prepost cache\nsolve_parameter_cache_vector::Vector : Vector containing the relevant typed cache vector of solve parameters\nsolve_parameter_cache_dims::NamedTuple : Named Tuple containing dimensions used for reshaping the solve parameter cache\nA_bb_LU::LinearAlgebra.LU : The LU factorization of the AIC matrix used in the panel method\nlu_decomp_flag::Bool : flag indicating if the LU decomposition was successful\nairfoils::Matrix{AFType} : Matrix contiaining the blade element airfoil polar objects\nidmaps::NamedTuple : Named Tuple containing bookkeeping information (index mappings)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/public_api/#Analysis","page":"Public API Reference","title":"Analysis","text":"","category":"section"},{"location":"DuctAPE/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.analyze","category":"page"},{"location":"DuctAPE/public_api/#DuctAPE.analyze","page":"Public API Reference","title":"DuctAPE.analyze","text":"analyze(\n    propulsor::Propulsor,\n    options::Options=set_options();\n    prepost_container_caching=nothing,\n    solve_parameter_caching=nothing,\n    solve_container_caching=nothing,\n    return_inputs=false,\n)\n\nAnalyze propulsor, including preprocessing.\n\nArguments\n\npropulsor::Propulsor : Propulsor input object (see docstring for Propulsor type)\noptions::Options=set_options() : Options object (see set_options and related functions)\n\nKeyword Arguments\n\nprepost_container_caching=nothing : Output of allocate_prepost_container_cache\nsolve_parameter_caching=nothing : Output of allocate_solve_parameter_container_cache\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::NamedTuple : Named Tuple of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\nanalyze(\n    propulsor::Propulsor,\n    prepost_containers,\n    solve_parameter_cache_vector,\n    solve_parameter_cache_dims,\n    airfoils,\n    A_bb_LU,\n    idmaps,\n    problem_dimensions,\n    options::Options=set_options();\n    return_inputs=false,\n    solve_container_caching=nothing,\n)\n\nAnalyze propulsor, assuming setup_analysis has been called and the outputs thereof are being passed in here.\n\nArguments\n\npropulsor::Propulsor : Propulsor input object\nprepost_containers::NamedTuple : An output from setup_analysis containing reshaped views into the prepost cache\nsolve_parameter_cache_vector::Vector : An output from setup_analysis containing the relevant typed cache vector of solve parameters\nsolve_parameter_cache_dims::NamedTuple : An output from setup_analysis containing dimensions used for reshaping the solve parameter cache\nairfoils::Vector{AFType} : An output from setup_analysis contiaining the blade element airfoil polar objects\nA_bb_LU::LinearAlgebra.LU : An output from setup_analysis that is the LU decomposition of the AIC matrix used in the panel method\nidmaps::NamedTuple : An output from setup_analysis containing bookkeeping information (index mappings)\nproblem_dimensions::NamedTuple : An output from setup_analysis contiaining bookkeeping information (problem dimensions)\noptions::Options=set_options() : Options object\n\nKeyword Arguments\n\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::NamedTuple : Named Tuple of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\nanalyze(\n    multipoint::AbstractVector{OperatingPoint},\n    propulsor::Propulsor,\n    options::Options=set_options();\n    prepost_container_caching=nothing,\n    solve_parameter_caching=nothing,\n    solve_container_caching=nothing,\n    return_inputs=false,\n)\n\nAnalyze propulsor, including preprocessing, for a set of operating points.\n\nArguments\n\nmultipoint::AbstractVector{OperatingPoint} : Vector of Operating Points at which to analyze the propulsor (note that the operating point within the propulsor input will be overwritten with these)\npropulsor::Propulsor : Propulsor input object\noptions::Options=set_options() : Options object\n\nKeyword Arguments\n\nprepost_container_caching=nothing : Output of allocate_prepost_container_cache\nsolve_parameter_caching=nothing : Output of allocate_solve_parameter_container_cache\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::Vector{NamedTuple} : Vector of named tuples of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\nanalyze(\n    multipoint::Vector{OperatingPoint},\n    propulsor::Propulsor,\n    prepost_containers,\n    solve_parameter_cache_vector,\n    solve_parameter_cache_dims,\n    airfoils,\n    A_bb_LU,\n    idmaps,\n    problem_dimensions,\n    options::Options=set_options();\n    return_inputs=false,\n    solve_container_caching=nothing,\n)\n\nAnalyze propulsor, assuming setup_analysis has been called and the inputs are being passed in here.\n\nArguments\n\nmultipoint::AbstractVector{OperatingPoint} : Vector of Operating Points at which to analyze the propulsor (note that the operating point within the propulsor input will be overwritten with these)\npropulsor::Propulsor : Propulsor input object\nprepost_containers::NamedTuple : An output from setup_analysis containing reshaped views into the prepost cache\nsolve_parameter_cache_vector::Vector : An output from setup_analysis containing the relevant typed cache vector of solve parameters\nsolve_parameter_cache_dims::NamedTuple : An output from setup_analysis containing dimensions used for reshaping the solve parameter cache\nairfoils::Vector{AFType} : An output from setup_analysis contiaining the blade element airfoil polar objects\nA_bb_LU::LinearAlgebra.LU : An output from setup_analysis that is the LU decomposition of the AIC matrix used in the panel method\nidmaps::NamedTuple : An output from setup_analysis containing bookkeeping information (index mappings)\nproblem_dimensions::NamedTuple : An output from setup_analysis contiaining bookkeeping information (problem dimensions)\noptions::Options=set_options() : Options object\n\nKeyword Arguments\n\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::Vector{NamedTuple} : Named Tuple of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true.  Note that some inputs will be overwritten (e.g. the linear system RHS components related to the freestream) and only those associated with the final operating point will be returned.\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/public_api/#Miscellaneous","page":"Public API Reference","title":"Miscellaneous","text":"","category":"section"},{"location":"DuctAPE/public_api/#Airfoil/Geometry-Manipulation","page":"Public API Reference","title":"Airfoil/Geometry Manipulation","text":"","category":"section"},{"location":"DuctAPE/public_api/#NACA-6-Series-Cascade-Geometry-Generation","page":"Public API Reference","title":"NACA 6-Series Cascade Geometry Generation","text":"","category":"section"},{"location":"DuctAPE/tutorial/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"Pages = [\"tutorial.md\"]\nDepth = 5","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"The following is a basic tutorial on how to set up the inputs to, and run, an analysis of a ducted fan in DuctAPE.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"include(\"../../assets/plots_default.jl\")","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"We begin by loading the package, and optionally create a shorthand name.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"using DuctAPE\nconst dt = DuctAPE\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/#Build-Inputs","page":"Getting Started","title":"Build Inputs","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"The next step is to create the input object of type Propulsor.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.Propulsor","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.Propulsor-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.Propulsor","text":"Propulsor(duct_coordinates, centerbody_coordinates, rotorstator_parameters, operating_point, paneling_constants, reference_parameters)\n\nArguments\n\nduct_coordinates::AbstractMatrix : The [z, r] coordinates of the duct geometry beginning at the inner (casing) side trailing edge and proceeding clockwise. Note that the duct geometry absolute radial position does not need to be included here if the autoshiftduct option is selected.\ncenterbody_coordinates::AbstractMatrix : The [z, r] coordinates of the centerbody beginning at the leading edge and ending at the trailing edge. Note that the leading edge is assumed to be placed at a radial distance of 0.0 from the axis of rotation.\noperating_point::OperatingPoint : The operating point values.\npaneling_constants::PanelingConstants : Constants used in re-paneling the geometry.\nrotorstator_parameters::RotorStatorParameters : Rotor (and possibly stator) geometric paramters.\nreference_parameters::ReferenceParameters : Reference Parameters.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/tutorial/#Body-Geometry","page":"Getting Started","title":"Body Geometry","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"We begin by defining a matrix of coordinates for the duct and another for the centerbody geometries, for example:","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"duct_coordinates = [\n    0.304466  0.158439\n    0.294972  0.158441\n    0.28113   0.158423\n    0.266505  0.158365\n    0.251898  0.158254\n    0.237332  0.158088\n    0.222751  0.157864\n    0.208123  0.157586\n    0.193399  0.157258\n    0.178507  0.156897\n    0.16349   0.156523\n    0.148679  0.156177\n    0.134222  0.155902\n    0.12      0.155721\n    0.106044  0.155585\n    0.092531  0.155498\n    0.079836  0.155546\n    0.067995  0.155792\n    0.057025  0.156294\n    0.046983  0.157103\n    0.037937  0.158256\n    0.029956  0.159771\n    0.02311   0.161648\n    0.017419  0.163862\n    0.012842  0.166404\n    0.009324  0.169289\n    0.006854  0.172546\n    0.005484  0.176154\n    0.005242  0.180005\n    0.006112  0.184067\n    0.00809   0.188086\n    0.011135  0.192004\n    0.015227  0.19579\n    0.020339  0.199393\n    0.026403  0.202735\n    0.033312  0.205736\n    0.040949  0.208332\n    0.049193  0.210487\n    0.057935  0.212174\n    0.067113  0.21339\n    0.076647  0.214136\n    0.086499  0.214421\n    0.09661   0.214255\n    0.10695   0.213649\n    0.117508  0.212618\n    0.12838   0.211153\n    0.139859  0.209267\n    0.151644  0.207051\n    0.163586  0.204547\n    0.175647  0.201771\n    0.187807  0.198746\n    0.20002   0.19549\n    0.212269  0.192017\n    0.224549  0.188335\n    0.236794  0.18447\n    0.249026  0.180416\n    0.261206  0.176188\n    0.273301  0.171796\n    0.28524   0.16727\n    0.29644   0.162842\n    0.304542  0.159526\n]\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"centerbody_coordinates = [\n    0.0       0.0\n    0.000586  0.005293\n    0.002179  0.010047\n    0.004736  0.014551\n    0.008231  0.018825\n    0.012632  0.022848\n    0.01788   0.026585\n    0.023901  0.030001\n    0.030604  0.033068\n    0.0379    0.035771\n    0.045705  0.038107\n    0.053933  0.040075\n    0.06254   0.04169\n    0.071451  0.042966\n    0.08063   0.043916\n    0.090039  0.044561\n    0.09968   0.044922\n    0.109361  0.044999\n    0.12      0.044952\n    0.135773  0.04495\n    0.151899  0.04493\n    0.16806   0.044913\n    0.184232  0.044898\n    0.200407  0.044882\n    0.21658   0.044866\n    0.232723  0.044847\n    0.248578  0.044839\n    0.262095  0.044564\n    0.274184  0.043576\n    0.285768  0.041795\n    0.296701  0.039168\n    0.306379  0.035928\n]\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"pg = plot(duct_coordinates[:,1], duct_coordinates[:,2], aspectratio=1, color=1, linewidth=2, label=\"Duct\", xlabel=\"z\", ylabel=\"r\", legend=:left) # hide\nplot!(pg, centerbody_coordinates[:,1], centerbody_coordinates[:,2], color=2, linewidth=2, label=\"Center Body\") # hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"note: Note\nThe body geometry coordinates must be input as columns of z (axial) and r (radial) coordinates, in that order.","category":"page"},{"location":"DuctAPE/tutorial/#Rotor-Geometry","page":"Getting Started","title":"Rotor Geometry","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"The next step is to assemble an object of type RotorStatorParameters which contains the geometric information required to define the rotor(s) and their respective blade elements.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.RotorStatorParameters","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.RotorStatorParameters-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.RotorStatorParameters","text":"RotorStatorParameters(\n    B, rotorzloc, r, Rhub, Rtip, chords, twists, tip_gap, airfoils, fliplift\n)\n\nComposite type containing the rotor(s) geometric properties.\n\nNote that the actual struct requires the inputs to be arrays, but there is a constructor function that will take in scalars and automatically build the array-based struct.\n\nArguments\n\nB::AbstractVector{Float} : The number of blades for each rotor. May not be an integer, but usually is.\nrotorzloc::AbstractVector{Float} : Dimensional, axial position of each rotor.\nr::AbstractArray{Float} : Non-dimensional radial locations of each blade element.\nRhub::AbstractVector{Float} : Dimensional hub radius of rotor. (may be changed if it does not match the radial position of the centerbody geometry at the selected rotorzloc.\nRtip::AbstractVector{Float} : Dimensional tip radius of rotor. Is used to determine the radial position of the duct if the autoshiftduct option is selected.\nchords::AbstractArray{Float} : Dimensional chord lengths of the blade elements.\ntwists::AbstractArray{Float} : Blade element angles, in radians.\ntip_gap::AbstractVector{Float} : Currently unused, do not set to anything other than zeros.\nairfoils::AbstractArray{AFType} : Airfoil types describing the airfoil polars for each blade element. Currently only fully tested with C4Blade.DFDCairfoil types.\nfliplift::AbstractVector{Bool} : flag to indicate if the airfoil lift values should be flipped or not.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"In this example, we have a single rotor defined as follows.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"B = 5\n\nrotorzloc = 0.12\n\nRtip = 0.15572081487373543\n\nRhub = 0.04495252299071941\n\nr = [\n    0.050491\n    0.061567\n    0.072644\n    0.083721\n    0.094798\n    0.10587\n    0.11695\n    0.12803\n    0.13911\n    0.15018\n]./Rtip\n\nchords = [\n    0.089142\n    0.079785\n    0.0713\n    0.063979\n    0.057777\n    0.052541\n    0.048103\n    0.044316\n    0.041061\n    0.038243\n]\n\ntwists = [\n    69.012\n    59.142\n    51.825\n    46.272\n    41.952\n    38.509\n    35.699\n    33.354\n    31.349\n    29.596\n].*pi/180.0\n\n\nafparams = DuctAPE.c4b.DFDCairfoil(;\n    alpha0=0.0,\n    clmax=1.5,\n    clmin=-1.0,\n    dclda=6.28,\n    dclda_stall=0.5,\n    dcl_stall=0.2,\n    cdmin=0.012,\n    clcdmin=0.1,\n    dcddcl2=0.005,\n    cmcon=0.0,\n    Re_ref=2e5,\n    Re_exp=0.35,\n    mcrit=0.7,\n)\n\nairfoils = fill(afparams, length(r)) # specify the airfoil array\n\nrotorstator_parameters = dt.RotorStatorParameters(\n    [B],\n    [rotorzloc],\n    r,\n    [Rhub],\n    [Rtip],\n    chords,\n    twists,\n    [0.0], # currently only zero tip gaps work.\n    airfoils,\n    [0.0], # can flip the cl lookups on the fly if desired, say, for stator sections\n)\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"plot!(pg, rotorzloc*ones(length(r)), r.*Rtip, seriestype=:scatter, markerstrokewidth=0, label=\"Blade Elements\") # hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"note: Airfoils\nAirfoil types for DuctAPE are currently contained in the C4Blade (Cascade Compatible CCBlade) sub-module of DuctAPE which is exported as c4b and also contains the various airfoil evaluation functions used for the blade element lookups. The available airfoil types include all the airfoil types from CCBlade, as well as DFDCairfoil which is an XROTOR-like parametric cascade polar used in DFDC. In addition there are untested cascade types with similar structure to CCBlades airfoil types called DTCascade. Furthermore, there is an experimental actuator disk model implemented via the ADM airfoil type in C4Blade.","category":"page"},{"location":"DuctAPE/tutorial/#Operating-Point","page":"Getting Started","title":"Operating Point","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"Next we will assemble the operating point which contains information about the freestream as well as the rotor rotation rate(s).","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.OperatingPoint","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.OperatingPoint-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.OperatingPoint","text":"OperatingPoint(Vinf, rhoinf, muinf, asound, Omega)\n\nPropulsor operating point information.\n\nNote that the actual struct requires the inputs to be arrays, but there is a constructor function that will take in scalars and automatically build the array-based struct.\n\nAlso note that even though each field is required to be a vector, only Omega should have more than one entry, and only then if there are more than one rotor.  The purpose behind having vector rather than constant scalar inputs here is for ease of redefinition in an optimization setting when freestream design variables may be present.\n\nArguments\n\nVinf::AbstractVector{Float} : Freestream velocity magnitude (which is only in the axial direction).\nrhoinf::AbstractVector{Float} : Freestream density\nmuinf::AbstractVector{Float} : Freestream viscosity\nasound::AbstractVector{Float} : Freestream speed of sound\nOmega::AbstractVector{Float} : Rotor rototation rate(s)\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# Freestream\nVinf = 0.0 # hover condition\nrhoinf = 1.226\nasound = 340.0\nmuinf = 1.78e-5\n\n# Rotation Rate\nRPM = 8000.0\nOmega = RPM * pi / 30 # if using RPM, be sure to convert to rad/s\n\n# utilizing the constructor function to put things in vector types\noperating_point = dt.OperatingPoint(Vinf, rhoinf, muinf, asound, Omega)\n\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/#Paneling-Constants","page":"Getting Started","title":"Paneling Constants","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"The PanelingConstants object contains the constants required for DuctAPE to re-panel the provided geometry into a format compatible with the solve structure. The PanelingConstants object is also used to build all of the preallocated caches inside DuctAPE, which can be done up-front if desired. Note that there is some functionality in place for cases when the user wants to keep their own specified geometry, but this functionality should be used with caution and only by users who are certain their provided geometry is in the compatible format.  See the Examples for an example.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.PanelingConstants","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.PanelingConstants-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.PanelingConstants","text":"PanelingConstants(\n    nduct_inlet,\n    ncenterbody_inlet,\n    npanels,\n    dte_minus_cbte,\n    nwake_sheets,\n    wake_length=1.0,\n)\n\nConstants used in re-paneling geometry.\n\nNote that unlike other input structures, this one, in general, does not define fields as vectors.  This is because these values should not change throughout an optimization, even if the geometry may change.  Otherwise, discontinuities could be experienced.\n\nArguments\n\nnduct_inlet::Int : The number of panels to use for the duct inlet (this number is used for both the casing and nacelle re-paneling)\nncenterbody_inlet::Int : The number of panels to use for the centerbody inlet.\nnpanels::AbstractVector{Int} : A vector containing the number of panels between discrete locations inside the wake. Specifically, the number of panels between the rotors, between the last rotor and the first body trailing edge, between the body trailing edges (if different), and between the last body trailing edge and the end of the wake.  The length of this vector should be N+1 (where N is the number of rotors) if the duct and centerbody trailing edges are aligned, and N+2 if not.\ndte_minus_cbte::Float : An indicator concerning the hub and duct trailing edge relative locations. Should be set to -1 if the duct trailing edge axial position minus the centerbody trailing edge axial position is negative, +1 if positive (though any positive or negative number will suffice), and zero if the trailing edges are aligned.\nnwake_sheets::Int : The number of wake sheets to use. Note this will also be setting the number of blade elements to use.\nwake_length::Float=1.0 : Non-dimensional (based on the length from the foremost body leading edge and the aftmost body trailing edge) length of the wake extending behind the aftmost body trailing edge.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"nduct_inlet = 30\nncenterbody_inlet = 30\nnpanels = [30, 1, 30] # the 1 is due to the fact that the duct and center body trailing edges are not quite aligned.\ndte_minus_cbte = -1.0 # the duct trailing edge is ahead of the centerbody trailing edge.\nnwake_sheets = 11\nwake_length = 0.8\n\npaneling_constants = dt.PanelingConstants(\n    nduct_inlet, ncenterbody_inlet, npanels, dte_minus_cbte, nwake_sheets, wake_length\n)\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/#Reference-Parameters","page":"Getting Started","title":"Reference Parameters","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"The reference parameters are used in the post-processing non-dimensionalizations.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.ReferenceParameters","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.ReferenceParameters-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.ReferenceParameters","text":"ReferenceParameters(Vref, Rref)\n\nReference parameters for post-process non-dimensionalization.\n\nNote that the actual struct requires the inputs to be arrays, but there is a constructor function that will take in scalars and automatically build the array-based struct.\n\nArguments\n\nVref::AbstractVector{Float} : Reference velocity.\nRref::AbstractVector{Float} : Reference rotor tip radius.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"Vref = 50.0 #this turns out to be close to the average axial velocity at the rotor in our case\nRref = Rtip\n\nreference_parameters = dt.ReferenceParameters([Vref], [Rref])\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/#All-Together","page":"Getting Started","title":"All Together","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"We are now posed to construct the Propulsor input type.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"propulsor = dt.Propulsor(\n    duct_coordinates,\n    centerbody_coordinates,\n    rotorstator_parameters,\n    operating_point,\n    paneling_constants,\n    reference_parameters,\n)\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/#Set-Options","page":"Getting Started","title":"Set Options","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"The default options should be sufficient for just starting out and are set through the set_options function.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.set_options","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.set_options-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.set_options","text":"set_options(; kwargs...)\nset_options(multipoint; kwargs...)\n\nSet the options for DuctAPE to use.\n\nNote that the vast majority of the available options are defined through keyword arguments.  See the documentation for the various option types for more information.\n\nArguments\n\nmultipoint::AbstractVector{OperatingPoint} : a vector of operating points to use if running a multi-point analysis.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"options = dt.set_options()","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"For more advanced option selection, see the examples and API reference.","category":"page"},{"location":"DuctAPE/tutorial/#Run-Analysis","page":"Getting Started","title":"Run Analysis","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"With the propulsor input build, and the options selected, we are now ready to run an analysis. This is done simply with the analyze function which dispatches the appropriate analysis, solve, and post-processing functions based on the selected options.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.analyze(::DuctAPE.Propulsor, ::DuctAPE.Options)","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.analyze-Tuple{Propulsor, Options}-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.analyze","text":"analyze(\n    propulsor::Propulsor,\n    options::Options=set_options();\n    prepost_container_caching=nothing,\n    solve_parameter_caching=nothing,\n    solve_container_caching=nothing,\n    return_inputs=false,\n)\n\nAnalyze propulsor, including preprocessing.\n\nArguments\n\npropulsor::Propulsor : Propulsor input object (see docstring for Propulsor type)\noptions::Options=set_options() : Options object (see set_options and related functions)\n\nKeyword Arguments\n\nprepost_container_caching=nothing : Output of allocate_prepost_container_cache\nsolve_parameter_caching=nothing : Output of allocate_solve_parameter_container_cache\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::NamedTuple : Named Tuple of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\n","category":"method"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"outs, success_flag = dt.analyze(propulsor, options)\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/#Outputs","page":"Getting Started","title":"Outputs","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"There are many outputs contained in the named tuple output from the analyze function (see the post_process() docstring), but some that may be of immediate interest include:","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# Total Thrust Coefficient\nouts.totals.CT","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# Total Torque Coefficient\nouts.totals.CQ","category":"page"}]
}
