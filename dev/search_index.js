var documenterSearchIndex = {"docs":
[{"location":"DuctAPE/advanced_usage/outputs/","page":"Outputs","title":"Outputs","text":"The output tuple contains many items. The post_process function docstring lists them. The purpose of showing this function here is not for you to manually run the fuction or apply any advanced usage, but simply rather for you to see what the available outputs are, as several of them may apply to advanced usage cases.","category":"page"},{"location":"DuctAPE/advanced_usage/outputs/","page":"Outputs","title":"Outputs","text":"DuctAPE.post_process","category":"page"},{"location":"DuctAPE/advanced_usage/outputs/#DuctAPE.post_process-DuctAPE-advanced_usage-outputs","page":"Outputs","title":"DuctAPE.post_process","text":"post_process(\n    solver_options,\n    converged_states,\n    prepost_containers,\n    solve_container_caching,\n    solve_parameter_cache_vector,\n    solve_parameter_cache_dims,\n    operating_point,\n    reference_parameters,\n    boundary_layer_options,\n    A_bb_LU,\n    airfoils,\n    idmaps,\n    problem_dimensions,\n    multipoint_index;\n    write_outputs=options.write_outputs,\n    outfile=options.outfile,\n    checkoutfileexists=options.checkoutfileexists,\n    output_tuple_name=options.output_tuple_name,\n    verbose=options.verbose,\n)\n\nPost-process a converged nonlinear solve solution.\n\nArguments\n\nsolver_options::SolverOptionsType : A SolverOptionsType object (also used for dispatch)\nconverged_states::Vector{Float} : the converged state variables\nprepost_containers::NamedTuple : the named tuple containing pre-allocated containers for the pre- and post-processing intermediate calculations\nsolve_container_cache::NamedTuple : the cache and dimensions for intermediate values in the residual calculation\nsolve_parameter_cache_vector::Vector{Float} : the applicably typed cache vector for the solve parameters\nsolve_parameter_cache_dims::NamedTuple : the dimensions of the solver parameters\noperating_point::OperatingPoint : the operating point being analyzed\nreference_parameters::ReferenceParameters : a ReferenceParameters object\nBoundaryLayerOptions::BoundaryLayerOptions : a BoundaryLayerOptions object\nA_bb_LU::LinearAlgebra.LU : LinearAlgebra LU factorization of the LHS matrix\nairfoils::Vector{AFType} : A matrix of airfoil types associated with each of the blade elements\nidmaps::NamedTuple : A named tuple containing index mapping used in bookkeeping throughout solve and post-process\nproblem_dimensions::ProblemDimensions : A ProblemDimensions object\n\nKeyword Arguments\n\nmultipoint_index::Vector{Int} : a one-dimensional vector containing the index of which multipoint analysis operating point is being analyzed.\nwrite_outputs=options.write_outputs::Vector{Bool} : a vector with the same length as number of multipoints indicating if the outputs should be saved.\noutfile=options.outfile::Vector{String} : a vector of file paths/names for where outputs should be written\ncheckoutfileexists=options.checkoutfileexists::Bool : a flag for whether existing files should be checked for or if blind overwriting is okay.\noutput_tuple_name=options.output_tuple_name::Vector{String} : the variable name(s) of the named tuple of outputs to be written.\nverbose::Bool=false : flag to print verbose statements\n\nReturns\n\nouts::NamedTuple : A named tuple containing all the output values including\n\nbodies\npanel_strengths\ntotal_thrust\nthrust_comp\ninduced_efficiency\ncp_in\ncp_out\ncp_casing_in\ncp_casing_out\ncasing_zpts\ncp_nacelle_in\ncp_nacelle_out\nnacelle_zpts\ncp_centerbody_in\ncp_centerbody_out\ncenterbody_zpts\nVtot_in\nVtot_out\nVtot_prejump\nvtot_body\nvtot_jump\nvtot_wake\nvtot_rotors\nVtan_in\nVtan_out\nvtan_casing_in\nvtan_casing_out\nvtan_nacelle_in\nvtan_nacelle_out\nvtan_centerbody_in\nvtan_centerbody_out\nboundary_layers\nstagnation_indices\nupper_solved_states\nupper_solved_steps\nlower_solved_states\nlower_solved_steps\nsurface_length_upper\nsurface_length_lower\nsplit_ratio\nseparation_point_ratio_upper\nseparation_point_ratio_lower\nrotors\ncirculation\npanel_strengths\nefficiency\ninviscid_thrust\ninviscid_thrust_dist\nviscous_thrust\nviscous_thrust_dist\nthrust\nCT\ninviscid_torque\ninviscid_torque_dist\nviscous_torque\nviscous_torque_dist\ntorque\nCQ\ninviscid_power\ninviscid_power_dist\nviscous_power\nviscous_power_dist\npower\nCP\ncl\ncd\nalpha\nbeta1\nblade_normal_force_per_unit_span\nblade_tangential_force_per_unit_span\nwake\npanel_strengths\ntotals\nthrust\ntorque\npower\nCT\nCQ\nCP\ntotal_efficiency\nideal_efficiency\nintermediate_solve_values\nvz_rotor\nvtheta_rotor\nCm_wake\nreynolds\nmach\nCz_rotor\nCtheta_rotor\nCmag_rotor\nGamma_tilde\nH_tilde\ndeltaGamma2\ndeltaH\nvz_wake\nvr_wake\nCm_avg\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/advanced_usage/outputs/#Returning-the-Pre-process-Objects","page":"Outputs","title":"Returning the Pre-process Objects","text":"","category":"section"},{"location":"DuctAPE/advanced_usage/outputs/","page":"Outputs","title":"Outputs","text":"Sometimes, it may be desireable to return the pre-process objects, including:","category":"page"},{"location":"DuctAPE/advanced_usage/outputs/","page":"Outputs","title":"Outputs","text":"panels which is a named tuple containing the body, rotor, and wake panel objects\nivb which are the unit induced velocities on the body panels\nsolve_parameter_tuple which contains all of the solver parameters\nblade_elements which contains all of the blade element geometry and airfoil information\nlinsys which contains all the linear system objects for the panel method\nidmaps which contains all the index mapping used throughout the solve and post-process.","category":"page"},{"location":"DuctAPE/advanced_usage/outputs/","page":"Outputs","title":"Outputs","text":"In this case, we can use the return_inputs keyword argument when calling the analyze function to return a named tuple containing those pre-process objects.","category":"page"},{"location":"DuctAPE/advanced_usage/outputs/","page":"Outputs","title":"Outputs","text":"outs, ins, success_flag = dt.analyze(ducted_rotor, operating_point, reference_parameters; return_inputs=true)","category":"page"},{"location":"DuctAPE/advanced_usage/manual_repaneling/#Circumventing-the-Automated-Geometry-Re-paneling","page":"-","title":"Circumventing the Automated Geometry Re-paneling","text":"","category":"section"},{"location":"DuctAPE/advanced_usage/manual_repaneling/","page":"-","title":"-","text":"It is not advised to circument the automated geometry re-paneling, but if it must be done, the user needs to provide duct, centerbody, and wake nodes conforming to compatible geometry formatting. The best use case for this is to use previously generated geometry or perhaps geometry exported from DFDC.","category":"page"},{"location":"DuctAPE/advanced_usage/manual_repaneling/","page":"-","title":"-","text":"The process is not simple, but is possible. You would have to manually run the dispatches of precompute_parameters that take in the the repaneled body nodes and wake grid. These dispatches exist for this purpose, but there is, by design, no convenience functions at this time to aid the user in easily bypassing the automated repaneling.","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/#Pre-compiling-the-Caches","page":"Preallocation","title":"Pre-compiling the Caches","text":"","category":"section"},{"location":"DuctAPE/advanced_usage/precompilation/","page":"Preallocation","title":"Preallocation","text":"There are several available caches that can be precompiled to help speed up multiple analyses. The first is a cache used for intermediate calculations in the pre- and post-processing phases of the analysis. It can be preallocated using allocate_prepost_container_cache","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/","page":"Preallocation","title":"Preallocation","text":"DuctAPE.allocate_prepost_container_cache","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/#DuctAPE.allocate_prepost_container_cache-DuctAPE-advanced_usage-precompilation","page":"Preallocation","title":"DuctAPE.allocate_prepost_container_cache","text":"allocate_prepost_container_cache(paneling_constants::PanelingConstants)\nallocate_prepost_container_cache(problem_dimensions::ProblemDimensions)\n\nAllocate the pre- and post-processing cache (used for intermediate calculations) based on paneling constants or problem dimensions.\n\nArguments\n\npaneling_constants::PanelingConstants : a PanelingConstants object\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chunk size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nprepost_container_caching::NamedTuple : a Named Tuple containing:\nprepost_container_cache::PreallocationTools.DiffCache : the cache\nprepost_container_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/advanced_usage/precompilation/","page":"Preallocation","title":"Preallocation","text":"The second is a cache containing parameters used in the solver, in other words, the results of the pre-processing phase. It can be preallocated using allocate_solve_parameter_cache.","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/","page":"Preallocation","title":"Preallocation","text":"DuctAPE.allocate_solve_parameter_cache","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/#DuctAPE.allocate_solve_parameter_cache-DuctAPE-advanced_usage-precompilation","page":"Preallocation","title":"DuctAPE.allocate_solve_parameter_cache","text":"allocate_solve_parameter_cache(\n    solve_type::SolverOptionsType,\n    paneling_constants::PanelingConstants;\n    fd_chunk_size=12,\n    levels=1,\n)\nallocate_solve_parameter_cache(\n    solve_type::SolverOptionsType,\n    problem_dimensions::ProblemDimensions;\n    fd_chunk_size=12,\n    levels=1\n)\n\nAllocate the solve parameter cache for parameters passed into the solver(s).\n\nArguments\n\nsolve_type::SolverOptionsType : Solver options type used for dispatch\npaneling_constants::PanelingConstants : a PanlingConstants object used for sizing\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object used for sizing\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chunk size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nsolve_parameter_caching::NamedTuple : a Named Tuple containing:\nsolve_parameter_cache::PreallocationTools.DiffCache : the cache\nsolve_parameter_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/advanced_usage/precompilation/","page":"Preallocation","title":"Preallocation","text":"The final precompileable cache is for intermediate calculations within the solve and can be preallocated using allocate_solve_container_cache","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/","page":"Preallocation","title":"Preallocation","text":"DuctAPE.allocate_solve_container_cache","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/#DuctAPE.allocate_solve_container_cache-DuctAPE-advanced_usage-precompilation","page":"Preallocation","title":"DuctAPE.allocate_solve_container_cache","text":"allocate_solve_container_cache(\n    solve_type::SolverOptionsType,\n    paneling_constants::PanelingConstants;\n    fd_chunk_size=12,\n    levels=1,\n)\nallocate_solve_container_cache(\n    solve_type::SolverOptionsType,\n    problem_dimensions::ProblemDimensions;\n    fd_chunk_size=12,\n    levels=1,\n)\n\nAllocate the solve cache (used for intermediate calculations) based on paneling constants or problem dimensions.\n\nArguments\n\npaneling_constants::PanelingConstants : a PanelingConstants object\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chunk size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nsolve_container_caching::NamedTuple : a Named Tuple containing:\nsolve_container_cache::PreallocationTools.DiffCache : the cache\nsolve_container_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/advanced_usage/precompilation/","page":"Preallocation","title":"Preallocation","text":"You may run all these simultaneously using the initialize_all_caches function.","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/","page":"Preallocation","title":"Preallocation","text":"DuctAPE.initialize_all_caches","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/#DuctAPE.initialize_all_caches-DuctAPE-advanced_usage-precompilation","page":"Preallocation","title":"DuctAPE.initialize_all_caches","text":"initialize_all_caches(solver_options, paneling_constants)\n\nConvenience function to initialize all caches before calling analysis.\n\nArguments\n\nsolver_options::SolverOptionsType : solver options used for cache allocation dispatch\npaneling_constants::PanelingConstants : PanelingConstants object upon which all cache sizing depends\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chunk size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nprepost_container_caching::NamedTuple : A named tuple containing the PreallocationTools DiffCache and a named tuple with relevant dimensions for accessing the cache.\nsolve_parameter_caching::NamedTuple : A named tuple containing the PreallocationTools DiffCache and a named tuple with relevant dimensions for accessing the cache.\nsolve_container_caching::NamedTuple : A named tuple containing the PreallocationTools DiffCache and a named tuple with relevant dimensions for accessing the cache.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/advanced_usage/precompilation/","page":"Preallocation","title":"Preallocation","text":"As an example of how to run this function, we'll grab solver options and paneling constants from previous examples","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/","page":"Preallocation","title":"Preallocation","text":"# - grab an object of SolverOptionsType defined in a previous example - #\naero_solver_options = DuctAPE.NLsolveOptions(;\n    algorithm=:newton,\n    atol=1e-10,\n    iteration_limite=30,\n    linesearch_method=LineSearches.BackTracking, #don't include parentheses on method handle\n    linesearch_kwargs=(; order=3, maxstep=1e6),\n    additional_kwargs=(; autoscale=false),\n)\n\n# - grab an object of PanelingConstants type from the Getting Started tutorial - #\n# number of panels for the duct inlet\nnduct_inlet = 30\n\n# number of panels for the center body inlet\nncenterbody_inlet = 30\n\n# number of panels from:\n#  - rotor to duct trailing edge\n#  - duct trailing edge to center body trailing edge\n#  - center body trailing edge to end of wake\nnpanels = [30, 1, 30]\n\n# the duct trailing edge is ahead of the centerbody trailing edge.\ndte_minus_cbte = -1.0\n\n# number of wake sheets (one more than blade elements to use)\nnwake_sheets = 11\n\n# non-dimensional wake length aft of rear-most trailing edge\nwake_length = 0.8\n\n# assemble paneling constants\npaneling_constants = DuctAPE.PanelingConstants(\n    nduct_inlet, ncenterbody_inlet, npanels, dte_minus_cbte, nwake_sheets, wake_length\n)\n\n# - Initialize Caches - #\nprepost_container_caching, solve_parameter_caching, solve_container_caching = DuctAPE.initialize_all_caches(aero_solver_options, paneling_constants)","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/#How-to-pass-the-caches-into-an-analysis","page":"Preallocation","title":"How to pass the caches into an analysis","text":"","category":"section"},{"location":"DuctAPE/advanced_usage/precompilation/","page":"Preallocation","title":"Preallocation","text":"The precompiled caches can be passed in via keyword arguments to the analysis functions. If they are not, they are generated as the first step in the analysis.","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/","page":"Preallocation","title":"Preallocation","text":"DuctAPE.analyze(\n    ducted_rotor::DuctedRotor,\n    operating_point::OperatingPoint,\n    reference_parameters::ReferenceParameters,\n    options::Options=set_options())","category":"page"},{"location":"DuctAPE/advanced_usage/precompilation/#DuctAPE.analyze-DuctAPE-advanced_usage-precompilation","page":"Preallocation","title":"DuctAPE.analyze","text":"analyze(\n    ducted_rotor::DuctedRotor,\n    operating_point::OperatingPoint,\n    reference_parameters::ReferenceParameters,\n    options::Options=set_options();\n    prepost_container_caching=nothing,\n    solve_parameter_caching=nothing,\n    solve_container_caching=nothing,\n    return_inputs=false,\n)\n\nAnalyze ducted_rotor, including preprocessing.\n\nArguments\n\nducted_rotor::DuctedRotor : DuctedRotor input object (see docstring for DuctedRotor type)\noperating_point::OperatingPoint : OperatingPoint input object (see docstring for OperatingPoint type)\nreference_parameters::ReferenceParameters : ReferenceParameters input object (see docstring for ReferenceParameters type)\noptions::Options=set_options() : Options object (see set_options and related functions)\n\nKeyword Arguments\n\nprepost_container_caching=nothing : Output of allocate_prepost_container_cache\nsolve_parameter_caching=nothing : Output of allocate_solve_parameter_container_cache\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::NamedTuple : Named Tuple of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/public_api/#Public-API","page":"Public API Reference","title":"Public API","text":"","category":"section"},{"location":"DuctAPE/api/public_api/","page":"Public API Reference","title":"Public API Reference","text":"Pages = [\"public_api.md\"]\nDepth = 5","category":"page"},{"location":"DuctAPE/api/public_api/#Input-Types","page":"Public API Reference","title":"Input Types","text":"","category":"section"},{"location":"DuctAPE/api/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.PanelingConstants\nDuctAPE.Rotor\nDuctAPE.DuctedRotor\nDuctAPE.OperatingPoint\nDuctAPE.ReferenceParameters","category":"page"},{"location":"DuctAPE/api/public_api/#DuctAPE.PanelingConstants","page":"Public API Reference","title":"DuctAPE.PanelingConstants","text":"PanelingConstants(\n    nduct_inlet,\n    ncenterbody_inlet,\n    npanels,\n    dte_minus_cbte,\n    nwake_sheets,\n    wake_length=1.0,\n)\n\nConstants used in re-paneling geometry.\n\nNote that unlike other input structures, this one, in general, does not define fields as vectors.  This is because these values should not change throughout an optimization, even if the geometry may change.  Otherwise, discontinuities could be experienced.\n\nArguments\n\nnduct_inlet::Int : The number of panels to use for the duct inlet (this number is used for both the casing and nacelle re-paneling)\nncenterbody_inlet::Int : The number of panels to use for the centerbody inlet.\nnpanels::AbstractVector{Int} : A vector containing the number of panels between discrete locations inside the wake. Specifically, the number of panels between the rotors, between the last rotor and the first body trailing edge, between the body trailing edges (if different), and between the last body trailing edge and the end of the wake.  The length of this vector should be N+1 (where N is the number of rotors) if the duct and centerbody trailing edges are aligned, and N+2 if not.\ndte_minus_cbte::Float : An indicator concerning the hub and duct trailing edge relative locations. Should be set to -1 if the duct trailing edge axial position minus the centerbody trailing edge axial position is negative, +1 if positive (though any positive or negative number will suffice), and zero if the trailing edges are aligned.\nnwake_sheets::Int : The number of wake sheets to use. Note this will also be setting the number of blade elements to use.\nwake_length::Float=1.0 : Non-dimensional (based on the length from the foremost body leading edge and the aftmost body trailing edge) length of the wake extending behind the aftmost body trailing edge.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.Rotor","page":"Public API Reference","title":"DuctAPE.Rotor","text":"Rotor(\n    B, rotorzloc, r, Rhub, Rtip, chords, twists, tip_gap, airfoils, fliplift\n)\n\nComposite type containing the rotor(s) geometric properties.\n\nNote that the actual struct requires the inputs to be arrays, but there is a constructor function that will take in scalars and automatically build the array-based struct.\n\nArguments\n\nB::AbstractVector{Float} : The number of blades for each rotor. May not be an integer, but usually is.\nrotorzloc::AbstractVector{Float} : Dimensional, axial position of each rotor.\nr::AbstractArray{Float} : Non-dimensional radial locations of each blade element.\nRhub::AbstractVector{Float} : Dimensional hub radius of rotor. (may be changed if it does not match the radial position of the centerbody geometry at the selected rotorzloc.\nRtip::AbstractVector{Float} : Dimensional tip radius of rotor. Is used to determine the radial position of the duct if the autoshiftduct option is selected.\nchords::AbstractArray{Float} : Dimensional chord lengths of the blade elements.\ntwists::AbstractArray{Float} : Blade element angles, in radians.\ntip_gap::AbstractVector{Float} : Currently unused, do not set to anything other than zeros.\nairfoils::AbstractArray{AFType} : Airfoil types describing the airfoil polars for each blade element. Currently only fully tested with C4Blade.DFDCairfoil types.\nfliplift::AbstractVector{Bool} : Flag to indicate if the airfoil lift values should be flipped or not.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.DuctedRotor","page":"Public API Reference","title":"DuctAPE.DuctedRotor","text":"DuctedRotor(duct_coordinates, centerbody_coordinates, rotor, paneling_constants)\n\nArguments\n\nduct_coordinates::AbstractMatrix : The [z, r] coordinates of the duct geometry beginning at the inner (casing) side trailing edge and proceeding clockwise. Note that the duct geometry absolute radial position does not need to be included here if the autoshiftduct option is selected.\ncenterbody_coordinates::AbstractMatrix : The [z, r] coordinates of the centerbody beginning at the leading edge and ending at the trailing edge. Note that the leading edge is assumed to be placed at a radial distance of 0.0 from the axis of rotation.\nrotor::Rotor : Rotor (and possibly stator) geometric paramters.\npaneling_constants::PanelingConstants : Constants used in re-paneling the geometry.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.OperatingPoint","page":"Public API Reference","title":"DuctAPE.OperatingPoint","text":"OperatingPoint(Vinf, Minf, rhoinf, muinf, asound, Ptot, Ttot, Omega)\nOperatingPoint(\n    Vinf, Omega, rhoinf=nothing, muinf=nothing, asound=nothing; altitude=0.0\n)\nOperatingPoint(\n    ::Imperial, Vinf, Omega, rhoinf=nothing, muinf=nothing, asound=nothing; altitude=0.0\n)\n\nDuctedRotor operating point information.\n\nFunctions that take in altitude will populate undefined thermodynamic properties of the freestream using a standard_atmosphere model, ideal gas law, and Sutherland's law; defaulting to SI units. If the ::Imperial dispatch type is input, then the thermodynamic properties will be converted to Imperial units.\n\nFields/Arguments\n\nVinf::AbstractVector{Float} : Freestream velocity magnitude (which is only in the axial direction).\nMinf::AbstractVector{Float} : Freestream Mach number\nrhoinf::AbstractVector{Float} : Freestream density\nmuinf::AbstractVector{Float} : Freestream viscosity\nasound::AbstractVector{Float} : Freestream speed of sound\nPtot::AbstractVector{Float} : Freestream total pressure\nTtot::AbstractVector{Float} : Freestream total temperature\nOmega::AbstractVector{Float} : Rotor rototation rate(s)\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.ReferenceParameters","page":"Public API Reference","title":"DuctAPE.ReferenceParameters","text":"ReferenceParameters(Vref, Rref)\n\nReference parameters for post-process non-dimensionalization.\n\nNote that the actual struct requires the inputs to be arrays, but there is a constructor function that will take in scalars and automatically build the array-based struct.\n\nArguments\n\nVref::AbstractVector{Float} : Reference velocity.\nRref::AbstractVector{Float} : Reference rotor tip radius.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#Preallocations","page":"Public API Reference","title":"Preallocations","text":"","category":"section"},{"location":"DuctAPE/api/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.allocate_prepost_container_cache\nDuctAPE.allocate_solve_parameter_cache\nDuctAPE.allocate_solve_container_cache","category":"page"},{"location":"DuctAPE/api/public_api/#DuctAPE.allocate_prepost_container_cache","page":"Public API Reference","title":"DuctAPE.allocate_prepost_container_cache","text":"allocate_prepost_container_cache(paneling_constants::PanelingConstants)\nallocate_prepost_container_cache(problem_dimensions::ProblemDimensions)\n\nAllocate the pre- and post-processing cache (used for intermediate calculations) based on paneling constants or problem dimensions.\n\nArguments\n\npaneling_constants::PanelingConstants : a PanelingConstants object\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chunk size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nprepost_container_caching::NamedTuple : a Named Tuple containing:\nprepost_container_cache::PreallocationTools.DiffCache : the cache\nprepost_container_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/public_api/#DuctAPE.allocate_solve_parameter_cache","page":"Public API Reference","title":"DuctAPE.allocate_solve_parameter_cache","text":"allocate_solve_parameter_cache(\n    solve_type::SolverOptionsType,\n    paneling_constants::PanelingConstants;\n    fd_chunk_size=12,\n    levels=1,\n)\nallocate_solve_parameter_cache(\n    solve_type::SolverOptionsType,\n    problem_dimensions::ProblemDimensions;\n    fd_chunk_size=12,\n    levels=1\n)\n\nAllocate the solve parameter cache for parameters passed into the solver(s).\n\nArguments\n\nsolve_type::SolverOptionsType : Solver options type used for dispatch\npaneling_constants::PanelingConstants : a PanlingConstants object used for sizing\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object used for sizing\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chunk size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nsolve_parameter_caching::NamedTuple : a Named Tuple containing:\nsolve_parameter_cache::PreallocationTools.DiffCache : the cache\nsolve_parameter_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/public_api/#DuctAPE.allocate_solve_container_cache","page":"Public API Reference","title":"DuctAPE.allocate_solve_container_cache","text":"allocate_solve_container_cache(\n    solve_type::SolverOptionsType,\n    paneling_constants::PanelingConstants;\n    fd_chunk_size=12,\n    levels=1,\n)\nallocate_solve_container_cache(\n    solve_type::SolverOptionsType,\n    problem_dimensions::ProblemDimensions;\n    fd_chunk_size=12,\n    levels=1,\n)\n\nAllocate the solve cache (used for intermediate calculations) based on paneling constants or problem dimensions.\n\nArguments\n\npaneling_constants::PanelingConstants : a PanelingConstants object\n\nOR\n\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chunk size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nsolve_container_caching::NamedTuple : a Named Tuple containing:\nsolve_container_cache::PreallocationTools.DiffCache : the cache\nsolve_container_cache_dims::NamedTuple : a named tuple containing the dimensions used for reshaping the cache when needed.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/public_api/#Options","page":"Public API Reference","title":"Options","text":"","category":"section"},{"location":"DuctAPE/api/public_api/#General-Options","page":"Public API Reference","title":"General Options","text":"","category":"section"},{"location":"DuctAPE/api/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.Options\nDuctAPE.set_options","category":"page"},{"location":"DuctAPE/api/public_api/#DuctAPE.Options","page":"Public API Reference","title":"DuctAPE.Options","text":"struct Options\n\nType containing (nearly) all the available user options.\n\nFields\n\nGeneral Options\n\nverbose::Bool = false : flag to print verbose statements\nsilence_warnings::Bool = true : flag to silence warnings\nmultipoint_index::Int = [1] : holds current index of multi-point solver (no need for user to change this usually)\n\nPre-processing Options\n\nGeometry interpolation and generation options :\n\nfinterp::Interplation Method = FLOWMath.akima : interpolation method used for re-paneling bodies\nautoshiftduct::Bool = true : flag as to whether duct geometry should be shifted based on rotor tip location\nlu_decomp_flag::Bool = false : flag indicating if panel method LHS matrix factorization was successful\n\npaneling options\n\nitcpshift::Float = 0.05 : factor for internal trailing edge psuedo-panel placement (default is DFDC hard-coded value)\naxistol::Float = 1e-15 : tolerance for how close the the axis of rotation should be considered on the axis\ntegaptol::Float = 1e1 * eps() : tolerance for how large of a trailing edge gap should be considered a gap\n\nIntegration Options\n\nintegration_options::IntegrationOptions type = IntegrationOptions() : integration options\n\nPost-processing Options\n\nboundary_layer_options::BoundaryLayerOptions : BoundaryLayerOptions object\nwrite_outputs::AbstractArray{Bool} = [false] : Bool for whether to write the outputs of the analysis to an external file (slow)\noutfile::AbstractArray{String} = [\"outputs.jl\"] : External output file name (including path information) for files to write\ncheckoutfileexists::Bool = false : Flag for whether to check if file exists before overwriting\noutput_tuple_name::AbstractArray{String} = [\"outs\"] : variable name for named tuple written to out file\n\nSolving Options\n\ngrid_solver_options::GridSolverOptionsType = GridSolverOptions() : elliptic grid solver options\nsolver_options::SolverOptionsType = ChainSolverOptions() : solver options\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.set_options","page":"Public API Reference","title":"DuctAPE.set_options","text":"set_options(; kwargs...)\nset_options(multipoint; kwargs...)\n\nSet the options for DuctAPE to use.\n\nNote that the vast majority of the available options are defined through keyword arguments.  See the documentation for the various option types for more information.\n\nArguments\n\nmultipoint::AbstractArray{OperatingPoint} : a vector of operating points to use if running a multi-point analysis.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/public_api/#Integration-Options","page":"Public API Reference","title":"Integration Options","text":"","category":"section"},{"location":"DuctAPE/api/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.IntegrationOptions\nDuctAPE.GaussLegendre\nDuctAPE.GaussKronrod\nDuctAPE.Romberg","category":"page"},{"location":"DuctAPE/api/public_api/#DuctAPE.IntegrationOptions","page":"Public API Reference","title":"DuctAPE.IntegrationOptions","text":"struct IntegrationOptions\n\nA struct used to hold the integration options for both the nominal and singular cases.\n\nFields\n\nnominal::IntegrationMethod=GaussLegendre(8) : the integration options to use for the nominal case.\nsingular::IntegrationMethod=GaussLegendre(8) : the integration options to use for the self-induced case.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.GaussLegendre","page":"Public API Reference","title":"DuctAPE.GaussLegendre","text":"struct GaussLegendre <: IntegrationMethod\n\nOptions for Gauss-Legendre integration method\n\nFields\n\nsample_points::Int : Sample Points\nweights::Int : Gauss weights\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.GaussKronrod","page":"Public API Reference","title":"DuctAPE.GaussKronrod","text":"struct GaussKronrod <: IntegrationMethod\n\nOptions for Gauss-Kronrod integration method\n\nFields\n\norder::Int = 7 : order of Legendre polynomial to use on each interval\nmaxevales::Int = 10^7 : maximum number of evaluations in the adaptive method\natol::Float = 0.0 : absolute error tolerance. (note, if zero, QuadGK uses sqrt(eps()) relative tolerance).\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.Romberg","page":"Public API Reference","title":"DuctAPE.Romberg","text":"struct Romberg <: IntegrationMethod\n\nOptions for Romberg integration method\n\nFields\n\nmax_subdivisions::Int = 10 : maximum number of subdivisions. Note, total number of internvals is 2^N, where N is number of subdivisions.\natol::Float = 1e-6 : absolute error tolerance.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#Solver-Options","page":"Public API Reference","title":"Solver Options","text":"","category":"section"},{"location":"DuctAPE/api/public_api/#Elliptic-Grid-Solve","page":"Public API Reference","title":"Elliptic Grid Solve","text":"","category":"section"},{"location":"DuctAPE/api/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.SLORGridSolverOptions\nDuctAPE.GridSolverOptions","category":"page"},{"location":"DuctAPE/api/public_api/#DuctAPE.SLORGridSolverOptions","page":"Public API Reference","title":"DuctAPE.SLORGridSolverOptions","text":"struct SLORGridSolverOptions <: GridSolverOptionsType\n\nOptions for SLOR (successive line over relaxation) elliptic grid solver.\n\nFields\n\niteration_limit::Int = 100 : maximum number of iterations\natol::Float = 1e-9 : absolute convergence tolerance\nconverged::AbstractArray{Bool} = [false]\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.GridSolverOptions","page":"Public API Reference","title":"DuctAPE.GridSolverOptions","text":"struct GridSolverOptions <: GridSolverOptionsType\n\nOptions for Newton elliptic grid solver.\n\nFields\n\niteration_limit::Int = 10 : maximum number of iterations\natol::Float = 1e-14 : absolute convergence tolerance\nalgorithm::Symbol = :newton : algorithm to use in NLsolve.jl\nautodiff::Symbol = :forward : differentiation method to use in NLsolve.jl\nconverged::AbstractArray{Bool} = [false]\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#Aerodynamics-Solve","page":"Public API Reference","title":"Aerodynamics Solve","text":"","category":"section"},{"location":"DuctAPE/api/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.ChainSolverOptions\nDuctAPE.CompositeSolverOptions\nDuctAPE.NLsolveOptions\nDuctAPE.NonlinearSolveOptions\nDuctAPE.MinpackOptions\nDuctAPE.SIAMFANLEOptions\nDuctAPE.SpeedMappingOptions\nDuctAPE.FixedPointOptions\nDuctAPE.CSORSolverOptions\nDuctAPE.ModCSORSolverOptions","category":"page"},{"location":"DuctAPE/api/public_api/#DuctAPE.ChainSolverOptions","page":"Public API Reference","title":"DuctAPE.ChainSolverOptions","text":"struct ChainSolverOptions <:ExternalPolyAlgorithmOptions\n\nOptions for Chain Solvers (try one solver, if it doesn't converge, try another)\n\nFields\n\n`solvers::AbstractArray{SolverOptionsType} = [       NLsolveOptions(; algorithm=:anderson, atol=1e-12),       MinpackOptions(; atol=1e-12),       NonlinearSolveOptions(;           algorithm=SimpleNonlinearSolve.SimpleNewtonRaphson,           atol=1e-12,           additional_kwargs=(; autodiff=SimpleNonlinearSolve.AutoForwardDiff()),       ),   ] : Vector of solver options to use.\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.CompositeSolverOptions","page":"Public API Reference","title":"DuctAPE.CompositeSolverOptions","text":"struct CompositeSolverOptions <: ExternalPolyAlgorithmOptions\n\nOptions for Composite Solvers (start with a partial solve of one solve, then finish with another starting where the first left off).\n\nFields\n\n`solvers::AbstractArray{SolverOptionsType} = [       NLsolveOptions(; algorithm=:newton, iteration_limit=3),       NLsolveOptions(; algorithm=:anderson, atol=1e-12),   ]' : Vector of solver options to use.\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.NLsolveOptions","page":"Public API Reference","title":"DuctAPE.NLsolveOptions","text":"struct NLsolveOptions <: ExternalSolverOptions\n\nOptions for the NLsolve pacakge solvers\n\nFields\n\nalgorithm::Symbol = :anderson : algorithm to use\nadditional_kwargs = (;) : any additional keyword arguments for the solver\natol::Float = 1e-12 : absolute convergence tolerance\niteration_limit::Int = 25 : maximum number of iterations\nlinesearch_method::LineSearches method = LineSearches.MoreThuente : line search method to use\nlinesearch_kwargs = (;) : any additional lineseach keyword arguments\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.NonlinearSolveOptions","page":"Public API Reference","title":"DuctAPE.NonlinearSolveOptions","text":"struct NonlinearSolveOptions <: ExternalSolverOptions\n\nOptions for the SimpleNonlinearSolve pacakge solvers\n\nFields\n\nalgorithm::SimpleNonlinearSolve algorithm = SimpleNonlinearSolve.SimpleNewtonRaphson : algorithm to use\nadditional_kwargs = (;) : any additional keyword arguments for the solver\natol::Float = 1e-12 : absolute convergence tolerance\niteration_limit::Float = 25 : maximum number of iterations\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.MinpackOptions","page":"Public API Reference","title":"DuctAPE.MinpackOptions","text":"struct MinpackOptions <: ExternalSolverOptions\n\nOptions for the MINPACK's HYBRJ solver\n\nFields\n\nalgorithm::Symbol = :hybr : algorithm to use in MINPACK.jl (hybr is HYBRJ when the jacobian is provided)\natol::FLoat = 1e-12 : absolute convergence tolerance\niteration_limit::FLoat = 100 : maximum number of iterations\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.SIAMFANLEOptions","page":"Public API Reference","title":"DuctAPE.SIAMFANLEOptions","text":"struct SIAMFANLEOptions <: ExternalSolverOptions\n\nOptions for the SIAMFANLEquations pacakge solvers\n\nFields\n\nalgorithm::SIAMFANLEquations algorithm = SIAMFANLEquations.nsoli : algorithm to use\nrtol::Float = 0.0 : relative convergence tolerance\natol::Float = 1e-10 : absolute convergence tolerance\niteration_limit::Int = 1000 : maximum number of iterations\nlinear_iteration_limit::Float = 5 : maximum number of linear solve iterations (GMRES)\nadditional_kwargs = (;) : any additional keyword arguments for the solver\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.SpeedMappingOptions","page":"Public API Reference","title":"DuctAPE.SpeedMappingOptions","text":"struct SpeedMappingOptions <: ExternalSolverOptions\n\nOptions for the SpeedMapping.jl package solver\n\nFields\n\n`orders::AbstractArray{Int} = [3, 2]\nsig_min::Int = 0 : maybe set to 1?\nstabilize::Bool = false : stabilizes before extrapolation\ncheck_obj::Bool = false : checks for inf's and nan's and starts from previous finite point\natol::Float = 1e-10 : absolute convergence tolerance\niteration_limit::Float = 1000 : maximum number of iterations\ntime_limit::Float = Inf : time limit in seconds\nlower::Float = nothing : box lower bounds\nupper::Float = nothing : box upper bounds\nbuffer::Float = 0.01 : if using bounds, buffer brings x inside bounds by buffer amountd\nLp::Float = Inf : p value for p-norm for convergence criteria\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.FixedPointOptions","page":"Public API Reference","title":"DuctAPE.FixedPointOptions","text":"struct FixedPointOptions <: ExternalSolverOptions\n\nOptions for the FixedPoint.jl package solver\n\nFields\n\niteration_limit::Int = 1000 : maximum number of iterations\nvel::Float = 0.9 : vel keyword argument, default is package default\nep::Float = 0.01 : ep keyword argument, default is package default\natol::Float = 1e-12 : absolute convergence tolerance\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.CSORSolverOptions","page":"Public API Reference","title":"DuctAPE.CSORSolverOptions","text":"struct CSORSolverOptions <: InternalSolverOptions\n\nType containing all the options for the CSOR (controlled successive over relaxation) solver.\n\nNote that the defaults match DFDC with the exception of the relaxation schedule, which is an experimental feature.\n\nFields\n\nverbose::Bool = false : flag to print verbose statements\niteration_limit::Float = 1e2 : maximum number of iterations\nnrf::Float = 0.4 : nominal relaxation factor\nbt1::Float = 0.2 : backtracking factor 1\nbt2::Float = 0.6 : backtracking factor 2\npf1::Float = 0.4 : press forward factor 1\npf2::Float = 0.5 : press forward factor 2\nbtw::Float = 0.6 : backtracking factor for wake\npfw::Float = 1.2 : press forward factor for wake\nrelaxation_schedule::TS = [[0.0;1e-14;1e-13;1e10]), [1.0;1.0;0.0;0.0])] : values used in spline definition for scaling the relaxation factors (second vector) after various convergence values (first vector).\nf_circ::Float = 1e-3 : convergence tolerance for rotor circulation\nf_dgamw::Float = 2e-4 : convergence tolerance for wake vortex strength\nconvergence_type::ConvergenceType = Relative() : dispatch for relative or absolute convergence criteria.\nVconv::AbstractArray{Float} = [1.0] : velocity used in relative convergence criteria (should be set to Vref).\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.ModCSORSolverOptions","page":"Public API Reference","title":"DuctAPE.ModCSORSolverOptions","text":"struct ModCSORSolverOptions <: InternalSolverOptions\n\nType containing all the options for the modified CSOR solver.\n\nFields\n\nverbose::Bool = false : flag to print verbose statements\niteration_limit::Float = 1e3 : maximum number of iterations\nrelaxation_parameters::NamedTuple = (;\nnrf::Float = 0.4 : nominal relaxation factor\nbt1::Float = 0.2 : backtracking factor 1\nbt2::Float = 0.6 : backtracking factor 2\npf1::Float = 0.4 : press forward factor 1\npf2::Float = 0.5 : press forward factor 2\nbtw::Float = 0.6 : backtracking factor for wake\npfw::Float = 1.2 : press forward factor for wake\n) : parameters for determining relaxation level of states in each iteration.\nconverged::AbstractArray{Bool} = [false] : flag to track if convergence took place.\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#Preprocess","page":"Public API Reference","title":"Preprocess","text":"","category":"section"},{"location":"DuctAPE/api/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.setup_analysis","category":"page"},{"location":"DuctAPE/api/public_api/#DuctAPE.setup_analysis","page":"Public API Reference","title":"DuctAPE.setup_analysis","text":"setup_analysis(\n    ducted_rotor::DuctedRotor,\n    operating_point::OperatingPoint,\n    options::Options=set_options();\n    prepost_container_caching=nothing,\n    solve_parameter_caching=nothing,\n    solve_container_caching=nothing,\n)\n\nPerform pre-processing and cache setup (as needed) for propuslor analysis.\n\nArguments\n\nducted_rotor::DuctedRotor : DuctedRotor input object (see docstring for DuctedRotor type)\noperating_point::OperatingPoint : OperatingPoint input object (see docstring for OperatingPoint type)\noptions::Options=set_options() : Options object (see set_options and related functions)\n\nKeyword Arguments\n\nprepost_container_caching=nothing : Output of allocate_prepost_container_cache\nsolve_parameter_caching=nothing : Output of allocate_solve_parameter_container_cache\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\n\nReturns\n\nproblem_dimensions::NamedTuple : Named Tuple contiaining bookkeeping information (problem dimensions)\nprepost_containers::NamedTuple : Named Tuple containing reshaped views into the prepost cache\nsolve_parameter_cache_vector::Vector : Vector containing the relevant typed cache vector of solve parameters\nsolve_parameter_cache_dims::NamedTuple : Named Tuple containing dimensions used for reshaping the solve parameter cache\nA_bb_LU::LinearAlgebra.LU : The LU factorization of the AIC matrix used in the panel method\nlu_decomp_flag::Bool : flag indicating if the LU decomposition was successful\nairfoils::Matrix{AFType} : Matrix contiaining the blade element airfoil polar objects\nidmaps::NamedTuple : Named Tuple containing bookkeeping information (index mappings)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/public_api/#Analysis","page":"Public API Reference","title":"Analysis","text":"","category":"section"},{"location":"DuctAPE/api/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.analyze","category":"page"},{"location":"DuctAPE/api/public_api/#DuctAPE.analyze","page":"Public API Reference","title":"DuctAPE.analyze","text":"analyze(\n    ducted_rotor::DuctedRotor,\n    operating_point::OperatingPoint,\n    reference_parameters::ReferenceParameters,\n    options::Options=set_options();\n    prepost_container_caching=nothing,\n    solve_parameter_caching=nothing,\n    solve_container_caching=nothing,\n    return_inputs=false,\n)\n\nAnalyze ducted_rotor, including preprocessing.\n\nArguments\n\nducted_rotor::DuctedRotor : DuctedRotor input object (see docstring for DuctedRotor type)\noperating_point::OperatingPoint : OperatingPoint input object (see docstring for OperatingPoint type)\nreference_parameters::ReferenceParameters : ReferenceParameters input object (see docstring for ReferenceParameters type)\noptions::Options=set_options() : Options object (see set_options and related functions)\n\nKeyword Arguments\n\nprepost_container_caching=nothing : Output of allocate_prepost_container_cache\nsolve_parameter_caching=nothing : Output of allocate_solve_parameter_container_cache\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::NamedTuple : Named Tuple of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\nanalyze(\n    ducted_rotor::DuctedRotor,\n    operating_point::OperatingPoint,\n    reference_parameters::ReferenceParameters,\n    prepost_containers,\n    solve_parameter_cache_vector,\n    solve_parameter_cache_dims,\n    airfoils,\n    A_bb_LU,\n    idmaps,\n    problem_dimensions,\n    options::Options=set_options();\n    return_inputs=false,\n    solve_container_caching=nothing,\n)\n\nAnalyze ducted_rotor, assuming setup_analysis has been called and the outputs thereof are being passed in here.\n\nArguments\n\nducted_rotor::DuctedRotor : DuctedRotor input object (see docstring for DuctedRotor type)\noperating_point::OperatingPoint : OperatingPoint input object (see docstring for OperatingPoint type)\nreference_parameters::ReferenceParameters : ReferenceParameters input object (see docstring for ReferenceParameters type)\nprepost_containers::NamedTuple : An output from setup_analysis containing reshaped views into the prepost cache\nsolve_parameter_cache_vector::Vector : An output from setup_analysis containing the relevant typed cache vector of solve parameters\nsolve_parameter_cache_dims::NamedTuple : An output from setup_analysis containing dimensions used for reshaping the solve parameter cache\nairfoils::Vector{AFType} : An output from setup_analysis contiaining the blade element airfoil polar objects\nA_bb_LU::LinearAlgebra.LU : An output from setup_analysis that is the LU decomposition of the AIC matrix used in the panel method\nidmaps::NamedTuple : An output from setup_analysis containing bookkeeping information (index mappings)\nproblem_dimensions::NamedTuple : An output from setup_analysis contiaining bookkeeping information (problem dimensions)\noptions::Options=set_options() : Options object\n\nKeyword Arguments\n\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::NamedTuple : Named Tuple of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\nanalyze(\n    ducted_rotor::DuctedRotor,\n    operating_point::AbstractVector{OperatingPoint},\n    reference_parameters::ReferenceParameters,\n    options::Options=set_options();\n    prepost_container_caching=nothing,\n    solve_parameter_caching=nothing,\n    solve_container_caching=nothing,\n    return_inputs=false,\n)\n\nAnalyze ducted_rotor, including preprocessing, for a set of operating points.\n\nArguments\n\nducted_rotor::DuctedRotor : DuctedRotor input object\noperating_point::AbstractVector{OperatingPoint} : Vector of Operating Points at which to analyze the ducted_rotor\nreference_parameters::ReferenceParameters : ReferenceParameters input object (see docstring for ReferenceParameters type)\noptions::Options=set_options() : Options object\n\nKeyword Arguments\n\nprepost_container_caching=nothing : Output of allocate_prepost_container_cache\nsolve_parameter_caching=nothing : Output of allocate_solve_parameter_container_cache\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::Vector{NamedTuple} : Vector of named tuples of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\nanalyze(\n    ducted_rotor::DuctedRotor,\n    operating_point::Vector{OperatingPoint},\n    reference_parameters::ReferenceParameters,\n    prepost_containers,\n    solve_parameter_cache_vector,\n    solve_parameter_cache_dims,\n    airfoils,\n    A_bb_LU,\n    idmaps,\n    problem_dimensions,\n    options::Options=set_options();\n    return_inputs=false,\n    solve_container_caching=nothing,\n)\n\nAnalyze ducted_rotor, assuming setup_analysis has been called and the inputs are being passed in here.\n\nArguments\n\nducted_rotor::DuctedRotor : DuctedRotor input object\noperating_point::AbstractVector{OperatingPoint} : Vector of Operating Points at which to analyze the ducted_rotor\nreference_parameters::ReferenceParameters : ReferenceParameters input object (see docstring for ReferenceParameters type)\nprepost_containers::NamedTuple : An output from setup_analysis containing reshaped views into the prepost cache\nsolve_parameter_cache_vector::Vector : An output from setup_analysis containing the relevant typed cache vector of solve parameters\nsolve_parameter_cache_dims::NamedTuple : An output from setup_analysis containing dimensions used for reshaping the solve parameter cache\nairfoils::Vector{AFType} : An output from setup_analysis contiaining the blade element airfoil polar objects\nA_bb_LU::LinearAlgebra.LU : An output from setup_analysis that is the LU decomposition of the AIC matrix used in the panel method\nidmaps::NamedTuple : An output from setup_analysis containing bookkeeping information (index mappings)\nproblem_dimensions::NamedTuple : An output from setup_analysis contiaining bookkeeping information (problem dimensions)\noptions::Options=set_options() : Options object\n\nKeyword Arguments\n\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::Vector{NamedTuple} : Named Tuple of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true.  Note that some inputs will be overwritten (e.g. the linear system RHS components related to the freestream) and only those associated with the final operating point will be returned.\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/public_api/#Postprocess","page":"Public API Reference","title":"Postprocess","text":"","category":"section"},{"location":"DuctAPE/api/public_api/","page":"Public API Reference","title":"Public API Reference","text":"DuctAPE.BoundaryLayerOptions\nDuctAPE.HeadsBoundaryLayerOptions\nDuctAPE.GreensBoundaryLayerOptions","category":"page"},{"location":"DuctAPE/api/public_api/#DuctAPE.BoundaryLayerOptions","page":"Public API Reference","title":"DuctAPE.BoundaryLayerOptions","text":"abstract type BoundaryLayerOptions\n\nUsed in boundary layer method dispatch\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.HeadsBoundaryLayerOptions","page":"Public API Reference","title":"DuctAPE.HeadsBoundaryLayerOptions","text":"struct HeadsBoundaryLayerOptions\n\nFields:\n\nmodel_drag::Tb=false : flag to turn on viscous drag approximation\nn_steps::Int = Int(2e2) : number of steps to use in boundary layer integration\nfirst_step_size::Float = 1e-6 : size of first step in boundary layer integration\noffset::Float = 1e-3 : size of offset for (where to initialize) boundary layer integration\nrk::Function = RK4 : solver to use for boundary layer integration (RK4 or RK2 available)\nseparation_criteria::Float=3.0 : value of H12 after which separation should happen.\nseparation_allowance_upper::Int=10 : upper side allowance for how many steps ahead of the trailing edge we'll allow separation without penalty\nseparation_allowance_lower::Int=10 : lower side allowance for how many steps ahead of the trailing edge we'll allow separation without penalty\nseparation_penalty_upper::Float=0.2 : upper side maximum penalty value for separation (at leading edge)\nseparation_penalty_lower::Float=0.2 : lower side maximum penalty value for separation (at leading edge)\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#DuctAPE.GreensBoundaryLayerOptions","page":"Public API Reference","title":"DuctAPE.GreensBoundaryLayerOptions","text":"struct GreensBoundaryLayerOptions\n\nNOTE: Green's method is mostly implemented, but there are several bugs still, especially when using Imperial units. Known Bugs:\n\nImperial units overestimate momentum thickness.  Likely a unit conversion bug.\nIn some cases of non-separation, the momentum thickens or shape parameter becomes exceedingly large, vastly overestimating the drag coefficient.  Likely the product of one or more of the adjustments to try and make the method more robust.\n\nFields:\n\nmodel_drag::Tb=true : flag to turn off viscous drag approximation\nlambda::Bool = true : flag to add secondary influences into boundary layer residuals\nlongitudinal_curvature::Bool = true : if lambda=true, flag to add longitudinal curvature influence into boundary layer residuals\nlateral_strain::Bool = true : if lambda=true, flag to add lateral strain influence into boundary layer residuals\ndilation::Bool = true : if lambda=true, flag to add dilation influence into boundary layer residuals\nn_steps::Int = Int(2e2) : number of steps to use in boundary layer integration\nfirst_step_size::Float = 1e-3 : size of first step in boundary layer integration\noffset::Float = 1e-2 : size of offset for (where to initialize) boundary layer integration\nrk::Function = RK4 : solver to use for boundary layer integration (RK4 or RK2 available)\nseparation_allowance_upper::Int=3 : upper side allowance for how many steps ahead of the trailing edge we'll allow separation without penalty\nseparation_allowance_lower::Int=3 : lower side allowance for how many steps ahead of the trailing edge we'll allow separation without penalty\nseparation_penalty_upper::Float=0.2 : upper side maximum penalty value for separation (at leading edge)\nseparation_penalty_lower::Float=0.2 : lower side maximum penalty value for separation (at leading edge)\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/public_api/#Miscellaneous","page":"Public API Reference","title":"Miscellaneous","text":"","category":"section"},{"location":"DuctAPE/api/public_api/#Airfoil/Geometry-Manipulation","page":"Public API Reference","title":"Airfoil/Geometry Manipulation","text":"","category":"section"},{"location":"DuctAPE/api/public_api/#NACA-6-Series-Cascade-Geometry-Generation","page":"Public API Reference","title":"NACA 6-Series Cascade Geometry Generation","text":"","category":"section"},{"location":"DuctAPE/api/private_utilities/","page":"Utilities","title":"Utilities","text":"DuctAPE.promote_ducted_rotor_type\nDuctAPE.isscalar\nDuctAPE.dot\nDuctAPE.norm\nDuctAPE.cross2mag\nDuctAPE.linear_transform\nDuctAPE.extract_primals!\nDuctAPE.lfs\nDuctAPE.reset_containers!\nDuctAPE.cache_dims!\nDuctAPE.write_data","category":"page"},{"location":"DuctAPE/api/private_utilities/#DuctAPE.promote_ducted_rotor_type","page":"Utilities","title":"DuctAPE.promote_ducted_rotor_type","text":"promote_ducted_rotor_type(ducted_rotor)\n\nConvenience function for promoting types based on any potential elements of the ducted_rotor object dependent on optimization design variables.\n\nArguments\n\nducted_rotor::DuctedRotor : the ducted_rotor input\n\nReturns\n\nTP::Type : the promoted type\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_utilities/#DuctAPE.isscalar","page":"Utilities","title":"DuctAPE.isscalar","text":"isscalar(x::T) where {T} = isscalar(T)\nisscalar(::Type{T}) where {T} = BroadcastStyle(T) isa Broadcast.DefaultArrayStyle{0}\n\nDetermines if the input is a scalar. Note that Base.BroadcastStyle is imported.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_utilities/#DuctAPE.dot","page":"Utilities","title":"DuctAPE.dot","text":"dot(A, B) = sum(a * b for (a, b) in zip(A, B))\n\nA faster dot product.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_utilities/#DuctAPE.norm","page":"Utilities","title":"DuctAPE.norm","text":"norm(A) = sqrt(mapreduce(x -> x^2, +, A))\n\nA faster 2-norm.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_utilities/#DuctAPE.cross2mag","page":"Utilities","title":"DuctAPE.cross2mag","text":"cross2mag(A, B) = A[1] * B[2] - A[2] * B[1]\n\n2D \"cross product\" magnitude\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_utilities/#DuctAPE.linear_transform","page":"Utilities","title":"DuctAPE.linear_transform","text":"linear_transform(range1, range2, values)\n\nLinear transfrom of values from range (source_range[1], source_range[end]) to (target_range[1], target_range[end])\n\nArguments\n\nsource_range::Vector{Float} : range values come from (can also be a Tuple)\ntarget_range::Vector{Float} : range onto which we are transforming (can also be a Tuple)\nsource_values::Array{Float} : array of source values to transform\n\nReturns\n\ntarget_values::Array{Float} : array of transformed sourcevalues onto target range\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_utilities/#DuctAPE.extract_primals!","page":"Utilities","title":"DuctAPE.extract_primals!","text":"extract_primals!(Avalue, A::AbstractMatrix{T}) where {T}\n\nExtracts primals of A and places them in Avalue.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_utilities/#DuctAPE.lfs","page":"Utilities","title":"DuctAPE.lfs","text":"lfs(shape)\n\nDetermines length from shape (output of size function).\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_utilities/#DuctAPE.reset_containers!","page":"Utilities","title":"DuctAPE.reset_containers!","text":"reset_containers!(containers; exception_keys=[])\n\nResets all fields (not incluing any contained in exception keys) of containers-which must be arrays, structs of arrays, or tuples of arrays-to zeros.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_utilities/#DuctAPE.cache_dims!","page":"Utilities","title":"DuctAPE.cache_dims!","text":"cache_dims!(total_length, l, s)\n\nA function that returns a named tuple containing an index range and shape and increases total_length by l.\n\nThis function is used heavily in the cache allocation functions for setting up the dimension maps used to access the vectorized caches.\n\nArguments\n\ntotal_length::Vector{Int} : single element vector containing the current total length of the eventual cache vector. Modified in place.\nl::Int : total length of the object in question\ns::Int : size of the object in question\n\nReturns\n\ndims::NamedTuple : A named tuple containing index and shape fields\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_utilities/#DuctAPE.write_data","page":"Utilities","title":"DuctAPE.write_data","text":"write_data(outs, filename; checkoutfileexists=false)\n\nWrites NamedTuples, specifically for writing out the output of the post_procces() function.\n\nArguments:\n\nouts::NamedTuple : Named tuple to write to file.\nfilename::String : file name (including full desired path and file type) for file to write\n\nKeyword Arguments:\n\noutput_tuple_name::String : desired variable name of written NamedTuple\ncheckoutfileexists::Bool=false : boolean for whether to check if the outfile already exists and whether or not to overwrite it.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/","page":"Process","title":"Process","text":"Pages = [\"private_process.md\"]\nDepth = 5","category":"page"},{"location":"DuctAPE/api/private_process/#Analysis","page":"Process","title":"Analysis","text":"","category":"section"},{"location":"DuctAPE/api/private_process/","page":"Process","title":"Process","text":"DuctAPE.analyze_multipoint","category":"page"},{"location":"DuctAPE/api/private_process/#DuctAPE.analyze_multipoint","page":"Process","title":"DuctAPE.analyze_multipoint","text":"analyze_multipoint(\n    ducted_rotor::DuctedRotor,\n    operating_point::OperatingPoint,\n    reference_parameters::ReferenceParameters\n    prepost_containers,\n    solve_parameter_cache_vector,\n    solve_parameter_cache_dims,\n    airfoils,\n    A_bb_LU,\n    idmaps,\n    problem_dimensions,\n    options::Options;\n    solve_container_caching=nothing,\n    return_inputs=false,\n)\n\nIdentical to the single analyze function assuming setup_analysis has been called; except here we are running a single operating point for a multipoint analysis, and overwriting the operating point in the ducted_rotor with the explicit operating point input.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#Process","page":"Process","title":"Process","text":"","category":"section"},{"location":"DuctAPE/api/private_process/","page":"Process","title":"Process","text":"DuctAPE.process\nDuctAPE.solve","category":"page"},{"location":"DuctAPE/api/private_process/#DuctAPE.process","page":"Process","title":"DuctAPE.process","text":"process(\n    solver_options::SolverOptionsType,\n    solve_parameter_cache_vector,\n    solve_parameter_cache_dims,\n    airfoils,\n    A_bb_LU,\n    solve_container_caching,\n    idmaps,\n    options,\n)\n\nProcess (the step between pre-process and post-process) the solution, in other words: call the solver(s).\n\nArguments\n\nsolver_options::SolverOptionsType : the solver options contained in the options object, used for dispatch.\nsolve_parameter_cache_vector::Vector{Float} : The vector cache for parameters used in the solve.\nsolve_parameter_cache_dims::NamedTuple : A named tuple containing the dimensions of the solve parameters.\nairfoils::NamedTuple : The airfoils to be interpolated that are associated with each blade element\nA_bb_LU::LinearAlgebra.LU : The LU decomposition of the panel method LHS matrix\nsolve_container_caching::NamedTuple : A named tuple containing the cache and dimensions for the intermediate solve values.\nidmaps::NamedTuple : The set of index maps used in various solve sub-functions\noptions::Options : User options\n\nReturns\n\nconverged_states::Vector{Float} : The output of a call to ImplicitAD.implicit\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.solve","page":"Process","title":"DuctAPE.solve","text":"solve(sensitivity_parameters, const_cache; initial_guess=nothing)\n\nA compact dispatch of solve that automatically dispatches based on the solveroptions contained in constcache.\n\n\n\n\n\nsolve(\n    solver_options::SolverOptionsType,\n    sensitivity_parameters,\n    const_cache;\n    initial_guess=nothing,\n)\n\nConverge the residual, solving for the state variables that do so.\n\nArguments\n\nsolver_options::SolverOptionsType : SolverOptionsType used for dispatch\nsensitivity_parameters::Vector{Float} : Sensitivity parameters for solve (parameters passed in through ImplicitAD)\nconst_cache::NamedTuple : A named tuple containing constants and caching helpers.\n\nKeyword Arguments\n\ninitial_guess=nothing::Vector{Float} : An optional manually provided initial guess (contained in the sensitivity parameters anyway).\n\nReturns\n\nconverged_states::Vector{Float} : the states for which the residual has converged.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#Internal-Solvers","page":"Process","title":"Internal Solvers","text":"","category":"section"},{"location":"DuctAPE/api/private_process/#ModCSOR","page":"Process","title":"ModCSOR","text":"","category":"section"},{"location":"DuctAPE/api/private_process/","page":"Process","title":"Process","text":"DuctAPE.mod_COR_solver\nDuctAPE.relax_Gamr_mod!\nDuctAPE.relax_gamw_mod!\nDuctAPE.update_states!","category":"page"},{"location":"DuctAPE/api/private_process/#DuctAPE.mod_COR_solver","page":"Process","title":"DuctAPE.mod_COR_solver","text":"mod_COR_solver(\n    r_fun!,\n    states,\n    B,\n    state_dims;\n    convergence_tolerance=1e-10,\n    iteration_limit=500,\n    relaxation_parameters=(; nrf=0.4, bt1=0.2, bt2=0.6, pf1=0.4, pf2=0.5, btw=0.6, pfw=1.2),\n)\n\nModified DFDC-like CSOR solver that updates all states before relaxing Gamr and gamw.\n\nArguments:\n\nr_fun!::function handle : the residual function for the solver to use\ninitial_states::Vector{Float} : the inital guess for the states\nB::Vector{Float} : number of blades on each rotor (used in state relaxation)\nstate_dims::NamedTuple : dimensions of the states (used in state relaxation)\n\nKeyword Arguments\n\nconvergence_tolerance::type=1e-10 : absolute convergence tolerance\niteration_limit::type=500 : maximum number of iterations\nrelaxation_parameters::type=(; nrf=0.4, bt1=0.2, bt2=0.6, pf1=0.4, pf2=0.5, btw=0.6, pfw=1.2) : parameters used in state relaxation\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.relax_Gamr_mod!","page":"Process","title":"DuctAPE.relax_Gamr_mod!","text":"relax_Gamr_mod!(\n    Gamr,\n    r_Gamr_current,\n    r_Gamr_previous,\n    B;\n    nrf=0.4,\n    bt1=0.2,\n    bt2=0.6,\n    pf1=0.4,\n    pf2=0.5,\n    test=false,\n)\n\nApply relaxed step to Gamr.\n\nArguments\n\nGamr::Array{Float} : Array of rotor circulations (columns = rotors, rows = blade elements), updated in place\nB::Vector{Float} : number of blades on each rotor\nr_Gamr_current::Array{Float} : Array of current iteration's differences in circulation values\nr_Gamr_previous::Array{Float} : Array of previous iteration's differences in circulation values, updated in place\n\nKeyword Arguments:\n\nnrf::Float=0.4 : nominal relaxation factor\nbt1::Float=0.2 : backtrack factor 1\nbt2::Float=0.6 : backtrack factor 2\npf1::Float=0.4 : press forward factor 1\npf2::Float=0.5 : press forward factor 2\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.relax_gamw_mod!","page":"Process","title":"DuctAPE.relax_gamw_mod!","text":"relax_gamw_mod!(gamw, r_gamw_current, r_gamw_previous; nrf=0.4, btw=0.6, pfw=1.2)\n\nApply relaxed step to gamw.\n\nArguments\n\ngamw::Array{Float} : Array of rotor circulations (columns = rotors, rows = blade elements), updated in place\nr_gamw_current::Array{Float} : Array of current iteration's differences in circulation values\nr_gamw_previous::Array{Float} : Array of previous iteration's differences in circulation values, updated in place\n\nKeyword Arguments\n\nnrf::Float=0.4 : nominal relaxation factor\nbt1::Float=0.2 : backtrack factor 1\nbt2::Float=0.6 : backtrack factor 2\npf1::Float=0.4 : press forward factor 1\npf2::Float=0.5 : press forward factor 2\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.update_states!","page":"Process","title":"DuctAPE.update_states!","text":"update_states!(states, r_current, r_previous, B, relaxation_parameters, state_dims)\n\nUpdate states using DFDC-like relaxation methods.\n\nArguments\n\nstates::Vector{Float} : current iteration states to update\nr_current::Vector{Float} : current iteration residual values\nr_previous::Vector{Float} : previous iteration residual values\nB::Vector{Float} : number of blades for each rotor\nrelaxation_parameters::NamedTuple : relaxation parameters\nstate_dims::NamedTuple : dimensions of the state variables\nsolver_options::SolverOptionsType : used for dispatch\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#CSOR","page":"Process","title":"CSOR","text":"","category":"section"},{"location":"DuctAPE/api/private_process/","page":"Process","title":"Process","text":"DuctAPE.apply_relaxation_schedule\nDuctAPE.update_CSOR_residual_values!\nDuctAPE.check_CSOR_convergence!\nDuctAPE.relax_Gamr!\nDuctAPE.relax_gamw!","category":"page"},{"location":"DuctAPE/api/private_process/#DuctAPE.apply_relaxation_schedule","page":"Process","title":"DuctAPE.apply_relaxation_schedule","text":"apply_relaxation_schedule(\n    resid::AbstractVector, solver_options::TS\n) where {TS<:SolverOptionsType}\n\nApply custom relaxation schedule to all relaxation factor inputs based on residual values.\n\nArguments\n\nresid::AbstractVector{Float} : current residual values\nsolver_options::SolverOptionsType : SolverOptions containing relaxation schedule\n\nReturns\n\nnrf::Float : nominal relaxation factor\nbt1::Float : backtrack factor 1\nbt2::Float : backtrack factor 2\npf1::Float : press forward factor 1\npf2::Float : press forward factor 2\n\n\n\n\n\napply_relaxation_schedule(resid, nominal, schedule)\n\nApply custom relaxation schedule to a single relaxation factor input.\n\nArguments\n\nresid::Float : residual value\nnominal::Float : nominal relaxation value\nschedule::AbstractVector{AbstractVector{Float}} : values between which to interpolate to scale the nominal relaxation value.\n\nReturns\n\nrf::Float : the updated relaxation factor\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.update_CSOR_residual_values!","page":"Process","title":"DuctAPE.update_CSOR_residual_values!","text":"update_CSOR_residual_values!(\n    convergence_type::ConvergenceType, resid, maxBGamr, maxdeltaBGamr, maxdeltagamw, Vconv\n)\n\nUpdate CSOR residual values in place.\n\nArguments\n\nconvergence_type::ConvergenceType : used for dispatch of relative or absolute residual values.\nresid::Vector{Float} : residual values modified in place\nmaxBGamr::Float : Maximum value of B*Gamr among all blade elements\nmaxdeltaBGamr::Float : Maximum change in B*Gamr between iterations among all blade elements\nmaxdeltagamw::Vector{Float} : Maximum change in gamw among all wake nodes (one element)\nVconv::Float : Reference velocity upon which the relative convergence criteria is based (one element)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.check_CSOR_convergence!","page":"Process","title":"DuctAPE.check_CSOR_convergence!","text":"check_CSOR_convergence!(\n    conv, resid; f_circ=1e-3, f_dgamw=2e-4, convergence_type=Relative(), verbose=false\n)\n\nDescription\n\nArguments\n\nconv::Vector{Float} : container holding convergence flag\nresid::Vector{Float} : residual vector\n\nKeyword Arguments\n\nf_circ::Float=1e-3 : convergence criteria for circulation residual\nf_dgamw::Float=2e-4 : convergence criteria for wake strength residual\nconvergence_type::ConvergenceType=Relative() : convergence type (absolute or relative) for print statements\nverbose::Bool=false : flag for verbose print statements\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.relax_Gamr!","page":"Process","title":"DuctAPE.relax_Gamr!","text":"relax_Gamr!(\n    Gamr,\n    delta_prev_mat,\n    delta_mat,\n    maxBGamr,\n    maxdeltaBGamr,\n    B;\n    nrf=0.4,\n    bt1=0.2,\n    bt2=0.6,\n    pf1=0.4,\n    pf2=0.5,\n    test=false,\n)\n\nApply relaxed step to Gamr.\n\nArguments\n\nGamr::Array{Float} : Array of rotor circulations (columns = rotors, rows = blade elements), updated in place\ndelta_prev_mat::Array{Float} : Array of previous iteration's differences in circulation values, updated in place\ndelta_mat::Array{Float} : Array of current iteration's differences in circulation values\nmaxBGamr::Array{Float} : stores value of maximum B*Gamr for each rotor\nmaxdeltaBGamr::Array{Float} : stores value of maximum change in B*Gamr for each rotor\nB::Vector{Float} : number of blades on each rotor\nnrf::Float=0.4 : nominal relaxation factor\nbt1::Float=0.2 : backtrack factor 1\nbt2::Float=0.6 : backtrack factor 2\npf1::Float=0.4 : press forward factor 1\npf2::Float=0.5 : press forward factor 2\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.relax_gamw!","page":"Process","title":"DuctAPE.relax_gamw!","text":"relax_gamw!(\n    gamw, delta_prev, delta, maxdeltagamw; nrf=0.4, btw=0.6, pfw=1.2, test=false\n)\n\nApply relaxed step to gamw.\n\nArguments\n\ngamw::Array{Float} : Array of rotor circulations (columns = rotors, rows = blade elements), updated in place\ndelta_prev_mat::Array{Float} : Array of previous iteration's differences in circulation values, updated in place\ndelta_mat::Array{Float} : Array of current iteration's differences in circulation values\nmaxdeltagamw::Array{Float} : Single element array that gets updated with the new maximum change in gamw.\n\nKeyword Arguments:\n\nnrf::Float=0.4 : nominal relaxation factor\nbt1::Float=0.2 : backtrack factor 1\nbt2::Float=0.6 : backtrack factor 2\npf1::Float=0.4 : press forward factor 1\npf2::Float=0.5 : press forward factor 2\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#Residuals","page":"Process","title":"Residuals","text":"","category":"section"},{"location":"DuctAPE/api/private_process/#ModCSOR-2","page":"Process","title":"ModCSOR","text":"","category":"section"},{"location":"DuctAPE/api/private_process/","page":"Process","title":"Process","text":"DuctAPE.mod_CSOR_residual!\nDuctAPE.estimate_CSOR_states!","category":"page"},{"location":"DuctAPE/api/private_process/#DuctAPE.mod_CSOR_residual!","page":"Process","title":"DuctAPE.mod_CSOR_residual!","text":"mod_CSOR_residual!(r, current_states, inputs, constants)\n\nModified DFDC-like CSOR residual that does not include any relaxation within the residual calculation.\n\nArguments\n\nr::Vector{Float} : solve residual\ncurrent_states::Vector{Float} : solve states\ninputs::Vector{Float} : solve inputs\nconstants::Vector{Float} : solve constants\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.estimate_CSOR_states!","page":"Process","title":"DuctAPE.estimate_CSOR_states!","text":"estimate_CSOR_states!(\n    solve_containers,\n    Gamr,\n    sigr,\n    gamw,\n    operating_point,\n    ivr,\n    ivw,\n    linsys,\n    blade_elements,\n    wakeK,\n    idmaps;\n    verbose=false,\n)\n\nEstimate states for modified CSOR solver.\n\nArguments:\n\nsolve_containers::NamedTuple : cache for intermediate solve values\nGamr::type : Blade element circulation strengths\nsigr::type : Rotor source panel strengths\ngamw::type : Wake vortex panel strengths\noperating_point::NamedTuple : Named tuple containing operating_point information\nivr::NamedTuple : unit induced velocities on rotor(s)\nivw::NamedTuple : unit induced velocities on wake\nlinsys::NamedTuple : vectors and matricies comprising the panel method linear system\nblade_elements::NamedTuple : blade element geometry and airfoil polar information\nwakeK::Vector{Float} : geometric constants used in caculating wake strengths\nidmaps::NamedTuple : index maps used throughout solve\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#CSOR-2","page":"Process","title":"CSOR","text":"","category":"section"},{"location":"DuctAPE/api/private_process/","page":"Process","title":"Process","text":"DuctAPE.CSOR_residual!\nDuctAPE.compute_CSOR_residual!","category":"page"},{"location":"DuctAPE/api/private_process/#DuctAPE.CSOR_residual!","page":"Process","title":"DuctAPE.CSOR_residual!","text":"CSOR_residual!(resid, state_variables, sensitivity_parameters, constants)\n\nThe in-place residual used for the CSOR solve method.\n\nArguments\n\nresid::Vector{Float} : In-place residual.\nstate_variables::Vector{Float} : The state variables\nsensitivity_parameters::Vector{Float} : The parameters to which the solution is sensitive.\nconstants::NamedTuple : Various constants required in the solve\n\nReturns\n\nstate_variables::Vector{Float} : The state variables (modified in place)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.compute_CSOR_residual!","page":"Process","title":"DuctAPE.compute_CSOR_residual!","text":"compute_CSOR_residual!(\n    resid,\n    solver_options,\n    solve_containers,\n    Gamr,\n    sigr,\n    gamw,\n    operating_point,\n    ivr,\n    ivw,\n    linsys,\n    blade_elements,\n    wakeK,\n    idmaps;\n    verbose=false,\n)\n\nDescription\n\nArguments\n\nresid::Vector{Float} : the residual vector\nsolver_options::SolverOptionsType : solver options (used for convergence criteria)\nsolve_containers::NamedTuple : cache for intermediate solve values\nGamr::type : Blade element circulation strengths\nsigr::type : Rotor source panel strengths\ngamw::type : Wake vortex panel strengths\noperating_point::NamedTuple : Named tuple containing operating_point information\nivr::NamedTuple : unit induced velocities on rotor(s)\nivw::NamedTuple : unit induced velocities on wake\nlinsys::NamedTuple : vectors and matricies comprising the panel method linear system\nblade_elements::NamedTuple : blade element geometry and airfoil polar information\nwakeK::Vector{Float} : geometric constants used in caculating wake strengths\nidmaps::NamedTuple : index maps used throughout solve\n\nKeyword Arguments\n\nverbose::Bool=false : Flag to print verbose statements\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#External-Solvers","page":"Process","title":"External Solvers","text":"","category":"section"},{"location":"DuctAPE/api/private_process/","page":"Process","title":"Process","text":"DuctAPE.system_residual\nDuctAPE.system_residual!\nDuctAPE.update_system_residual!\nDuctAPE.estimate_states!","category":"page"},{"location":"DuctAPE/api/private_process/#DuctAPE.system_residual","page":"Process","title":"DuctAPE.system_residual","text":"system_residual(state_variables, sensitivity_parameters, constants)\n\nThe residual function for external solvers.\n\nArguments\n\nstate_variables::Vector{Float} : the state variables\nsensitivity_parameters::Vector{Float} : parameters to which the solution derivatives are sensitive\nconstants::NamedTuple : parameters to which the solution derivatives are constant\n\nReturs\n\nresid::Vector{Float} : residual vector\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.system_residual!","page":"Process","title":"DuctAPE.system_residual!","text":"system_residual!(resid, state_variables, sensitivity_parameters, constants)\n\nIn-place version of system_residual.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.update_system_residual!","page":"Process","title":"DuctAPE.update_system_residual!","text":"update_system_residual!(\n    solver_options::SolverOptionsType\n    resid,\n    vz_est,\n    vz_rotor,\n    vtheta_est,\n    vtheta_rotor,\n    Cm_est,\n    Cm_wake,\n    solve_parameter_cache_dims,\n)\n\nUpdate the residual for external solvers.\n\nArguments\n\n`solver_options::SolverOptionsType\nresid::Vector{Float} : residual vector\nvz_est::Vector{Float} : axial induced rotor velocity estimate container\nvz_rotor::Vector{Float} : axial induced rotor velocity state container\nvtheta_est::Vector{Float} : tangential induced rotor velocity estimate container\nvtheta_rotor::Vector{Float} : tangential induced rotor velocity state container\nCm_est::Vector{Float} : absolute meridional wake control point velocity estimate container\nCm_wake::Vector{Float} : absolute meridional wake control point velocity state container\nsolve_parameter_cache_dims::Vector{Float} : dimensions of state vectors to use in accessing the residual vector\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.estimate_states!","page":"Process","title":"DuctAPE.estimate_states!","text":"estimate_states!(\n    solve_containers,\n    vz_rotor,\n    vtheta_rotor,\n    Cm_wake,\n    operating_point,\n    ivr,\n    ivw,\n    linsys,\n    blade_elements,\n    wakeK,\n    idmaps;\n    verbose=false,\n)\n\nEstimate velocity states.\n\nArguments\n\nsolve_containers::NamedTuple : cache for intermediate values in solve\nvz_rotor::Vector{Float} : axial induced rotor velocity state container\nvtheta_rotor::Vector{Float} : tangential induced rotor velocity state container\nCm_wake::Vector{Float} : absolute meridional wake control point velocity state container\noperating_point::NamedTuple : Named tuple containing operating_point information\nivr::NamedTuple : unit induced velocities on rotor(s)\nivw::NamedTuple : unit induced velocities on wake\nlinsys::NamedTuple : vectors and matricies comprising the panel method linear system\nblade_elements::NamedTuple : blade element geometry and airfoil polar information\nwakeK::Vector{Float} : geometric constants used in caculating wake strengths\nidmaps::NamedTuple : index maps used throughout solve\n\nKeyword Arguments\n\nverbose::Bool=false : flag for verbose print statements\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#Solve-Utilities","page":"Process","title":"Solve Utilities","text":"","category":"section"},{"location":"DuctAPE/api/private_process/","page":"Process","title":"Process","text":"DuctAPE.extract_initial_guess\nDuctAPE.extract_state_variables","category":"page"},{"location":"DuctAPE/api/private_process/#DuctAPE.extract_initial_guess","page":"Process","title":"DuctAPE.extract_initial_guess","text":"extract_initial_guess(\n    solver_options::SolverOptionsType, sensitivity_parameters, state_dims\n)\n\nExtract initial guess from the solve parameters cache vector.\n\nArguments\n\nsolver_options::SolverOptionsType : used for dispatch\nsensitivity_parameters::Vector{Float} : vector form of solve parameter cache passed into the solver.\nstate_dims::NamedTuple : dimensions and indices of state variables within the solve parameter cache vector\n\nReturns\n\ninitial_guess::Vector{Float}` : a vector of the solver initial guess\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_process/#DuctAPE.extract_state_variables","page":"Process","title":"DuctAPE.extract_state_variables","text":"extract_state_variables(solver_options::SolverOptionsType, vars, dims)\n\nReshape the state variables from a single vector, to multiple arrays.\n\nArguments\n\nReturns if solver_options <: CSORSolverOptions\n\nGamr::type : Blade element circulation strengths\nsigr::type : Rotor source panel strengths\ngamw::type : Wake vortex panel strengths\n\nReturns if solver_options <: Union{ExternalSolverOptions, PolyAlgorithmOptions}\n\nvz_rotor::Vector{Float} : axial induced rotor velocity state container\nvtheta_rotor::Vector{Float} : tangential induced rotor velocity state container\nCm_wake::Vector{Float} : absolute meridional wake control point velocity state container\n\n\n\n\n\n","category":"function"},{"location":"C4Blade/api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"C4Blade/api/","page":"API Reference","title":"API Reference","text":"Pages = [\"C4Blade/api.md\"]\nDepth = 5","category":"page"},{"location":"C4Blade/api/","page":"API Reference","title":"API Reference","text":"Modules=[DuctAPE.C4Blade]","category":"page"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"Pages = [\"private_preprocess.md\"]\nDepth = 5","category":"page"},{"location":"DuctAPE/api/private_preprocess/#General","page":"Preprocess","title":"General","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"DuctAPE.set_index_maps\nDuctAPE.precompute_parameters\nDuctAPE.precompute_parameters!","category":"page"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.set_index_maps","page":"Preprocess","title":"DuctAPE.set_index_maps","text":"set_index_maps(\n    npanels,\n    ncenterbody_inlet,\n    nwake_sheets,\n    dte_minus_cbte,\n    wnm,\n    wenids,\n    nwp,\n    nwsp,\n    nbn,\n    ndp,\n    riiw,\n    nrotor,\n)\n\nSet values for index map to be used throughout solve and post-process.\n\nArguments\n\nnpanels : paneling_constants.npanels\nncenterbody_inlet : paneling_constants.ncenterbody_inlet\nnwake_sheets : paneling_constants.nwake_sheets\ndte_minus_cbte : paneling_constants.dte_minus_cbte\nwnm : wake_vortex_panels.nodemap\nwenids : wake_vortex_panels.endnodeidxs\nnwp :  problem_dimensions.nwp\nnwsp : problem_dimensions.nwsp\nnbn : problem_dimensions.nbn\nndp : body_vortex_panels.npanel[1]\nriiw : rotor_indices_in_wake\nnrotor : problem_dimensions.nrotor\n\nReturns\n\nidmaps::NamedTuple : A named tuple containing index mapping used in bookkeeping throughout solve and post-process\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.precompute_parameters","page":"Preprocess","title":"DuctAPE.precompute_parameters","text":"precompute_parameters(\n    ducted_rotor,\n    operating_point;\n    grid_solver_options=GridSolverOptions(),\n    integration_options=IntegrationOptions(),\n    autoshiftduct=true,\n    itcpshift=0.05,\n    axistol=1e-15,\n    tegaptol=1e1 * eps(),\n    finterp=(x,y,xp)->FLOWMath.akima(x,y,xp,2.0*eps(),eps()),\n    silence_warnings=true,\n    verbose=false,\n)\n\nOut of place main pre-processing function that computes all the required parameters for the solve.\n\nArguments\n\nducted_rotor::DuctedRotor : A DuctedRotor object\noperating_point::OperatingPoint : A OperatingPoint object\n\nKeyword Arguments\n\ngrid_solver_options::GridSolverOptionsType=GridSolverOptions() : A GridSolverOptionsType object\nintegration_options::IntegrationMethod=IntegrationOptions() : An IntegrationMethod object\nautoshiftduct::Bool=true : flag to shift duct geometry based on rotor tip radius\nitcpshift::Float=0.05 : value used in positioning the internal pseudo control point in the solid bodies. Default is DFDC hard-coded value.\naxistol::Float=1e-15 : tolerance for how close to the axis of rotation to be considered on the axis.\ntegaptol::Float=1e1 * eps() : tolerance for how large of a trailing edge gap is considered a gap.\nfinterp::Function=FLOWMath.akima : interpolation method for re-interpolating body coordinates\nsilence_warnings::Bool=true : flag to silence warnings\nverbose::Bool=false : flag to print verbose statements\n\nReturns\n\nivr::NamedTuple : A named tuple containing arrays of induced velocities on the rotors\nivw::NamedTuple : A named tuple containing arrays of induced velocities on the wake\nivb::NamedTuple : A named tuple containing arrays of induced velocities on the bodies\nlinsys::NamedTuple : A named tuple containing cacheable data for the linear system, including:\nA_bb::Array{Float} : AIC (LHS) matrix for the panel method system\nb_bf::Array{Float} : Initial system RHS vector based on freestrem magnitude\nA_br::Array{Float} : Unit normal velocity from rotors onto body panels\nA_pr::Array{Float} : Unit normal velocity from rotors onto body internal psuedo control points\nA_bw::Array{Float} : Unit normal velocity from wake onto body panels\nA_pw::Array{Float} : Unit normal velocity from wake onto body internal psuedo control points\nA_bb_LU::LinearAlgebra.LU : LinearAlgebra LU factorization of the LHS matrix\nlu_decomp_flag::Vector{Bool} : flag for whether factorization was successful\nblade_elements::NamedTuple : A named tuple containing cacheable blade element information (see docs for interpolate_blade_elements)\nairfoils::Vector{AFType} : A matrix of airfoil types associated with each of the blade elements\nwakeK::Matrix{Float} : A matrix of precomputed geometric constants used in the calculation of the wake vortex strengths\nidmaps::NamedTuple : A named tuple containing index mapping used in bookkeeping throughout solve and post-process\npanels::NamedTuple : A named tuple of panel objects including:\nbody_vortex_panels::NamedTuple : the named tuple containing the body vortex panel information\nrotor_source_panels::NamedTuple : the named tuple containing the rotor source panel information\nwake_vortex_panels::NamedTuple : the named tuple containing the wake vortex panel information\nproblem_dimensions::ProblemDimensions : A ProblemDimensions object\n\n\n\n\n\nprecompute_parameters(\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    wake_grid,\n    rotor_indices_in_wake,\n    Rtips,\n    Rhubs,\n    rotor,\n    paneling_constants,\n    operating_point,\n    integration_options,\n    problem_dimensions=nothing;\n    itcpshift=0.05,\n    axistol=1e-15,\n    tegaptol=1e1 * eps(),\n    silence_warnings=true,\n    verbose=false,\n)\n\nAn alternate version of precompute_parameters allowing for user defined geometry that does not go through a re-panling step (use with caution).\n\nThe first inputs are the outputs of the reinterpolate_geometry and get_blade_ends_from_body_geometry functions.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.precompute_parameters!","page":"Preprocess","title":"DuctAPE.precompute_parameters!","text":"precompute_parameters!(\n    ivr,\n    ivw,\n    blade_element_cache,\n    linsys,\n    wakeK,\n    ducted_rotor,\n    operating_point,\n    prepost_containers,\n    problem_dimensions;\n    grid_solver_options=GridSolverOptions(),\n    integration_options=IntegrationOptions(),\n    autoshiftduct=true,\n    itcpshift=0.05,\n    axistol=1e-15,\n    tegaptol=1e1 * eps(),\n    finterp=(x,y,xp)->FLOWMath.akima(x,y,xp,2.0*eps(),eps()),\n    silence_warnings=true,\n    verbose=false,\n)\n\nIn-place version of precompute_parameters.\n\n\n\n\n\nprecompute_parameters!(\n    ivr,\n    ivw,\n    blade_element_cache,\n    linsys,\n    wakeK,\n    wake_grid,\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    rotor_indices_in_wake,\n    rotor,\n    paneling_constants,\n    operating_point,\n    prepost_containers,\n    problem_dimensions=nothing;\n    integration_options=IntegrationOptions(),\n    itcpshift=0.05,\n    axistol=1e-15,\n    tegaptol=1e1 * eps(),\n    finterp=(x,y,xp)->FLOWMath.akima(x,y,xp,2.0*eps(),eps()),\n    silence_warnings=true,\n    verbose=false,\n)\n\nIn-place version of the precompute_parameters function by-passing the geometry reinterpolateion. (Use with caution)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#Geometry","page":"Preprocess","title":"Geometry","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"DuctAPE.reinterpolate_geometry\nDuctAPE.reinterpolate_geometry!\nDuctAPE.generate_all_panels\nDuctAPE.generate_all_panels!","category":"page"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.reinterpolate_geometry","page":"Preprocess","title":"DuctAPE.reinterpolate_geometry","text":"reinterpolate_geometry(\n    problem_dimensions,\n    duct_coordinates,\n    centerbody_coordinates,\n    rotor,\n    paneling_constants;\n    autoshiftduct=true,\n    grid_solver_options=GridSolverOptions(),\n    finterp=(x,y,xp)->FLOWMath.akima(x,y,xp,2.0*eps(),eps()),\n    verbose=false,\n    silence_warnings=true,\n)\n\nRe-interpolate the body geometry and return compatible body and way geometry.\n\nArguments\n\nproblem_dimensions::ProblemDimensions : A ProblemDimensions object\nduct_coordinates::Matrix{Float} : [z,r] coordinates of duct geometry\ncenterbody_coordinates::Matrix{Float} : [z,r] coordinates of centerbody geometry\nrotor::Rotor : A Rotor object\npaneling_constants::PanelingConstants : A PanelingConstants object\n\nKeyword Arguments\n\nautoshiftduct::Bool=true : flag to shift duct geometry based on rotor tip radius\ngrid_solver_options::SolverOptionsType=GridSolverOptions() : options for the wake grid position solver\nfinterp::Function=FLOWMath.akima : interpolation method for re-interpolating body coordinates\nverbose::Bool=false : flag to print verbose statements\nsilence_warnings::Bool=true : flag to silence warnings\n\nReturns\n\nwake_grid::Array{Float} : array containig the z and r elliptic grid points defning the wake geometry.\nrp_duct_coordinates::Matrix{Float} : matrix containing the re-paneled duct coordinates\nrp_centerbody_coordinates::Matrix{Float} : matrix containing the re-paneled centerbody coordinates\nrotor_indices_in_wake::Vector{Int} : vector containing the indices of where in the wake the rotors reside (used later to define the rotor panel edges).\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.reinterpolate_geometry!","page":"Preprocess","title":"DuctAPE.reinterpolate_geometry!","text":"reinterpolate_geometry!(\n    wake_grid,\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    rotor_indices_in_wake,\n    duct_coordinates,\n    centerbody_coordinates,\n    rotor,\n    blade_element_cache,\n    paneling_constants;\n    autoshiftduct=true,\n    grid_solver_options=GridSolverOptions(),\n    finterp=(x,y,xp)->FLOWMath.akima(x,y,xp,2.0*eps(),eps()),\n    verbose=false,\n    silence_warnings=true,\n)\n\nIn-place version of reinterpolate_geometry.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.generate_all_panels","page":"Preprocess","title":"DuctAPE.generate_all_panels","text":"generate_all_panels(\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    nwake_sheets,\n    rotor_indices_in_wake,\n    rotorzloc,\n    wake_grid;\n    itcpshift=0.05,\n    axistol=1e-15,\n    tegaptol=1e1 * eps(),\n    silence_warnings=true,\n)\n\nFunction that calls all of the various panel generation functions are returns a named tuple containing all the panels\n\nArguments\n\nrp_duct_coordinates::Matrix{Float} : matrix containing the re-paneled duct coordinates\nrp_centerbody_coordinates::Matrix{Float} : matrix containing the re-paneled centerbody coordinates\nnwake_sheets::Int : number of wake sheets\nrotor_indices_in_wake::Vector{Int} : vector containing the indices of where in the wake the rotors reside (used later to define the rotor panel edges).\nrotorzloc:Vector{Float} : axial locations of rotor lifting lines (contained in Rotor)\nwake_grid::Array{Float} : array containig the z and r elliptic grid points defning the wake geometry.\n\nKeyword Arguments\n\nitcpshift::Float=0.05 : value used in positioning the internal pseudo control point in the solid bodies. Default is DFDC hard-coded value.\naxistol::Float=1e-15 : tolerance for how close to the axis of rotation to be considered on the axis.\ntegaptol::Float=1e1 * eps() : tolerance for how large of a trailing edge gap is considered a gap.\nsilence_warnings::Bool=true : flag to silence warnings\n\nReturns\n\npanels::NamedTuple : A named tuple of named tuples containing paneling information, including:\nbody_vortex_panels::NamedTuple\nrotor_source_panels::NamedTuple\nwake_vortex_panels::NamedTuple\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.generate_all_panels!","page":"Preprocess","title":"DuctAPE.generate_all_panels!","text":"generate_all_panels!(\n    panels,\n    wake_grid,\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    rotor_indices_in_wake,\n    rotorzloc,\n    nwake_sheets;\n    itcpshift=0.05,\n    axistol=1e-15,\n    tegaptol=1e1 * eps(),\n    silence_warnings=true,\n)\n\nIn-place version of generate_all_panels.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#Wake","page":"Preprocess","title":"Wake","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"DuctAPE.discretize_wake\nDuctAPE.generate_wake_grid\nDuctAPE.generate_wake_grid!\nDuctAPE.initialize_wake_grid\nDuctAPE.initialize_wake_grid!\nDuctAPE.relax_grid!\nDuctAPE.solve_elliptic_grid!\nDuctAPE.solve_elliptic_grid\nDuctAPE.elliptic_grid_residual!\nDuctAPE.backward_stencil_1\nDuctAPE.center_stencil_1\nDuctAPE.center_stencil_2\nDuctAPE.center_stencil_2_mixed\nDuctAPE.generate_wake_panels\nDuctAPE.generate_wake_panels!\nDuctAPE.get_wake_k\nDuctAPE.get_wake_k!","category":"page"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.discretize_wake","page":"Preprocess","title":"DuctAPE.discretize_wake","text":"discretize_wake(\n    duct_coordinates,\n    centerbody_coordinates,\n    rotorzloc, # rotor axial locations\n    wake_length,\n    npanels,\n    dte_minus_cbte;\n)\n\nCalculate wake sheet panel node z-coordinates.\n\nArguments\n\nduct_coordinates::Matrix{Float} : Array of input duct coordinates\ncenterbody_coordinates::Matrix{Float} : Array of input centerbody_coordinates coordinates\nrotorzloc ::Vector{Float} : rotor axial locations\nwake_length::Float : non-dimensional length of wake to extend beyond aft-most body trailing edge.\nnpanels::Vector{Int} : A vector of the number of panels between each discrete point.  For example: [number of panels between the rotors; number of panels between the stator and the first trailing edge; number of panels between the trailing edges; number of panels between the last trailing edge and the end of the wake]\ndte_minus_cbte::Float : indicator as to whether the duct trailing edge minus the centerbody trailing edge is positive, zero, or negative.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.generate_wake_grid","page":"Preprocess","title":"DuctAPE.generate_wake_grid","text":"generate_wake_grid(\n    problem_dimensions,\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    Rhub1,\n    Rtip1,\n    tip_gap1,\n    zwake;\n    grid_solver_options=GridSolverOptions(),\n    verbose=false,\n    silence_warnings=true,\n)\n\nInitialize and solve for elliptic grid on which wake sheets are defined.\n\nArguments\n\nproblem_dimensions:: : A ProblemDimensions object\nrp_duct_coordinates:: : repaneled duct coordinates\nrp_centerbody_coordinates:: : repaneled centerbody coordinates\nRhub1:: : Hub radius of first rotor\nRtip1:: : Tip radius of first rotor\ntip_gap1:: : Tip gap of first rotor (MUST BE ZERO for now)\nzwake:: : axial positions of wake sheet panel nodes\n\nKeyword Arguments\n\ngrid_solver_options::GridSolverOptionsType=GridSolverOptions() : options for solving the elliptic grid.\nverbose::Bool=false : flag to print verbose statements\nsilence_warnings::Bool=true : flag to supress warnings\n\nReturns\n\nwake_grid::Array{Float,3} : 3D Array of axial and radial wake_grid points after solution of elliptic system.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.generate_wake_grid!","page":"Preprocess","title":"DuctAPE.generate_wake_grid!","text":"generate_wake_grid!(\n    wake_grid,\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    Rhub1,\n    Rtip1,\n    tip_gap1,\n    zwake;\n    grid_solver_options=grid_solver_options,\n    verbose=false,\n    silence_warnings=true,\n)\n\nIn-place version of generate_wake_grid.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.initialize_wake_grid","page":"Preprocess","title":"DuctAPE.initialize_wake_grid","text":"initialize_wake_grid(rp_duct_coordinates, rp_centerbody_coordinates, zwake, rwake)\n\nInitialize the wake grid.\n\nArguments:\n\nrp_duct_coordinates::Matrix{Float} : The re-paneled duct coordinates\nrp_centerbody_coordinates::Matrix{Float} : The re-paneled centerbody coordinates\nzwake::Vector{Float} : The axial positions of the wake sheet panel nodes\nrwake::Vector{Float} : The radial positions of the blade elements for the foremost rotor\n\nReturns:\n\nwake_grid::Array{Float,3} : 3D Array of axial and radial wake_grid points\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.initialize_wake_grid!","page":"Preprocess","title":"DuctAPE.initialize_wake_grid!","text":"initialize_wake_grid!(\n    wake_grid, rp_duct_coordinates, rp_centerbody_coordinates, zwake, rwake\n)\n\nIn-place version of initialize_wake_grid.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.relax_grid!","page":"Preprocess","title":"DuctAPE.relax_grid!","text":"relax_grid!(\n    grid_solver_options::GridSolverOptionsType,\n    wake_grid;\n    verbose=false,\n    silence_warnings=true,\n    tabchar=\"    \",\n    ntab=1,\n)\n\nRelax/Solve initial wake grid according to elliptic system of equations.\n\nArguments\n\n`gridsolveroptions::GridSolverOptionsType' : options for elliptic grid solver\nwake_grid::Array{Float,3} : Initialized wake grid\n\nKeyword Arguments\n\n`verbose=false::' : flag for printing verbose statements\n`silence_warnings=true::' : flag for supressing warnings\n`tabchar::String=\"    \"::' : string to use for tabbing over verbose statements.\n`ntab::Int=1' : number of tabs for printing verbose statements\n\n\n\n\n\nrelax_grid!(xg, rg, nxi, neta; iteration_limit, atol)\n\nRelax wakegrid using elliptic wakegrid solver.\n\nArguments:\n\nwake_grid::Array{Float} : initial guess for grid points.\n\nKeyword Arguments:\n\niteration_limit::Int : maximum number of iterations to run, default=100\natol::Float : convergence tolerance, default = 1e-9\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.solve_elliptic_grid!","page":"Preprocess","title":"DuctAPE.solve_elliptic_grid!","text":"solve_elliptic_grid!(\n    wake_grid;\n    algorithm=:trust_region,\n    autodiff=:forward,\n    atol=1e-14,\n    iteration_limit=10,\n    converged=[false],\n    verbose=false,\n)\n\nSolve for elliptic grid using a non-SLOR approach that is compatible with ImplicitAD\n\nArguments:\n\nwake_grid::Array{Float} : initial guess for grid points.\n\nKeyword Arguments:\n\nalgorithm::Symbol=:trust_region : NLsolve algorithm type\nautodiff::Symbol=:forward : NLsolve derivatives option\natol::Float=1e-10 : convergence tolerance, default = 1e-9\niteration_limit::Int=10 : maximum number of iterations to run, default=100\nconverged::Vector{Bool}=[false] : convergence flag\nverbose::Bool=false : flag to print verbose statements\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.solve_elliptic_grid","page":"Preprocess","title":"DuctAPE.solve_elliptic_grid","text":"solve_elliptic_grid!(x,p)\n\nSolve for elliptic grid using a non-SLOR approach that is compatible with ImplicitAD\n\nArguments:\n\nx::Vector{Float} : inputs (including initial guess for wake grid points)\np::NamedTuple : constant parameters\n\nReturns:\n\nconverged_states::Vector{Float} : converged states for grid solver\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.elliptic_grid_residual!","page":"Preprocess","title":"DuctAPE.elliptic_grid_residual!","text":"elliptic_grid_residual!(r, y, x, p)\n\nResidual function for elliptic grid solver.\n\nNote: We assume grid has radial lines of constant axial position (as is done in the grid initialization) such that z'()=1.0 and z''()=z'()=z''()=0.0.\n\nArguments\n\nr::Vector{Float} : residual values\ny::Vector{Float} : states\nx::Vector{Float} : inputs (to which derivatives are sensitive)\np::Vector{Float} : constants\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.backward_stencil_1","page":"Preprocess","title":"DuctAPE.backward_stencil_1","text":"backward_stencil_1(f, x)\n\nThree-point, backward difference scheme on a non-uniform grid.\n\nArguments:\n\nf::AbstractMatrix{Float} : f(x) for x{i-2}:x{i}\nx::AbstractVector{Float} : [x{i-2}:x{i}]\n\nReturns:\n\nf'(x)::Float : f/x at x_i\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.center_stencil_1","page":"Preprocess","title":"DuctAPE.center_stencil_1","text":"center_stencil_1(f, x)\n\nThree-point, central difference scheme on a non-uniform grid, for first derivatives.\n\nArguments:\n\nf::AbstractMatrix{Float} : f(x) for x{i-1}:x{i+1}\nx::AbstractVector{Float} : [x{i-1}:x{i+1}]\n\nReturns:\n\nf'(x)::Float : f/x at x_i\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.center_stencil_2","page":"Preprocess","title":"DuctAPE.center_stencil_2","text":"center_stencil_2(f, x)\n\nThree-point, central difference scheme on a non-uniform grid, for second derivatives.\n\nArguments:\n\nf::AbstractMatrix{Float} : f(x) for x{i-1}:x{i+1}\nx::AbstractVector{Float} : [x{i-1}:x{i+1}]\n\nReturns:\n\nf''(x)::Float : ^2f/x^2 at x_i\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.center_stencil_2_mixed","page":"Preprocess","title":"DuctAPE.center_stencil_2_mixed","text":"center_stencil_2_mixed(f, x, y)\n\nThree-point, central difference scheme on a non-uniform grid, for mixed derivatives. Uses a consecutive first derivative central difference (center_stencil_1) in the x-dimension then another centeral difference of the f'(x) values in the y-dimension.\n\nArguments:\n\nf::AbstractMatrix{Float} : f(x,y) for x{i-1}:x{i+1} and y{i-1}:y{i+1}\nx::AbstractVector{Float} : [x{i-1}:x{i+1}]\ny::AbstractVector{Float} : [y{i-1}:y{i+1}]\n\nReturns:\n\nf'(x,y)::Float : ^2f/xy at x_ij\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.generate_wake_panels","page":"Preprocess","title":"DuctAPE.generate_wake_panels","text":"generate_wake_panels(wake_grid)\n\nGenerate paneling for each wake sheet emanating from the rotor blade elements.\n\nArguments:\n\nwake_grid::Array{Float,3} : axial and radial locations of each wake_grid point (after relaxation/solution)\n\nReturns:\n\nwake_vortex_panels::NamedTuple : A named tuple of panel values describing the wake vortex panels\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.generate_wake_panels!","page":"Preprocess","title":"DuctAPE.generate_wake_panels!","text":"generate_wake_panels!(wake_panels, wake_grid)\n\nIn-place version of generate_wake_panels.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.get_wake_k","page":"Preprocess","title":"DuctAPE.get_wake_k","text":"get_wake_k(r, nwn)\n\nCalculate geometric constant for use in later calculation of wake panel node strengths.\n\nArguments\n\nr::Vector{Float} : Vector of wake panel node radial positions\n\nReturns\n\nK::Vector{Float} : Vector of geometric constants used in calculation of panel node strengths.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.get_wake_k!","page":"Preprocess","title":"DuctAPE.get_wake_k!","text":"get_wake_k!(K, r)\n\nIn-place version of get_wake_k.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#Bodies","page":"Preprocess","title":"Bodies","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"DuctAPE.reinterpolate_bodies!\nDuctAPE.place_duct!","category":"page"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.reinterpolate_bodies!","page":"Preprocess","title":"DuctAPE.reinterpolate_bodies!","text":"reinterpolate_bodies!(\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    duct_coordinates,\n    centerbody_coordinates,\n    zwake,\n    ncenterbody_inlet,\n    nduct_inlet;\n    finterp=FLOWMath.akima,\n)\n\nReinterpolate duct and centerbody coordinates in order to make them compatible with the calculated wake sheet panel axial positions.\n\nArguments\n\nrp_duct_coordinates::Matrix{Float} : the re-paneled duct coordinates\nrp_centerbody_coordinates::Matrix{Float} : the re-paneled centerbody coordinates\nduct_coordinates::Matrix{Float} : the input duct coordinates\ncenterbody_coordinates::Matrix{Float} : the input centerbody coordinates\nzwake::Matrix{Float} : the wake sheet panel node axial positions\nncenterbody_inlet::Matrix{Float} : the number of panels to use for the centerbody inlet\nnduct_inlet::Matrix{Float} : the number of panels to use for the duct inlet\n\nKeyword Arguments\n\nfinterp::Function=FLOWMath.akima : interpolation method\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.place_duct!","page":"Preprocess","title":"DuctAPE.place_duct!","text":"place_duct!(rp_duct_coordinates, Rtip, rotorzloc, tip_gap)\n\nTransform the duct radial coordinates such that the leading rotor radius touches the duct wall.\n\nNote that this function is called AFTER the repanling function is called, such that the rotorzloc locations should line up directly with the duct and centerbody coordinates.\n\nArguments\n\nrp_duct_coordinates::Matrix{Float} : the re-paneled duct coordinates\nRtip::Vector{Float} : Tip radii for the rotor(s)\nrotorzloc::Vector{Float} : axial position(s) of the rotor(s)\ntip_gap::Vector{Float} : tip gap for the fore-most rotor (MUST BE ZERO for now)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#Rotors","page":"Preprocess","title":"Rotors","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"DuctAPE.interpolate_blade_elements\nDuctAPE.interpolate_blade_elements!\nDuctAPE.get_blade_ends_from_body_geometry\nDuctAPE.get_blade_ends_from_body_geometry!\nDuctAPE.get_local_solidity\nDuctAPE.get_stagger\nDuctAPE.generate_rotor_panels\nDuctAPE.generate_rotor_panels!","category":"page"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.interpolate_blade_elements","page":"Preprocess","title":"DuctAPE.interpolate_blade_elements","text":"interpolate_blade_elements(\n    rsp, Rtips, Rhubs, rotor_panel_centers, nbe; finterp=FLOWMath.linear\n)\n\nInterpolate blade elements based on Rotor inputs and number of desired blade elements (from number of wake sheet in PanelingConstants input)\n\nArguments\n\nrsp::Rotor : A Rotor object\n`Rtips::Vector{Float}' : Vector of rotor tip radii\n`Rhubs::Vector{Float}' : Vector of rotor hub radii\n`rotorpanelcenters::Vector{Float}' : Vector of rotor panel centers\nnbe::Int : number of blade elements per rotor\n\nKeyword Arguments\n\nfinterp::Function=FLOWMath.linear : interpolation method (note, using Akima splines as is done for the body geometry can lead to negative chord in some cases)\n\nReturns\n\nblade_element_cache::NamedTuple : A named tuple containing the cacheable blade element information excluding the airfoil data.\nairfoils::NamedTuple : A named tuple containing vectors of inner and outer airfoil polar data for each blade element, used in interpolating the input data at blade element locations.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.interpolate_blade_elements!","page":"Preprocess","title":"DuctAPE.interpolate_blade_elements!","text":"interpolate_blade_elements!(\n    blade_element_cache, rsp, rotor_panel_centers, nbe; finterp=FLOWMath.linear\n)\n\nIn-place version of interpolate_blade_elements.\n\nReturns\n\nairfoils::NamedTuple : A named tuple containing vectors of inner and outer airfoil polar data for each blade element, used in interpolating the input data at blade element locations.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.get_blade_ends_from_body_geometry","page":"Preprocess","title":"DuctAPE.get_blade_ends_from_body_geometry","text":"get_blade_ends_from_body_geometry(\n    rp_duct_coordinates, rp_centerbody_coordinates, tip_gaps, rotorzloc\n)\n\nObtain rotor hub and tip radii based on duct and centerbody geometry.\n\nArguments\n\nvar::type :\nrp_duct_coordinates::Matrix{Float} : re-paneled duct coordinates\nrp_centerbody_coordinates::Matrix{Float} : re-paneled centerbody coordinates\ntip_gaps::Vector{Float} : gaps between blade tips and duct surface (MUST BE ZEROS for now)\nrotorzloc::Vector{Float} : rotor lifting line axial positions.\n\nReturns\n\nRtips::Vector{Float} : rotor tip radii\nRhubs::Vector{Float} : rotor hub radii\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.get_blade_ends_from_body_geometry!","page":"Preprocess","title":"DuctAPE.get_blade_ends_from_body_geometry!","text":"get_blade_ends_from_body_geometry!(\n    Rtip,\n    Rhub,\n    rp_duct_coordinates,\n    rp_centerbody_coordinates,\n    tip_gaps,\n    rotorzloc;\n    silence_warnings=true,\n)\n\nIn-place version of get_blade_ends_from_body_geometry.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.get_local_solidity","page":"Preprocess","title":"DuctAPE.get_local_solidity","text":"get_local_solidity(B, chord, r)\n\nCalculate local solidity from local chord, radial position, and number of blades.\n\nArguments\n\nB::Float : number of blades on rotor (usually an integer, but not necessarily).\nchord::Vector{Float} : chord lengths at each radial station.\nr::Vector{Float} : dimensional radial positions.\n\nReturns\n\nsolidity::Vector{Float} : local solidity at each radial station\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.get_stagger","page":"Preprocess","title":"DuctAPE.get_stagger","text":"get_stagger(twists)\n\nConvert twist angle to stagger angle\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.generate_rotor_panels","page":"Preprocess","title":"DuctAPE.generate_rotor_panels","text":"generate_rotor_panels(rotorzloc, wake_grid, rotor_indices_in_wake, nwake_sheets)\n\nGenerate rotor panel objects.\n\nArguments\n\nrotorzloc::Vector{Float} : rotor lifting line axial position\nwake_grid::Array{Float,3} : wake elliptic grid axial and radial locations\nrotor_indices_in_wake::Vector{Int} : indices of where along wake the rotors are placed\nnwake_sheets::Int : number of wake sheets\n\nReturns\n\nrotor_source_panels::NamedTuple : A named tuple containing the rotor source panel variables.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.generate_rotor_panels!","page":"Preprocess","title":"DuctAPE.generate_rotor_panels!","text":"generate_rotor_panels!(\n    rotor_source_panels, rotorzloc, wake_grid, rotor_indices_in_wake, nwake_sheets\n)\n\nIn-place version of generate_rotor_panels.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#Induced-Velocities","page":"Preprocess","title":"Induced Velocities","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"DuctAPE.calculate_unit_induced_velocities\nDuctAPE.calculate_unit_induced_velocities!\nDuctAPE.initialize_linear_system\nDuctAPE.initialize_linear_system!","category":"page"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.calculate_unit_induced_velocities","page":"Preprocess","title":"DuctAPE.calculate_unit_induced_velocities","text":"calculate_unit_induced_velocities(problem_dimensions, panels, integration_options)\n\nCalculate all the unit-induced velocties of all panels on all control points\n\nArguments\n\nproblem_dimensions::ProblemDimensions : A ProblemDimensions object\npanels::NamedTuple : A named tuple containing all the paneling information\nintegration_options::IntegrationOptions : Options used for integration of velocity kernals across panels\n\nReturns\n\nivr::NamedTuple : A named tuple containing arrays of induced velocities on the rotors\nivw::NamedTuple : A named tuple containing arrays of induced velocities on the wake\nivb::NamedTuple : A named tuple containing arrays of induced velocities on the bodies\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.calculate_unit_induced_velocities!","page":"Preprocess","title":"DuctAPE.calculate_unit_induced_velocities!","text":"calculate_unit_induced_velocities!(ivr, ivw, ivb, panels, integration_options)\n\nIn-place version of calculate_unit_induced_velocities.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.initialize_linear_system","page":"Preprocess","title":"DuctAPE.initialize_linear_system","text":"initialize_linear_system(\n    ivb,\n    body_vortex_panels,\n    rotor_source_panels,\n    wake_vortex_panels,\n    Vinf,\n    integration_options,\n)\n\nSet up the linear system used in the panel method solve.\n\nArguments\n\nivb::NamedTuple : the named tuple containing all the unit induced velocities on the bodies\nbody_vortex_panels::NamedTuple : the named tuple containing the body vortex panel information\nrotor_source_panels::NamedTuple : the named tuple containing the rotor source panel information\nwake_vortex_panels::NamedTuple : the named tuple containing the wake vortex panel information\nVinf::Vector{Float} : the one-element vector containing the Freestream velocity magnitude\nintegration_options::IntegrationOptions : the integration options used in integrating the panel induced velocities\n\nReturns\n\nlinsys::NamedTuple : A named tuple containing cacheable data for the linear system, including:\nA_bb::Array{Float} : AIC (LHS) matrix for the panel method system\nb_bf::Array{Float} : Initial system RHS vector based on freestrem magnitude\nA_br::Array{Float} : Unit normal velocity from rotors onto body panels\nA_pr::Array{Float} : Unit normal velocity from rotors onto body internal psuedo control points\nA_bw::Array{Float} : Unit normal velocity from wake onto body panels\nA_pw::Array{Float} : Unit normal velocity from wake onto body internal psuedo control points\nA_bb_LU::LinearAlgebra.LU : LinearAlgebra LU factorization of the LHS matrix\nlu_decomp_flag::Vector{Bool} : flag for whether factorization was successful\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.initialize_linear_system!","page":"Preprocess","title":"DuctAPE.initialize_linear_system!","text":"initialize_linear_system!(\n    linsys,\n    ivb,\n    body_vortex_panels,\n    rotor_source_panels,\n    wake_vortex_panels,\n    Vinf,\n    intermediate_containers,\n    integration_options,\n)\n\nIn-place version of initialize_linear_system.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#Unit-Induced-Velocities","page":"Preprocess","title":"Unit Induced Velocities","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"DuctAPE.calculate_xrm\nDuctAPE.calculate_xrm!\nDuctAPE.get_elliptics\nDuctAPE.vortex_ring_vz\nDuctAPE.vortex_ring_vz!\nDuctAPE.smoke_ring_vz\nDuctAPE.vortex_ring_vr\nDuctAPE.vortex_ring_vr!\nDuctAPE.source_ring_vz\nDuctAPE.source_ring_vz!\nDuctAPE.source_ring_vr\nDuctAPE.source_ring_vr!","category":"page"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.calculate_xrm","page":"Preprocess","title":"DuctAPE.calculate_xrm","text":"calculate_xrm(controlpoint, node)\n\nCalculate xi, rho, and m for vortex and/or source ring induced velocity calculation.\n\nReturns zeros if ring is on (or approximately on) the axis of rotation (zero radius).\n\nArguments\n\ncontrolpoint::Vector{Float} [z r] coordinates of point being influenced\nnode::Vector{Float} : [z r] coordinates of singularity ring\n\nReturns\n\nxi::Float : normalized relative axial position\nrho::Float : normalized relative radial position\nm::Float : Elliptic integral input\nrj::Float : radial position of the ring\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.calculate_xrm!","page":"Preprocess","title":"DuctAPE.calculate_xrm!","text":"calculate_xrm!(cache_vec, controlpoint, node)\n\nIn-place version of calculate_xrm.\n\nCache_vec is a vector used to hold intermediate values as well as the outputs.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.get_elliptics","page":"Preprocess","title":"DuctAPE.get_elliptics","text":"get_elliptics(m)\n\nCalculate value of elliptic functions for the given geometry parameter.\n\nArguments\n\nm::Float : Elliptic Function parameter\n\nReturns\n\nK::Float : K(m), value of elliptic function of the first kind at m.\nE::Float : E(m), value of eeliptic function of the second kind at m.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.vortex_ring_vz","page":"Preprocess","title":"DuctAPE.vortex_ring_vz","text":"vortex_ring_vz(xi, rho, m, r_influence, influence_length)\n\nAxial velocity induced by axisymmetric vortex ring.\n\nUses equivalent smoke ring induced velocity for self-induction, and returns zero if vortex ring is on axis of rotation (zero radius).\n\nArguments\n\nxi::Float : normalized z-coordinate, (z-zo)/ro\nrho::Float : normalized r-coordinate, r/ro\nm::Float : Elliptic Integral parameter, 4rho/sqrt(xi^2+(rho+1)^2)\nr_influence::Float : radial location of vortex ring, ro\ninfluence_length::Float : length of panel used in calculating self-induction\n\nReturns\n\nvz::Float : axially induced velocity of vortex ring\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.vortex_ring_vz!","page":"Preprocess","title":"DuctAPE.vortex_ring_vz!","text":"vortex_ring_vz!(xi, rho, m, r_influence, influence_length, cache_vec)\n\nSame as vortexringvz, but uses the cache_vec to store intermediate calculations.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.smoke_ring_vz","page":"Preprocess","title":"DuctAPE.smoke_ring_vz","text":"smoke_ring_vz(r_influence, influence_length)\n\nEquivalent \"smoke\" ring self-induced velocity.\n\nArguments\n\nr_influence::Float : radial position of ring (i.e. the ring raidus)\ninfluence_length::Float : length of influencing panel\n\nReturs\n\nvz::Float : axially induced velocity of vortex ring\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.vortex_ring_vr","page":"Preprocess","title":"DuctAPE.vortex_ring_vr","text":"vortex_ring_vr(xi, rho, m, r_influence)\n\nRadial velocity induced by axisymmetric vortex ring.\n\nReturns zero if vortex ring is on axis of rotation (zero radius), the point of influence is on the axis, or if self-inducing velocity.\n\nArguments\n\nxi::Float : normalized z-coordinate, (z-zo)/ro\nrho::Float : normalized r-coordinate, r/ro\nm::Float : Elliptic Integral parameter, 4rho/sqrt(xi^2+(rho+1)^2)\nr_influence::Float : radial location of vortex ring, ro\n\nReturns\n\nvr::Float : radially induced velocity of vortex ring\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.vortex_ring_vr!","page":"Preprocess","title":"DuctAPE.vortex_ring_vr!","text":"vortex_ring_vr!(xi, rho, m, r_influence, cache_vec)\n\nSame as vortexringvr, but uses the cache_vec to store intermediate calculations.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.source_ring_vz","page":"Preprocess","title":"DuctAPE.source_ring_vz","text":"source_ring_vz(xi, rho, m, r_influence)\n\nAxial velocity induced by axisymmetric source ring.\n\nReturns zero if source ring is on axis of rotation (zero radius), the point of influence is on the axis, or if self-inducing velocity.\n\nArguments:\n\nxi::Float : normalized z-coordinate, (z-zo)/ro\nrho::Float : normalized r-coordinate, r/ro\nm::Float : Elliptic Integral parameter, 4rho/sqrt(xi^2+(rho+1)^2)\nr_influence::Float : radial location of vortex ring, ro\n\nReturns:\n\nvz::Float : axially induced velocity of source ring\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.source_ring_vz!","page":"Preprocess","title":"DuctAPE.source_ring_vz!","text":"source_ring_vz!(xi, rho, m, r_influence, cache_vec)\n\nSame as sourceringvz, but uses cache_vec to store intermediate values.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.source_ring_vr","page":"Preprocess","title":"DuctAPE.source_ring_vr","text":"source_ring_vr(xi, rho, m, r_influence)\n\nRadial velocity induced by axisymmetric source ring.\n\nReturns zero if source ring is on axis of rotation (zero radius), the point of influence is on the axis, or if self-inducing velocity.\n\nArguments:\n\nxi::Float : normalized z-coordinate, (z-zo)/ro\nrho::Float : normalized r-coordinate, r/ro\nm::Float : Elliptic Integral parameter, 4rho/sqrt(xi^2+(rho+1)^2)\nr_influence::Float : radial location of vortex ring, ro\n\nReturns:\n\nvr::Float : radially induced velocity of source ring\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.source_ring_vr!","page":"Preprocess","title":"DuctAPE.source_ring_vr!","text":"source_ring_vr!(xi, rho, m, r_influence, cache_vec)\n\nSame as sourceringvr, but uses cache_vec to store intermediate values.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#Unit-Induced-Velocity-Matrices","page":"Preprocess","title":"Unit Induced Velocity Matrices","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"DuctAPE.induced_velocities_from_vortex_panels_on_points\nDuctAPE.induced_velocities_from_vortex_panels_on_points!\nDuctAPE.induced_velocities_from_source_panels_on_points\nDuctAPE.induced_velocities_from_source_panels_on_points!\nDuctAPE.induced_velocities_from_trailing_edge_gap_panel!","category":"page"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.induced_velocities_from_vortex_panels_on_points","page":"Preprocess","title":"DuctAPE.induced_velocities_from_vortex_panels_on_points","text":"induced_velocities_from_vortex_panels_on_points(\n    controlpoints,\n    nodes,\n    nodemap,\n    influence_lengths,\n    integration_options;\n    integration_caches=nothing,\n)\n\nCalculate axial and radial components of induced velocity for a set of control points due to a set of axisymmetric vortex panels (bands).\n\nUsed for getting the unit induced velocities due to the body panels on the rotor/wake as well as the unit induced velocity due to the wake on the body/rotor.\n\nArguments\n\ncontrolpoints::Matrix{Float} [z r] coordinates of points being influenced\nnodes::Matrix{Float} : [z r] coordinates of vortex rings\nnodemap::Matrix{Int} : mapping from panel index to associated node indices\ninfluence_lengths::Vector{Float} : lengths over which vortex ring influence is applied on the surface.\nintegration_options::IntegrationOptions : integration options\n\nKeyword Arguments\n\nintegration_caches::NamedTuple=nothing : cache used in in-place quadrature functions.\n\nReturns\n\nVEL::Array{Float} : N-controlpoint x N-node x [vz, vr] array of induced velocity components\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.induced_velocities_from_vortex_panels_on_points!","page":"Preprocess","title":"DuctAPE.induced_velocities_from_vortex_panels_on_points!","text":"induced_velocities_from_vortex_panels_on_points!(\n    VEL,\n    controlpoint,\n    node,\n    nodemap,\n    influence_length,\n    integration_options;\n    integration_caches=nothing,\n)\n\nIn-place version of induced_velocities_from_vortex_panels_on_points.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.induced_velocities_from_source_panels_on_points","page":"Preprocess","title":"DuctAPE.induced_velocities_from_source_panels_on_points","text":"induced_velocities_from_source_panels_on_points(\n    controlpoints,\n    nodes,\n    nodemap,\n    influence_lengths,\n    integration_options;\n    integration_caches=nothing,\n)\n\nCalculate axial and radial components of induced velocity for a set of control points due to a set of axisymmetric source panels (bands)\n\nUsed for getting the unit induced velocities due to the body panels on the rotor/wake as well as the unit induced velocity due to the wake on the body/rotor.\n\nArguments\n\ncontrolpoints::Matrix{Float} [z r] coordinates of points being influenced\nnodes::Matrix{Float} : [z r] coordinates of vortex rings\nnodemap::Matrix{Int} : mapping from panel index to associated node indices\ninfluence_lengths::Vector{Float} : lengths over which vortex ring influence is applied on the surface.\nintegration_options::IntegrationOptions : integration options\n\nReturns:\n\nVEL::Array{Float} : N-controlpoint x N-node x [vz, vr] array of induced velocity components\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.induced_velocities_from_source_panels_on_points!","page":"Preprocess","title":"DuctAPE.induced_velocities_from_source_panels_on_points!","text":"induced_velocities_from_source_panels_on_points!(\n    VEL,\n    controlpoint,\n    node,\n    nodemap,\n    influence_length,\n    integration_options;\n    integration_caches=nothing,\n)\n\nIn-place version of induced_velocities_from_source_panels_on_points.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.induced_velocities_from_trailing_edge_gap_panel!","page":"Preprocess","title":"DuctAPE.induced_velocities_from_trailing_edge_gap_panel!","text":"induced_velocities_from_trailing_edge_gap_panel!(\n    VEL,\n    controlpoint,\n    tenode,\n    teinfluence_length,\n    tendotn,\n    tencrossn,\n    teadjnodeidxs,\n    integration_options;\n    wake=false,\n    integration_caches=nothing,\n)\n\nCalculate axial and radial components of induced velocity for a set of control points due to any trailing edge gap panels.\n\nUsed for getting the unit induced velocities due to the body body trailing edge gap panels on the body/rotor/wake.\n\nNote, this function is also used to calculate the influence of the wake ends rather than modeling a semi-infinite fortex sheet.\n\nArguments\n\nVEL::Array{Float} : N-controlpoint x N-node x [vz, vr] array of induced velocity components (modified in place)\ncontrolpoints::Matrix{Float} [z r] coordinates of points being influenced\nnodes::Matrix{Float} : [z r] coordinates of vortex rings\nnodemap::Matrix{Int} : mapping from panel index to associated node indices\ninfluence_lengths::Vector{Float} : lengths over which vortex ring influence is applied on the surface.\nstrengths::Matrix{Float} : vortex constant circulation values\nintegration_options::IntegrationOptions : integration options\n\nKeyword Arguments\n\nwake::Bool=false : flag to indicate if this is being used for a wake sheet.\nintegration_caches::NamedTuple=nothing : cache used in in-place quadrature functions.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#Panel-Method-Velocity-Functions","page":"Preprocess","title":"Panel Method Velocity Functions","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"DuctAPE.vortex_aic_boundary_on_boundary\nDuctAPE.vortex_aic_boundary_on_boundary!\nDuctAPE.vortex_aic_boundary_on_field\nDuctAPE.vortex_aic_boundary_on_field!\nDuctAPE.add_kutta!\nDuctAPE.add_te_gap_aic!\nDuctAPE.source_aic\nDuctAPE.source_aic!\nDuctAPE.freestream_influence_vector\nDuctAPE.freestream_influence_vector!\nDuctAPE.assemble_lhs_matrix\nDuctAPE.assemble_lhs_matrix!\nDuctAPE.factorize_LHS\nDuctAPE.factorize_LHS!\nDuctAPE.assemble_rhs_matrix\nDuctAPE.assemble_rhs_matrix!\nDuctAPE.calculate_normal_velocity\nDuctAPE.calculate_normal_velocity!","category":"page"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.vortex_aic_boundary_on_boundary","page":"Preprocess","title":"DuctAPE.vortex_aic_boundary_on_boundary","text":"vortex_aic_boundary_on_boundary(\n    controlpoint, normal, node, nodemap, influence_length, integration_options\n)\n\nCalculate panel method influence coefficients (V dot nhat) for a set of control points (on panels) due to a set of axisymmetric vortex rings (also on body surface)\n\nCan be used for constructing the LHS influence Matrix for the panel method system.\n\nArguments\n\ncontrolpoint::Matrix{Float} [z r] coordinates of points being influenced\nnormal::Matrix{Float} : unit normal vectors of the panels on which the control points are situated.\nnode::Matrix{Float} : [z r] coordinates of panel nodes (edges)\nnodemap::Matrix{Int} : [1 2] node indices for each panel\ninfluence_length::Vector{Float} : lengths of influencing panels\nintegration_options::IntegrationOptions : integration options\n\nReturns\n\nAICn::Matrix{Float} : N controlpoint x N+1 node  array of V dot nhat values\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.vortex_aic_boundary_on_boundary!","page":"Preprocess","title":"DuctAPE.vortex_aic_boundary_on_boundary!","text":"vortex_aic_boundary_on_boundary!(\n    AICn,\n    controlpoint,\n    normal,\n    node,\n    nodemap,\n    influence_length,\n    integration_options;\n    integration_caches=nothing,\n)\n\nIn-place verion of vortex_aic_boundary_on_boundary.\n\nintegration_caches is a named tuple containing caching for intermediate calculation values.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.vortex_aic_boundary_on_field","page":"Preprocess","title":"DuctAPE.vortex_aic_boundary_on_field","text":"vortex_aic_boundary_on_field(\n    controlpoint,\n    normal,\n    node,\n    nodemap,\n    influence_length,\n    integration_options;\n    integration_caches=nothing,\n)\n\nCalculate panel method influence coefficients (V dot nhat) for a set of control points (NOT on panels) due to a set of axisymmetric vortex rings (on body surface)\n\nUsed for constructing portions of the panel method LHS matrix related to the pseudo control points in the bodies.\n\nArguments:\n\ncontrolpoint::Matrix{Float} [z r] coordinates of points being influenced\nnormal::Matrix{Float} : unit normal vectors of the panels on which the control points are situated.\nnode::Matrix{Float} : [z r] coordinates of panel nodes (edges)\nnodemap::Matrix{Int} : [1 2] node indices for each panel\ninfluence_length::Vector{Float} : lengths of influencing panels\nintegration_options::IntegrationOptions : integration options\n\nKeyword Arguments\n\nintegration_caches::NamedTuple=nothing : caches for intermediate values in integration.\n\nReturns:\n\nAICn::Matrix{Float} : N controlpoint x N+1 node  array of V dot nhat values\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.vortex_aic_boundary_on_field!","page":"Preprocess","title":"DuctAPE.vortex_aic_boundary_on_field!","text":"vortex_aic_boundary_on_field!(\n    AICn,\n    controlpoint,\n    normal,\n    node,\n    nodemap,\n    influence_length,\n    integration_options;\n    integration_caches=nothing,\n)\n\nIn-place version of vortex_aic_boundary_on_field.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.add_kutta!","page":"Preprocess","title":"DuctAPE.add_kutta!","text":"add_kutta!(LHS, AICn, kids)\n\nAdd Kutta condition (1 + N = 0) to LHS matrix.\n\nLHS::Matrix{Float} : a pre-allocated (zeros) full size left-hand side matrix\nAICn::Matrix{Float} :  influence coefficients for panels/nodes\nkids::Vector{Int} : [1 2] indices of where to put 1's for kutta condition\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.add_te_gap_aic!","page":"Preprocess","title":"DuctAPE.add_te_gap_aic!","text":"add_te_gap_aic!(\n    AICn,\n    controlpoint,\n    normal,\n    tenode,\n    teinfluence_length,\n    tendotn,\n    tencrossn,\n    teadjnodeidxs,\n    integration_options;\n    wake=false,\n    integration_caches=nothing,\n)\n\nAdd trailing edge gap aerodynmic influence coefficient contributions to the AIC matrix.\n\nArguments\n\nAICn::Matrix{Float} : N controlpoint x N+1 node  array of V dot nhat values\ncontrolpoint::Matrix{Float} [z r] coordinates of points being influenced\nnormal::Matrix{Float} : unit normal vectors of the panels on which the control points are situated.\ntenode::Matrix{Float} : [z r] coordinates of trailing edge panel nodes (edges)\nteinfluence_length::Vector{Float} : lengths of influencing trailing edge panels\ntendotn::Matrix{Float} : nhat of trailing edge panel dotted with nhat of adjacent panels\ntencrossn::Matrix{Float} : nhat of trailing edge panel crossed with nhat of adjacent panels\nteadjnodeidxs::Matrix{Float} : indices of nodes adjacent to trailing edge panel\nintegration_options::IntegrationOptions : integration options\n\nKeyword Arguments\n\nwake::Bool=false : flag as to whether this function is being applied to a wake sheet.\nintegration_caches::NamedTuple=nothing : caches for intermediate values in integration.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.source_aic","page":"Preprocess","title":"DuctAPE.source_aic","text":"source_aic(\n    controlpoint,\n    normal,\n    node,\n    nodemap,\n    influence_length,\n    integration_options;\n    integration_caches=nothing,\n)\n\nCalculate panel method influence coefficients (V dot nhat) for a set of control points (on panels) due to a set of axisymmetric source rings not on body surface.\n\nCan be used for constructing the RHS boundary conditions due to rotor source panels.\n\nArguments\n\ncontrolpoint::Matrix{Float} [z r] coordinates of points being influenced\nnormal::Matrix{Float} : unit normal vectors of the panels on which the control points are situated.\nnode::Matrix{Float} : [z r] coordinates of panel nodes (edges)\nnodemap::Matrix{Int} : [1 2] node indices for each panel\ninfluence_length::Vector{Float} : lengths of influencing panels\nintegration_options::IntegrationOptions : integration options\n\nKeyword Arguments\n\nintegration_caches::NamedTuple=nothing : caches for intermediate values in integration.\n\nReturns\n\nAICn::Matrix{Float} : N controlpoint x N+1 node  array of V dot nhat values\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.source_aic!","page":"Preprocess","title":"DuctAPE.source_aic!","text":"source_aic!(\n    AICn,\n    controlpoint,\n    normal,\n    node,\n    nodemap,\n    influence_length,\n    integration_options;\n    integration_caches=nothing,\n)\n\nIn-place version of source_aic.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.freestream_influence_vector","page":"Preprocess","title":"DuctAPE.freestream_influence_vector","text":"freestream_influence_vector(normals, Vinfmat)\n\nCalculate RHS contributions due to freestream.\n\nNote that the freestream is assumed to have zero radial component in the underlying theory, but here we allow an arbitrary 2D vector for velocity for taking the dot product easier.\n\nArguments\n\nnormals::Matrix{Float} : unit normal vectors of the panels on which the control points are situated.\nVinfmat::Matrix{Float} : [z r] components of freestream velocity (r's should be zero)\n\nReturns\n\nRHS::Vector{Float} : vector of normal components of freestream velocity on input panels\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.freestream_influence_vector!","page":"Preprocess","title":"DuctAPE.freestream_influence_vector!","text":"freestream_influence_vector!(RHS, normals, Vinfmat)\n\nIn-place version of freestream_influence_vector.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.assemble_lhs_matrix","page":"Preprocess","title":"DuctAPE.assemble_lhs_matrix","text":"assemble_lhs_matrix(\n    AICn, AICpcp, npanel, nnode, totpanel, totnode, prescribednodeidxs; dummyval=1.0\n)\n\nAssemble the LHS matrix of the panel method.\n\nArguments\n\nAICn::Matrix{Float} : N controlpoint x N+1 node  array of V dot nhat values\nAICpcp::Matrix{Float} : Nbodies controlpoint x N+1 node  array of V dot nhat values (influence on psuedo control points)\nnpanel::Vector{Int} : number of panels comprising each body\nnnode::Vector{Int} : number of nodes comprising each body\ntotpanel::Int : total number of panels\ntotnode::Int : total number of nodes\nprescribednodeidxs::Vector{Int} : indices of nodes with prescribed strengths (those on the axis of rotation).\n\nKeyword Arguments\n\ndummyval::Float=1.0 : value for dummy input for prescribed and internal control points in the system. Do not change except for debugging purposes.\n\nReturns\n\nLHS::Matrix{Float} : The full LHS matrix for the panel method.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.assemble_lhs_matrix!","page":"Preprocess","title":"DuctAPE.assemble_lhs_matrix!","text":"assemble_lhs_matrix!(\n    LHS, AICn, AICpcp, npanel, nnode, totpanel, totnode, prescribednodeidxs; dummyval=1.0\n)\n\nIn-place version of assemble_lhs_matrix.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.factorize_LHS","page":"Preprocess","title":"DuctAPE.factorize_LHS","text":"factorize_LHS(A::AbstractMatrix)\n\nReturns the LU decomposition of A.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.factorize_LHS!","page":"Preprocess","title":"DuctAPE.factorize_LHS!","text":"factorize_LHS!(Apivot::AbstractMatrix, A::AbstractMatrix)\n\nReturns the LU decomposition of A using Apivot as storage memory to pivot leaving A unchanged.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.assemble_rhs_matrix","page":"Preprocess","title":"DuctAPE.assemble_rhs_matrix","text":"assemble_rhs_matrix(\n    vdnb, vdnpcp, npanel, nnode, totpanel, totnode, prescribednodeidxs\n)\n\nArguments\n\nvdnb::Vector{Float} : V dot nhat for body panels\nvdnpcp::Vector{Float} : V dot nhat for pseudo control points\nnpanel::Vector{Int} : number of panels comprising each body\nnnode::Vector{Int} : number of nodes comprising each body\ntotpanel::Int : total number of body panels\ntotnode::Int : total number of body nodes\nprescribednodeidxs::Vector{Int} : indices of nodes with prescribed strengths (those on the axis of rotation)\n\nReturns\n\nRHS::Vector{Float} : the RHS vector of the panel method.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.assemble_rhs_matrix!","page":"Preprocess","title":"DuctAPE.assemble_rhs_matrix!","text":"assemble_rhs_matrix!(\n    RHS, vdnb, vdnpcp, npanel, nnode, totpanel, totnode, prescribednodeidxs\n)\n\nIn-place version of assemble_rhs_matrix.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.calculate_normal_velocity","page":"Preprocess","title":"DuctAPE.calculate_normal_velocity","text":"calculate_normal_velocity(velocity_vector, normal)\n\nCalculate normal velocity_vector (V dot nhat).\n\nArguments\n\nvelocity_vector::Matrix{Float} : velocity vector [z r] on each panel\nnormal::Matrix{Float} : the panel unit normals\n\nReturns\n\nAIC::Matrix{Float} : V dot n on each panel\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.calculate_normal_velocity!","page":"Preprocess","title":"DuctAPE.calculate_normal_velocity!","text":"calculate_normal_velocity!(AIC, velocity_vector, normal)\n\nIn-place version of calculate_normal_velocity.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#Quadrature","page":"Preprocess","title":"Quadrature","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/#Integrands","page":"Preprocess","title":"Integrands","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"DuctAPE.nominal_vortex_induced_velocity_sample\nDuctAPE.nominal_vortex_induced_velocity_sample!\nDuctAPE.subtracted_singular_vortex_influence\nDuctAPE.subtracted_singular_vortex_influence!\nDuctAPE.analytically_integrated_vortex_influence\nDuctAPE.analytically_integrated_vortex_influence!\nDuctAPE.self_vortex_induced_velocity_sample\nDuctAPE.self_vortex_induced_velocity_sample!\nDuctAPE.nominal_source_induced_velocity_sample\nDuctAPE.nominal_source_induced_velocity_sample!\nDuctAPE.subtracted_singular_source_influence\nDuctAPE.subtracted_singular_source_influence!\nDuctAPE.analytically_integrated_source_influence\nDuctAPE.analytically_integrated_source_influence!\nDuctAPE.self_source_induced_velocity_sample\nDuctAPE.self_source_induced_velocity_sample!","category":"page"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.nominal_vortex_induced_velocity_sample","page":"Preprocess","title":"DuctAPE.nominal_vortex_induced_velocity_sample","text":"nominal_vortex_induced_velocity_sample(\n    t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nCalculate the velocity induced by a linear vortex panel on a point.\n\nArguments\n\nt::Float : sample point in range (0,1) selected by quadrature method.\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncache_vec::Vector{Float} : cache for intermediate calculations\n\nKeyword Arguments\n\nnondimrange::Tuple=(0.0,1.0) : Non-dimensional range describing the panel length.  Do not change excpet for debugging purposes. Note, can also be a vector.\n\nReturns\n\nV::Matrix{Float} : 2x2 matrix of axial and radial induced velocities from each of the nodes.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.nominal_vortex_induced_velocity_sample!","page":"Preprocess","title":"DuctAPE.nominal_vortex_induced_velocity_sample!","text":"nominal_vortex_induced_velocity_sample!(\n    V, t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nIn-place version of nominal_vortex_induced_velocity_sample.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.subtracted_singular_vortex_influence","page":"Preprocess","title":"DuctAPE.subtracted_singular_vortex_influence","text":"subtracted_singular_vortex_influence(node, controlpoint)\n\nCalculate the singular portions of the self-induced vortex panel influence to subtract off the integral in the separation of singularity method.\n\nArguments\n\nnode::Vector{Float} : node position\ncontrolpoint::Vector{Float} : controlpoint position\n\nReturns\n\naxial::Float : axial direction influence\nradial::Float : radial direction influence\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.subtracted_singular_vortex_influence!","page":"Preprocess","title":"DuctAPE.subtracted_singular_vortex_influence!","text":"subtracted_singular_vortex_influence!(node, controlpoint, cache_vec)\n\nSomewhat in-place version of subtracted_singular_vortex_influence.\n\nArguments\n\nnode::Vector{Float} : node position\ncontrolpoint::Vector{Float} : controlpoint position\ncache_vec::Vector{Float} : used to store intermediate values.\n\nReturns\n\naxial::Float : axial direction influence\nradial::Float : radial direction influence\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.analytically_integrated_vortex_influence","page":"Preprocess","title":"DuctAPE.analytically_integrated_vortex_influence","text":"analytically_integrated_vortex_influence(r, influence_length)\n\nAnalytical approximation of the singular portions of the self-induced vortex panel velocities to be added back in as part of the separation of singularity method.\n\nArguments\n\nr::Float : radial position of self-induced control point\ninfluence_length::Float : dimensional length of the panel\n\nReturns\n\nV::Vector{Float} : axial and radial induced velocities\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.analytically_integrated_vortex_influence!","page":"Preprocess","title":"DuctAPE.analytically_integrated_vortex_influence!","text":"analytically_integrated_vortex_influence!(V, r, influence_length)\n\nIn-place version of analytically_integrated_vortex_influence.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.self_vortex_induced_velocity_sample","page":"Preprocess","title":"DuctAPE.self_vortex_induced_velocity_sample","text":"self_vortex_induced_velocity_sample(\n    t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nCalculate the velocity induced by a linear vortex panel on a point at the midpoint between the panel edges.\n\nArguments\n\nt::Float : sample point in range (0,1) selected by quadrature method.\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncache_vec::Vector{Float} : cache for intermediate calculations\n\nKeyword Arguments\n\nnondimrange::Tuple=(0.0,1.0) : Non-dimensional range describing the panel length.  Do not change excpet for debugging purposes. Note, can also be a vector.\n\nReturns\n\nV::Matrix{Float} : 2x2 matrix of axial and radial induced velocities from each of the nodes.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.self_vortex_induced_velocity_sample!","page":"Preprocess","title":"DuctAPE.self_vortex_induced_velocity_sample!","text":"self_vortex_induced_velocity_sample!(\n    V, t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nIn-place version of self_vortex_induced_velocity_sample.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.nominal_source_induced_velocity_sample","page":"Preprocess","title":"DuctAPE.nominal_source_induced_velocity_sample","text":"nominal_source_induced_velocity_sample(\n    t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nCalculate the velocity induced by a source panel on a point.\n\nArguments\n\nt::Float : sample point in range (0,1) selected by quadrature method.\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncache_vec::Vector{Float} : cache for intermediate calculations\n\nKeyword Arguments\n\nnondimrange::Tuple=(0.0,1.0) : Non-dimensional range describing the panel length.  Do not change excpet for debugging purposes. Note, can also be a vector.\n\nReturns\n\nV::Matrix{Float} : 2x2 matrix of axial and radial induced velocities from each of the nodes.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.nominal_source_induced_velocity_sample!","page":"Preprocess","title":"DuctAPE.nominal_source_induced_velocity_sample!","text":"nominal_source_induced_velocity_sample!(\n    V, t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0,1.0)\n)\n\nIn-place version of nominal_source_induced_velocity_sample.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.subtracted_singular_source_influence","page":"Preprocess","title":"DuctAPE.subtracted_singular_source_influence","text":"subtracted_singular_source_influence(node, controlpoint)\n\nCalculate the singular portions of the self-induced source panel influence to subtract off the integral in the separation of singularity method.\n\nArguments\n\nnode::Vector{Float} : node position\ncontrolpoint::Vector{Float} : controlpoint position\n\nReturns\n\naxial::Float : axial direction influence\nradial::Float : radial direction influence\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.subtracted_singular_source_influence!","page":"Preprocess","title":"DuctAPE.subtracted_singular_source_influence!","text":"subtracted_singular_source_influence!(node, controlpoint, cache_vec)\n\nIn-place version of subtracted_singular_source_influence.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.analytically_integrated_source_influence","page":"Preprocess","title":"DuctAPE.analytically_integrated_source_influence","text":"analytically_integrated_source_influence(r, influence_length)\n\nIn-place version of analytically_integrated_source_influence.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.analytically_integrated_source_influence!","page":"Preprocess","title":"DuctAPE.analytically_integrated_source_influence!","text":"analytically_integrated_source_influence(r, influence_length)\n\nAnalytical approximation of the singular portions of the self-induced source panel velocities to be added back in as part of the separation of singularity method.\n\nArguments\n\nr::Float : radial position of self-induced control point\ninfluence_length::Float : dimensional length of the panel\n\nReturns\n\nV::Vector{Float} : axial and radial induced velocities\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.self_source_induced_velocity_sample","page":"Preprocess","title":"DuctAPE.self_source_induced_velocity_sample","text":"self_source_induced_velocity_sample(\n    t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nCalculate the velocity induced by a linear source panel on a point at the midpoint between the panel edges.\n\nArguments\n\nt::Float : sample point in range (0,1) selected by quadrature method.\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncache_vec::Vector{Float} : cache for intermediate calculations\n\nKeyword Arguments\n\nnondimrange::Tuple=(0.0,1.0) : Non-dimensional range describing the panel length.  Do not change excpet for debugging purposes. Note, can also be a vector.\n\nReturns\n\nV::Matrix{Float} : 2x2 matrix of axial and radial induced velocities from each of the nodes.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.self_source_induced_velocity_sample!","page":"Preprocess","title":"DuctAPE.self_source_induced_velocity_sample!","text":"self_source_induced_velocity_sample!(\n    V, t, node1, node2, influence_length, controlpoint, cache_vec; nondimrange=(0.0, 1.0)\n)\n\nIn-place version of self_source_induced_velocity_sample.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#Integrals","page":"Preprocess","title":"Integrals","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"DuctAPE.nominal_vortex_panel_integration\nDuctAPE.nominal_vortex_panel_integration!\nDuctAPE.self_vortex_panel_integration\nDuctAPE.self_vortex_panel_integration!\nDuctAPE.nominal_source_panel_integration\nDuctAPE.nominal_source_panel_integration!\nDuctAPE.self_source_panel_integration\nDuctAPE.self_source_panel_integration!\nDuctAPE.extrapolate!","category":"page"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.nominal_vortex_panel_integration","page":"Preprocess","title":"DuctAPE.nominal_vortex_panel_integration","text":"nominal_vortex_panel_integration(\n    integration_options,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIntegration of vortex panel induced velocity on a point far away.\n\nArguments\n\nintegration_options::IntegrationMethod : options for itegration methods\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncontainers::NamedTuple : cache for intermediate calculations\n\nKeyword Arguments\n\ndebug::Bool=false : if true, some methods will return the estimation error.\n\nReturns\n\nV::Matrix{Float} : velocity components due to the jth and j+1th nodes in the format: [vz_j vr_j; vz_{j+1} vr_{j+1}]\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.nominal_vortex_panel_integration!","page":"Preprocess","title":"DuctAPE.nominal_vortex_panel_integration!","text":"nominal_vortex_panel_integration!(\n    integration_options,\n    V,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIn-place version of nominal_vortex_panel_integration.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.self_vortex_panel_integration","page":"Preprocess","title":"DuctAPE.self_vortex_panel_integration","text":"self_vortex_panel_integration(\n    integration_options,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIntegration of linear vortex panel self-induced velocity.\n\nArguments\n\nintegration_options::IntegrationMethod : options for itegration methods\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncontainers::NamedTuple : cache for intermediate calculations\n\nKeyword Arguments\n\ndebug::Bool=false : if true, some methods will return the estimation error.\n\nReturns\n\nV::Matrix{Float} : velocity components due to the jth and j+1th nodes in the format: [vz_j vr_j; vz_{j+1} vr_{j+1}]\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.self_vortex_panel_integration!","page":"Preprocess","title":"DuctAPE.self_vortex_panel_integration!","text":"self_vortex_panel_integration!(\n    integration_options,\n    V,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIn-place version of self_vortex_panel_integration.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.nominal_source_panel_integration","page":"Preprocess","title":"DuctAPE.nominal_source_panel_integration","text":"nominal_source_panel_integration(\n    integration_options,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIntegration of source panel induced velocity on a point far away.\n\nArguments\n\nintegration_options::IntegrationMethod : options for itegration methods\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncontainers::NamedTuple : cache for intermediate calculations\n\nKeyword Arguments\n\ndebug::Bool=false : if true, some methods will return the estimation error.\n\nReturns\n\nV::Matrix{Float} : velocity components due to the jth and j+1th nodes in the format: [vz_j vr_j; vz_{j+1} vr_{j+1}]\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.nominal_source_panel_integration!","page":"Preprocess","title":"DuctAPE.nominal_source_panel_integration!","text":"nominal_source_panel_integration!(\n    integration_options,\n    V,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIn-place version of nominal_source_panel_integration.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.self_source_panel_integration","page":"Preprocess","title":"DuctAPE.self_source_panel_integration","text":"self_source_panel_integration(\n    integration_options,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIntegration of linear source panel self-induced velocity.\n\nArguments\n\nintegration_options::IntegrationMethod : options for itegration methods\nnode1::Vector{Float} : first panel node (edge) position.\nnode2::Vector{Float} : second panel node (edge) position.\ninfluence_length::Float : dimensional length of panel.\ncontrolpoint::Vector{Float} : controlpoint position\ncontainers::NamedTuple : cache for intermediate calculations\n\nKeyword Arguments\n\ndebug::Bool=false : if true, some methods will return the estimation error.\n\nReturns\n\nV::Matrix{Float} : velocity components due to the jth and j+1th nodes in the format: [vz_j vr_j; vz_{j+1} vr_{j+1}]\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.self_source_panel_integration!","page":"Preprocess","title":"DuctAPE.self_source_panel_integration!","text":"self_source_panel_integration!(\n    integration_options,\n    V,\n    node1,\n    node2,\n    influence_length,\n    controlpoint,\n    containers;\n    debug=false,\n)\n\nIn-place version of self_source_panel_integration.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.extrapolate!","page":"Preprocess","title":"DuctAPE.extrapolate!","text":"extrapolate!(V, err, fh; power=2, atol=1e-6)\n\nPerforms Richardson extrapolation on an array fh for use in Romberg integration.\n\nArguments\n\nV::Matrix{Float} : velocity components due to the jth and j+1th nodes in the format: [vz_j vr_j; vz_{j+1} vr_{j+1}]\nerr::Vector{Float} : estimated errors in velocity approximation\nfh::Tuple : (f(h), h) tuples (in order of decreasing |h|)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#State-Initialization","page":"Preprocess","title":"State Initialization","text":"","category":"section"},{"location":"DuctAPE/api/private_preprocess/","page":"Preprocess","title":"Preprocess","text":"DuctAPE.initialize_velocities\nDuctAPE.initialize_velocities!\nDuctAPE.initialize_strengths!","category":"page"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.initialize_velocities","page":"Preprocess","title":"DuctAPE.initialize_velocities","text":"initialize_velocities(\n    solver_options::SolverOptionsType,\n    operating_point,\n    blade_elements,\n    linsys,\n    ivr,\n    ivw,\n    body_totnodes,\n    wake_panel_sheet_be_map,\n)\n\nInitialize velocity state variables.\n\nArguments\n\nsolver_options::SolverOptionsType : solver options type for dispatch\noperating_point::OperatingPoint : an OperatingPoint object\nblade_elements::NamedTuple : A named tuple containing the blade element geometry and airfoil information.\nlinsys::NamedTuple : A named tuple containing the panel method linear system information.\nivr::NamedTuple : A named tuple containing the unit induced velocities on the rotors\nivw::NamedTuple : A named tuple containing the unit induced velocities on the wake\nbody_totnodes::Int : the total number of panel nodes comprising the duct and centerbody geometry\nwake_panel_sheet_be_map::Matrix{Int} : An index map from the wake panels to the nearest ahead rotor blade element along the wake sheets\n\nReturns\n\nvz_rotor::Vector{Float} : a vector of the velocity state variables associated with the rotor axially induced velocity\nvtheta_rotor::Vector{Float} : a vector of the velocity state variables associated with the rotor tangentially induced velocity\nCm_wake::Vector{Float} : a vector of the velocity state variables associated with the wake control point meridional velocity\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.initialize_velocities!","page":"Preprocess","title":"DuctAPE.initialize_velocities!","text":"function initializevelocities!(     solveroptions::SolverOptionsType,     vzrotor,     vthetarotor,     Cmwake,     operatingpoint,     bladeelements,     linsys,     ivr,     ivw,     bodytotnodes,     wakepanelsheetbemap, )\n\nIn-place version of initialize_velocities.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_preprocess/#DuctAPE.initialize_strengths!","page":"Preprocess","title":"DuctAPE.initialize_strengths!","text":"initialize_strengths!(\n    solver_options::SolverOptionsType,\n    Gamr,\n    sigr,\n    gamw,\n    operating_point,\n    blade_elements,\n    linsys,\n    ivr,\n    ivw,\n    wakeK,\n    body_totnodes,\n    wake_nodemap,\n    wake_endnodeidxs,\n    wake_panel_sheet_be_map,\n    wake_node_sheet_be_map,\n    wake_node_ids_along_casing_wake_interface,\n    wake_node_ids_along_centerbody_wake_interface,\n)\n\nInitialize strength state variables.\n\nArguments\n\nsolver_options::SolverOptionsType : solver options type for dispatch\nGamr::Vector{Float} : Rotor circulation state variables (modified in place)\nsigr::Vector{Float} : Rotor panel strength state variables (modified in place)\ngamw::Vector{Float} : Wake panel strength state variables (modified in place)\noperating_point::OperatingPoint : an OperatingPoint object\nblade_elements::NamedTuple : A named tuple containing the blade element geometry and airfoil information.\nlinsys::NamedTuple : A named tuple containing the panel method linear system information.\nivr::NamedTuple : A named tuple containing the unit induced velocities on the rotors\nivw::NamedTuple : A named tuple containing the unit induced velocities on the wake\nwakeK::Vector{Float} : geometric constants of wake nodes used in calculating wake strengths\nbody_totnodes::Int : the total number of panel nodes comprising the duct and centerbody geometry\nwake_nodemap::Matrix{Int} : an index map of wake panel to the associated node indices\nwake_endnodeidxs::Matrix{Int} : the node indices of the start and end of the wake sheets.\nwake_panel_sheet_be_map::Matrix{Int} : An index map from the wake panels to the nearest ahead rotor blade element along the wake sheets\nwake_node_sheet_be_map::Matrix{Int} : An index map from the wake nodes to the nearest ahead rotor blade element along the wake sheets\nwake_node_ids_along_casing_wake_interface::type : An index map indicating which wake nodes interface with the duct wall\nwake_node_ids_along_centerbody_wake_interface::type : An index map indicating which wake nodes interface with the centerbody wall\n\n\n\n\n\nfunction initialize_strengths!(\n    solver_options::CSORSolverOptions,\n    Gamr,\n    sigr,\n    gamw,\n    solve_containers,\n    operating_point,\n    blade_elements,\n    wakeK,\n    wake_nodemap,\n    wake_endnodeidxs,\n    wake_panel_sheet_be_map,\n    wake_node_sheet_be_map,\n    wake_node_ids_along_casing_wake_interface,\n    wake_node_ids_along_centerbody_wake_interface;\n    niter=10,\n    rlx=0.5,\n)\n\nRefactored from DFDC SUBROUTINE ROTINITBLD\n\nFrom the subroutine notes: Sets reasonable initial circulation using current rotor blade geometry (chord, beta). Initial circulations are set w/o induced effects An iteration is done using the self-induced velocity from momentum theory to converge an approximate induced axial velocity\n\nArguments\n\nsolver_options::SolverOptionsType : solver options type for dispatch\nGamr::Vector{Float} : Rotor circulation state variables (modified in place)\nsigr::Vector{Float} : Rotor panel strength state variables (modified in place)\ngamw::Vector{Float} : Wake panel strength state variables (modified in place)\noperating_point::OperatingPoint : an OperatingPoint object\nblade_elements::NamedTuple : A named tuple containing the blade element geometry and airfoil information.\nwakeK::Vector{Float} : geometric constants of wake nodes used in calculating wake strengths\nwake_nodemap::Matrix{Int} : an index map of wake panel to the associated node indices\nwake_endnodeidxs::Matrix{Int} : the node indices of the start and end of the wake sheets.\nwake_panel_sheet_be_map::Matrix{Int} : An index map from the wake panels to the nearest ahead rotor blade element along the wake sheets\nwake_node_sheet_be_map::Matrix{Int} : An index map from the wake nodes to the nearest ahead rotor blade element along the wake sheets\nwake_node_ids_along_casing_wake_interface::type : An index map indicating which wake nodes interface with the duct wall\nwake_node_ids_along_centerbody_wake_interface::type : An index map indicating which wake nodes interface with the centerbody wall\n\nKeyword Arguments\n\nrlx::Float=0.5 : factor for under-relaxation to reduce transients in CL\n\nReturns\n\n\n\n\n\n","category":"function"},{"location":"C4Blade/airfoil_types/CCBlade/#CCBlade-Airfoil-Types","page":"CCBlade Airfoil Types","title":"CCBlade Airfoil Types","text":"","category":"section"},{"location":"C4Blade/airfoil_types/CCBlade/","page":"CCBlade Airfoil Types","title":"CCBlade Airfoil Types","text":"DuctAPE includes all the airfoil types and methods available in CCBlade.  We repeat them here for convenience, but refer the user to the CCBlade documentation for more context if advanced usage is desired.","category":"page"},{"location":"C4Blade/airfoil_types/CCBlade/","page":"CCBlade Airfoil Types","title":"CCBlade Airfoil Types","text":"Modules = [DuctAPE.C4Blade]\nPages = [\"C4Blade/airfoils.jl\"]","category":"page"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.AlphaAF","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.AlphaAF","text":"AlphaAF(alpha, cl, cd, info, Re, Mach)\nAlphaAF(alpha, cl, cd, info, Re=0.0, Mach=0.0)\nAlphaAF(alpha, cl, cd, info=\"CCBlade generated airfoil\", Re=0.0, Mach=0.0)\nAlphaAF(filename::String; radians=true)\n\nAirfoil data that varies with angle of attack.  Data is fit with an Akima spline.\n\nArguments:\n\nalpha::Vector{Float64}: angles of attack\ncl::Vector{Float64}: corresponding lift coefficients\ncd::Vector{Float64}: corresponding drag coefficients\ninfo::String: a description of this airfoil data (just informational)\nRe::Float64: Reynolds number data was taken at (just informational)\nMach::Float64: Mach number data was taken at (just informational)\n\nor\n\na file\n\nArguments:\n\nfilename::String: name/path of file to read in\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.AlphaMachAF","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.AlphaMachAF","text":"AlphaMachAF(alpha, Mach, cl, cd, info, Re)\nAlphaMachAF(alpha, Mach, cl, cd, info)\nAlphaMachAF(alpha, Mach, cl, cd)\nAlphaMachAF(filenames::Vector{String}; radians=true)\n\nAirfoil data that varies with angle of attack and Mach number. Data is fit with a recursive Akima spline.\n\nArguments:\n\nalpha::Vector{Float64}: angles of attack\nMach::Vector{Float64}: Mach numbers\ncl::Matrix{Float64}: lift coefficients where cl[i, j] corresponds to alpha[i], Mach[j]\ncd::Matrix{Float64}: drag coefficients where cd[i, j] corresponds to alpha[i], Mach[j]\ninfo::String: a description of this airfoil data (just informational)\nRe::Float64: Reynolds number data was taken at (just informational)\n\nor\n\nfilenames with one file per Mach number.\n\nArguments:\n\nfilenames::Vector{String}: name/path of files to read in, each at a different Mach number in ascending order\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.AlphaReAF","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.AlphaReAF","text":"AlphaReAF(alpha, Re, cl, cd, info, Mach)\nAlphaReAF(alpha, Re, cl, cd, info)\nAlphaReAF(alpha, Re, cl, cd)\nread_AlphaReAF(filenames::Vector{String}; radians=true)\n\nAirfoil data that varies with angle of attack and Reynolds number. Data is fit with a recursive Akima spline.\n\nArguments:\n\nalpha::Vector{Float64}: angles of attack\nRe::Vector{Float64}: Reynolds numbers\ncl::Matrix{Float64}: lift coefficients where cl[i, j] corresponds to alpha[i], Re[j]\ncd::Matrix{Float64}: drag coefficients where cd[i, j] corresponds to alpha[i], Re[j]\ninfo::String: a description of this airfoil data (just informational)\nMach::Float64: Mach number data was taken at (just informational)\n\nor\n\nfilenames with one file per Reynolds number.\n\nArguments:\n\nfilenames::Vector{String}: name/path of files to read in, each at a different Reynolds number in ascending order\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.AlphaReMachAF","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.AlphaReMachAF","text":"AlphaReMachAF(alpha, Re, Mach, cl, cd, info)\nAlphaReMachAF(alpha, Re, Mach, cl, cd)\nAlphaReMachAF(filenames::Matrix{String}; radians=true)\n\nAirfoil data that varies with angle of attack, Reynolds number, and Mach number. Data is fit with a recursive Akima spline.\n\nArguments:\n\nalpha::Vector{Float64}: angles of attack\nRe::Vector{Float64}: Reynolds numbers\nMach::Vector{Float64}: Mach numbers\ncl::Array{Float64}: lift coefficients where cl[i, j, k] corresponds to alpha[i], Re[j], Mach[k]\ncd::Array{Float64}: drag coefficients where cd[i, j, k] corresponds to alpha[i], Re[j], Mach[k]\ninfo::String: a description of this airfoil data (just informational)\n\nor files with one per Re/Mach combination\n\nArguments:\n\nfilenames::Matrix{String}: name/path of files to read in.  filenames[i, j] corresponds to Re[i] Mach[j] with Reynolds number and Mach number in ascending order.\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.DuSeligEggers","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.DuSeligEggers","text":"DuSeligEggers(a, b, d, m, alpha0)\nDuSeligEggers(a=1.0, b=1.0, d=1.0, m=2*pi, alpha0=0.0)  # uses defaults\n\nDuSelig correction for lift an Eggers correction for drag.\n\nArguments:\n\na, b, d::Float64: parameters in Du-Selig paper.  Normally just 1.0 for each.\nm::Float64: lift curve slope.  Defaults to 2 pi for zero argument version.\nalpha0::Float64: zero-lift angle of attack.  Defaults to 0 for zero argument version.\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.PrandtlTip","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.PrandtlTip","text":"PrandtlTip()\n\nStandard Prandtl tip loss correction.\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.PrandtlTipHub","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.PrandtlTipHub","text":"PrandtlTipHub()\n\nStandard Prandtl tip loss correction plus hub loss correction of same form.\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.SimpleAF","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.SimpleAF","text":"SimpleAF(m, alpha0, clmax, clmin, cd0, cd2)\n\nA simple parameterized lift and drag curve.\n\ncl = m (alpha - alpha0) (capped by clmax/clmin)\ncd = cd0 + cd2 * cl^2\n\nArguments:\n\nm::Float64: lift curve slope\nalpha0::Float64: zero-lift angle of attack\nclmax::Float64: maximum lift coefficient\nclmin::Float64: minimum lift coefficient\ncd0::Float64: zero lift drag\ncd2::Float64: quadratic drag term\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.SkinFriction","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.SkinFriction","text":"SkinFriction(Re0, p)\n\nSkin friction model for a flat plate. cd *= (Re0 / Re)^p\n\nArguments:\n\nRe0::Float64: reference Reynolds number (i.e., no corrections at this number)\np::Float64: exponent in flat plate model.  0.5 for laminar (Blasius solution), ~0.2 for fully turbulent (Schlichting empirical fit)\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.afeval-Tuple{DuctAPE.C4Blade.AFType, Any, Any, Any}","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.afeval","text":"afeval(af::AFType, alpha, Re, Mach)\n\nEvaluate airfoil aerodynamic performance\n\nArguments:\n\naf::AFType or Function: dispatch on AFType or if function call: cl, cd = af(alpha, Re, Mach)\nalpha::Float64: angle of attack in radians\nRe::Float64: Reynolds number\nMach::Float64: Mach number\n\nReturns:\n\ncl::Float64: lift coefficient\ncd::Float64: drag coefficient\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.mach_correction-Tuple{DuctAPE.C4Blade.MachCorrection, Any, Any, Any}","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.mach_correction","text":"mach_correction(::MachCorrection, cl, cd, Mach)\n\nMach number correction for lift/drag coefficient\n\nArguments:\n\nmc::MachCorrection: used for dispatch\ncl::Float64: lift coefficient before correction\ncd::Float64: drag coefficient before correction\nMach::Float64: Mach number\n\nReturns:\n\ncl::Float64: lift coefficient after correction\ncd::Float64: drag coefficient after correction\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.mach_correction-Tuple{DuctAPE.C4Blade.PrandtlGlauert, Any, Any, Any}","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.mach_correction","text":"mach_correction(::PrandtlGlauert, cl, cd, Mach)\n\nPrandtl/Glauert Mach number correction for lift coefficient\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.parsefile-Tuple{Any, Any}","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.parsefile","text":"A basic airfoil file format.  nheader is the number of header lines, which will be skipped.  For one Reynolds/Mach number. Additional data like cm is optional but will be ignored.\n\nformat:\n\ninformational header\n\nRe\n\nMach\n\nalpha1 cl1 cd1 ...\n\nalpha2 cl2 cd2\n\nalpha3 cl3 cd3\n\n...\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.re_correction-Tuple{DuctAPE.C4Blade.ReCorrection, Any, Any, Any}","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.re_correction","text":"re_correction(re::ReCorrection, cl, cd, Re)\n\nReynolds number correction for lift/drag coefficient\n\nArguments:\n\nre::ReCorrection: used for dispatch\ncl::Float64: lift coefficient before correction\ncd::Float64: drag coefficient before correction\nRe::Float64: Reynolds number\n\nReturns:\n\ncl::Float64: lift coefficient after correction\ncd::Float64: drag coefficient after correction\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.re_correction-Tuple{DuctAPE.C4Blade.SkinFriction, Any, Any, Any}","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.re_correction","text":"re_correction(sf::SkinFriction, cl, cd, Re)\n\nSkin friction coefficient correction based on flat plat drag increases with Reynolds number.\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.rotation_correction","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.rotation_correction","text":"rotation_correction(rc::RotationCorrection, cl, cd, cr, rR, tsr, alpha, phi=alpha, alpha_max_corr=30*pi/180)\n\nRotation correction (3D stall delay).\n\nArguments:\n\nrc::RotationCorrection: used for dispatch\ncl::Float64: lift coefficient before correction\ncd::Float64: drag coefficient before correction\ncr::Float64: local chord / local radius\nrR::Float64: local radius / tip radius\ntsr::Float64: local tip speed ratio (Omega r / Vinf)\nalpha::Float64: local angle of attack\nphi::Float64: local inflow angles (defaults to angle of attack is precomputing since it is only known for on-the-fly computations)\nalpha_max_corr::Float64: angle of attack for maximum correction (tapers off to zero by 90 degrees)\n\nReturns:\n\ncl::Float64: lift coefficient after correction\ncd::Float64: drag coefficient after correction\n\n\n\n\n\n","category":"function"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.tip_correction-Tuple{DuctAPE.C4Blade.TipCorrection, Vararg{Any, 5}}","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.tip_correction","text":"tip_correction(::TipCorrection, r, Rhub, Rtip, phi, B)\n\nTip corrections for 3D flow.\n\nArguments:\n\ntc::TipCorrection: used for dispatch\nr::Float64: local radius\nRhub::Float64: hub radius\nRtip::Float64: tip radius\nphi::Float64: inflow angle\nB::Integer: number of blades\n\nReturns:\n\nF::Float64: tip loss factor to multiple against loads.\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.viterna","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.viterna","text":"viterna(alpha, cl, cd, cr75, nalpha=50)\n\nViterna extrapolation.  Follows Viterna paper and somewhat follows NREL version of AirfoilPrep, but with some modifications for better robustness and smoothness.\n\nArguments:\n\nalpha::Vector{Float64}: angles of attack\ncl::Vector{Float64}: correspnding lift coefficients\ncd::Vector{Float64}: correspnding drag coefficients\ncr75::Float64: chord/Rtip at 75% Rtip\nnalpha::Int64: number of discrete points (angles of attack) to include in extrapolation\n\nReturns:\n\nalpha::Vector{Float64}: angle of attack from -pi to pi\ncl::Vector{Float64}: correspnding extrapolated lift coefficients\ncd::Vector{Float64}: correspnding extrapolated drag coefficients\n\n\n\n\n\n","category":"function"},{"location":"C4Blade/airfoil_types/CCBlade/#DuctAPE.C4Blade.write_af-Tuple{Any, DuctAPE.C4Blade.AlphaAF}","page":"CCBlade Airfoil Types","title":"DuctAPE.C4Blade.write_af","text":"write_af(filename(s), af::AFType; radians=true)\n\nWrite airfoil data to file\n\nArguments:\n\nfilename(s)::String or Vector{String} or Matrix{String}: name/path of file to write to\naf::AFType: writing is dispatched based on type (AlphaAF, AlphaReAF, etc.)\nradians::Bool: true if you want angle of attack to be written in radians\n\n\n\n\n\n","category":"method"},{"location":"DuctAPE/api/private_prelims/#Option-Types","page":"Prelims","title":"Option Types","text":"","category":"section"},{"location":"DuctAPE/api/private_prelims/","page":"Prelims","title":"Prelims","text":"DuctAPE.DFDC_options\nDuctAPE.ConvergenceType\nDuctAPE.Relative\nDuctAPE.Absolute\nDuctAPE.SolverOptionsType\nDuctAPE.InternalSolverOptions\nDuctAPE.InternalPolyAlgorithmOptions\nDuctAPE.ExternalSolverOptions\nDuctAPE.ExternalPolyAlgorithmOptions\nDuctAPE.GridSolverOptionsType\nDuctAPE.IntegrationMethod","category":"page"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.DFDC_options","page":"Prelims","title":"DuctAPE.DFDC_options","text":"function DFDC_options(;\n    grid_solver_options=SLORGridSolverOptions(),\n    solver_options=CSORSolverOptions(),\n    kwargs...,\n)\n\nConvenience function to select options used in DFDC.\n\n\n\n\n\nfunction DFDC_options(\n    multipoint;\n    grid_solver_options=SLORGridSolverOptions(),\n    solver_options=CSORSolverOptions(),\n    kwargs...,\n)\n\nConvenience function to select options used in DFDC and run multipoint analysis.\n\nArguments\n\nmultipoint::Vector : doesn't need to be anything but a vector of the length of multipoints.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.ConvergenceType","page":"Prelims","title":"DuctAPE.ConvergenceType","text":"abstract type ConvergenceType\n\nUsed in dispatching the CSOR (controlled successive over relaxation) residual as relative or absolute.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.Relative","page":"Prelims","title":"DuctAPE.Relative","text":"struct Relative <: ConvergenceType\n\nUsed to dispatch the relative residual for CSOR (controlled successive over relaxation) method\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.Absolute","page":"Prelims","title":"DuctAPE.Absolute","text":"struct Absolute <: ConvergenceType\n\nUsed to dispatch the absolute residual for CSOR (controlled successive over relaxation)  method\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.SolverOptionsType","page":"Prelims","title":"DuctAPE.SolverOptionsType","text":"abstract type SolverOptionsType\n\nUsed for solver dispatch.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.InternalSolverOptions","page":"Prelims","title":"DuctAPE.InternalSolverOptions","text":"abstract type InternalSolverOptions <: SolverOptionsType\n\nUsed for solver dispatch.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.InternalPolyAlgorithmOptions","page":"Prelims","title":"DuctAPE.InternalPolyAlgorithmOptions","text":"abstract type InternalPolyAlgorithmOptions <: SolverOptionsType\n\nUsed for solver dispatch.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.ExternalSolverOptions","page":"Prelims","title":"DuctAPE.ExternalSolverOptions","text":"abstract type ExternalSolverOptions <: SolverOptionsType\n\nUsed for solver dispatch.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.ExternalPolyAlgorithmOptions","page":"Prelims","title":"DuctAPE.ExternalPolyAlgorithmOptions","text":"abstract type ExternalPolyAlgorithmOptions <: SolverOptionsType\n\nUsed for solver dispatch.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.GridSolverOptionsType","page":"Prelims","title":"DuctAPE.GridSolverOptionsType","text":"abstract type GridSolverOptionsType\n\nUsed for elliptic grid solver dispatch\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.IntegrationMethod","page":"Prelims","title":"DuctAPE.IntegrationMethod","text":"abstract type IntegrationMethod\n\nUsed in integration method dispatch\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/private_prelims/#Bookkeeping","page":"Prelims","title":"Bookkeeping","text":"","category":"section"},{"location":"DuctAPE/api/private_prelims/","page":"Prelims","title":"Prelims","text":"DuctAPE.get_problem_dimensions","category":"page"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.get_problem_dimensions","page":"Prelims","title":"DuctAPE.get_problem_dimensions","text":"get_problem_dimensions(paneling_constants::PanelingConstants)\nget_problem_dimensions(body_vortex_panels, rotor_source_panels, wake_vortex_panels)\n\nDetermine all relevant dimensions to the problem based either on the paneling_constants or the panels themselves.\n\nArguments\n\npaneling_constants::PanelingConstants : Rotor (and possibly stator) geometric paramters.\n\nReturns\n\nproblem_dimensions::ProblemDimensions : ProblemDimensions object.\n\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#Caching","page":"Prelims","title":"Caching","text":"","category":"section"},{"location":"DuctAPE/api/private_prelims/#Allocation","page":"Prelims","title":"Allocation","text":"","category":"section"},{"location":"DuctAPE/api/private_prelims/","page":"Prelims","title":"Prelims","text":"The following are various helper functions used in preallocating the various caches.","category":"page"},{"location":"DuctAPE/api/private_prelims/","page":"Prelims","title":"Prelims","text":"DuctAPE.initialize_all_caches\nDuctAPE.allocate_wake_panel_container!\nDuctAPE.allocate_panel_containers!\nDuctAPE.allocate_panel_container!\nDuctAPE.allocate_body_panel_container!\nDuctAPE.allocate_rotor_panel_container!\nDuctAPE.allocate_solve_parameter_extras!\nDuctAPE.allocate_grid_parameter_cache\nDuctAPE.allocate_integration_containers","category":"page"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.initialize_all_caches","page":"Prelims","title":"DuctAPE.initialize_all_caches","text":"initialize_all_caches(solver_options, paneling_constants)\n\nConvenience function to initialize all caches before calling analysis.\n\nArguments\n\nsolver_options::SolverOptionsType : solver options used for cache allocation dispatch\npaneling_constants::PanelingConstants : PanelingConstants object upon which all cache sizing depends\n\nKeyword Arguments\n\nfd_chunk_size::Int=12 : chunk size to use for PreallocationTools caches.  Note that the automated chunk size for DuctAPE will always be the ForwardDiff threshold of 12 due to the size of the system, so it will be best to leave this at the default unless further development allows for chunk size selection for individual solvers.\nlevels::Int=1 : levels for nested duals.  Note that since ImplicitAD is being used for all solves, there should be no need for more than 1 level.\n\nReturns\n\nprepost_container_caching::NamedTuple : A named tuple containing the PreallocationTools DiffCache and a named tuple with relevant dimensions for accessing the cache.\nsolve_parameter_caching::NamedTuple : A named tuple containing the PreallocationTools DiffCache and a named tuple with relevant dimensions for accessing the cache.\nsolve_container_caching::NamedTuple : A named tuple containing the PreallocationTools DiffCache and a named tuple with relevant dimensions for accessing the cache.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.allocate_wake_panel_container!","page":"Prelims","title":"DuctAPE.allocate_wake_panel_container!","text":"allocate_wake_panel_containers!(total_length, problem_dimensions::ProblemDimensions)\n\nA helper function is assembling the prepostcontainercache.\n\nArguments\n\ntotal_length::Vector{Int} : a one-element vector used to store the total length in order to know how large of a cache to allocate.  Is updated in place.\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nReturns\n\nwake_vortex_panels::NamedTuple : A named containing the dimensions needed to reshape the cache with regards to the wake vortex panel object\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.allocate_panel_containers!","page":"Prelims","title":"DuctAPE.allocate_panel_containers!","text":"allocate_panel_containers!(total_length, problem_dimensions::ProblemDimensions)\n\nA helper function is assembling the prepostcontainercache.\n\nArguments\n\ntotal_length::Vector{Int} : a one-element vector used to store the total length in order to know how large of a cache to allocate.  Is updated in place.\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nReturns\n\npanels::NamedTuple : A named tuple of named tuples containing the dimensions needed to reshape the cache with regards to the panel objects\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.allocate_panel_container!","page":"Prelims","title":"DuctAPE.allocate_panel_container!","text":"allocate_panel_container!(total_length, nn, np, tn, tp, nb)\n\nA helper function is assembling the prepostcontainercache.\n\nArguments\n\ntotal_length::Vector{Int} : a one-element vector used to store the total length in order to know how large of a cache to allocate.  Is updated in place.\nnn::Int : number of nodes in each body, rotor, or wake sheet\nnp::Int : number of panels in each body, rotor, or wake sheet\ntn::Int : number of total nodes among the bodies, rotors, or wake sheets\ntp::Int : number of total panels among the bodies, rotors, or wake sheets\nnb::Int : number of bodies, rotors, or wake sheets\n\nReturns\n\npanel::NamedTuple : A named containing the dimensions needed to reshape the cache with regards to an arbitrary panel set\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.allocate_body_panel_container!","page":"Prelims","title":"DuctAPE.allocate_body_panel_container!","text":"allocate_body_panel_containers!(total_length, problem_dimensions::ProblemDimensions)\n\nA helper function is assembling the prepostcontainercache.\n\nArguments\n\ntotal_length::Vector{Int} : a one-element vector used to store the total length in order to know how large of a cache to allocate.  Is updated in place.\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nReturns\n\nbody_vortex_panels::NamedTuple : A named tuple containing the dimensions needed to reshape the cache with regards to the body vortex panel object\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.allocate_rotor_panel_container!","page":"Prelims","title":"DuctAPE.allocate_rotor_panel_container!","text":"allocate_rotor_panel_containers!(total_length, problem_dimensions::ProblemDimensions)\n\nA helper function is assembling the prepostcontainercache.\n\nArguments\n\ntotal_length::Vector{Int} : a one-element vector used to store the total length in order to know how large of a cache to allocate.  Is updated in place.\nproblem_dimensions::ProblemDimensions : a ProblemDimensions object\n\nReturns\n\nrotor_source_panels::NamedTuple : A named containing the dimensions needed to reshape the cache with regards to the rotor source panel object\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.allocate_solve_parameter_extras!","page":"Prelims","title":"DuctAPE.allocate_solve_parameter_extras!","text":"allocate_solve_parameter_extras!(\n    solver_options::SolverOptionsType, input_length, total_length\n)\n\nIncludes additional caching for various solvers.  Currently only does anything for SIAMFANLEOptions types.\n\nArguments\n\ninput_length::Int : the number of state variables in the solver\ntotal_length::Vector{Int} : a one-element vector used to store the total length in order to know how large of a cache to allocate.  Is updated in place.\n\nReturns\n\nsolve_parameter_extras::NamedTuple : A named tuple containing dimensions related to extra caching parameters used in various solvers.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.allocate_grid_parameter_cache","page":"Prelims","title":"DuctAPE.allocate_grid_parameter_cache","text":"allocate_grid_parameter_cache(pg, x, n)\n\nAllocate a cache used inside the elliptic grid solve.\n\nArguments\n\npg::AbstractArray{Float,3} : the proposed grid array\nx::AbstractVector{Float} : the array of  values used in the solve\nn::AbstractVector{Float} : the array of  values used in the solve\n\nReturns\n\ngrid_parameter_cache::NamedTuple : A named tuple containing the PreallocationTools DiffCache and dimensions for accessing it.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.allocate_integration_containers","page":"Prelims","title":"DuctAPE.allocate_integration_containers","text":"allocate_integration_containers(\n    integration_options::IntegrationMethod, dispatch_type; cache_size=20\n)\n\nDescription\n\nArguments\n\nintegration_options::IntegrationMethod : options for integration used for dispatch and to size cache\ndispatch_type:: : an object with eltype(dispatch_type) with which to define the type for cache initialization.\n\nKeyword Arguments\n\ncache_size::Int=20 : size needed for intermediate calculations for integration.\n\nReturns\n\nintegration_containers::NamedTuple : A named tuple containing the cache(s) needed for integration.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#Reshaping","page":"Prelims","title":"Reshaping","text":"","category":"section"},{"location":"DuctAPE/api/private_prelims/","page":"Prelims","title":"Prelims","text":"The following are used internally to reshape the cache vectors into more usable formats.","category":"page"},{"location":"DuctAPE/api/private_prelims/","page":"Prelims","title":"Prelims","text":"DuctAPE.withdraw_prepost_container_cache\nDuctAPE.withdraw_solve_parameter_cache\nDuctAPE.withdraw_solve_container_cache\nDuctAPE.withdraw_grid_parameter_cache","category":"page"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.withdraw_prepost_container_cache","page":"Prelims","title":"DuctAPE.withdraw_prepost_container_cache","text":"withdraw_prepost_container_cache(vec, dims)\n\nReshape the prepost cache vector using the saved dimensions tuple.\n\nArguments\n\nvec::Vector{Float} : vector cache of pre- and post-processing intermediate containers.\ndims::NamedTuple : Named tuple containing the indices and shape of the various items stored in the cache vector.\n\nReturns\n\nprepost_container_caching::NamedTuple : Named tuple containing reshaped views of sections of the cache vector.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.withdraw_solve_parameter_cache","page":"Prelims","title":"DuctAPE.withdraw_solve_parameter_cache","text":"withdraw_solve_parameter_cache(solver_options::SolverOptionsType, vec, dims)\n\nReshape the solve parameter cache vector using the saved dimensions tuple.\n\nArguments\n\nsolver_options::SolverOptionsType : Solver options type for dispatch.\nvec::Vector{Float} : vector cache of pre- and post-processing intermediate containers.\ndims::NamedTuple : Named tuple containing the indices and shape of the various items stored in the cache vector.\n\nReturns\n\nsolve_parameter_caching::NamedTuple : Named tuple containing reshaped views of sections of the cache vector.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.withdraw_solve_container_cache","page":"Prelims","title":"DuctAPE.withdraw_solve_container_cache","text":"withdraw_solve_container_cache(solver_options::SolverOptionsType, vec, dims)\n\nReshape the intermediate solve container cache vector using the saved dimensions tuple.\n\nArguments\n\nsolver_options::SolverOptionsType : Solver options type for dispatch.\nvec::Vector{Float} : vector cache of pre- and post-processing intermediate containers.\ndims::NamedTuple : Named tuple containing the indices and shape of the various items stored in the cache vector.\n\nReturns\n\nsolve_container_caching::NamedTuple : Named tuple containing reshaped views of sections of the cache vector.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_prelims/#DuctAPE.withdraw_grid_parameter_cache","page":"Prelims","title":"DuctAPE.withdraw_grid_parameter_cache","text":"withdraw_grid_parameter_cache(vec, dims)\n\nReshape the cache used inside the elliptic grid solve.\n\nArguments\n\nvec::Vector{Float} : the cache vector\ndims::NamedTuple : the named tuple of dimensions used to reshape the cache vector\n\nReturns\n\nproposed_grid::AbstractArray{Float,3} : the proposed grid array\nxi::AbstractVector{Float} : the array of  values used in the solve\neta::AbstractVector{Float} : the array of  values used in the solve\n\n\n\n\n\n","category":"function"},{"location":"C4Blade/airfoil_types/DFDC/#DFDC-Airfoil-Type","page":"DFDC Airfoil Type","title":"DFDC Airfoil Type","text":"","category":"section"},{"location":"C4Blade/airfoil_types/DFDC/","page":"DFDC Airfoil Type","title":"DFDC Airfoil Type","text":"The DFDC Airfoil type is very similar to the XROTOR airfoil type, but includes additions for cascade corrections based on stagger and solidity. The cascade corrections aren't particularly accurate, but they do apply ballpark effects resulting from high solidity blade sections. The main benefit to this airfoil type is its simplicity and that the post-stall behavior is already in a format allowing more robust convergence of the DuctAPE solvers.","category":"page"},{"location":"C4Blade/airfoil_types/DFDC/","page":"DFDC Airfoil Type","title":"DFDC Airfoil Type","text":"DuctAPE.C4Blade.DFDCairfoil","category":"page"},{"location":"C4Blade/airfoil_types/DFDC/#DuctAPE.C4Blade.DFDCairfoil","page":"DFDC Airfoil Type","title":"DuctAPE.C4Blade.DFDCairfoil","text":"Fields:\n\nalpha0::Float : zero lift angle of attack\nclmax::Float : maximum cl\nclmin::Float : minimum cl\ndclda::Float : lift curve slope (1/radians)\ndclda_stall::Float :  lift curve slope post-stall (1/radians)\ndcl_stall::Float : cl increment from initial to total stall.\ncdmin::Float : minimum cd\ncldmin::Float : cl at cdmin\ndcddcl2::Float : quadratic curve factor for cl vs cd curve left(fracd(c_d)d(c_l^2)right)\ncmcon::Float : pitching moment constant (unused right now)\nRe_ref::Float : reference Reynolds number at which cd values apply\nRe_exp::Float : Reynolds number exponent scaling left( c_d = c_d(ReRe_ref)^Re_expright) should be 0.2 for fully laminar and 0.5 for fully turbulent\nmcrit::Float : critical Mach number\ncorrect_for_mach::Bool : flag to add Prandtl-Glauert correction\ncorrect_for_cascade::Bool : flag to add cascade corrections\ncorrect_for_reynolds::Bool : flag to add reynolds drag correction\ncorrect_for_transonic::Bool : flag to add drag correction above critical mach number\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/actuator_disk/#Actuator-Disk-Type","page":"Actuator Disk Type","title":"Actuator Disk Type","text":"","category":"section"},{"location":"C4Blade/airfoil_types/actuator_disk/","page":"Actuator Disk Type","title":"Actuator Disk Type","text":"warning: Warning\nActuator disk types are currently in development and not ready for general use.","category":"page"},{"location":"C4Blade/airfoil_types/actuator_disk/","page":"Actuator Disk Type","title":"Actuator Disk Type","text":"DuctAPE currently implements an actuator disk type that can be used to directly define the rotor blade circulation.","category":"page"},{"location":"C4Blade/airfoil_types/actuator_disk/","page":"Actuator Disk Type","title":"Actuator Disk Type","text":"DuctAPE.C4Blade.ADM","category":"page"},{"location":"C4Blade/airfoil_types/actuator_disk/#DuctAPE.C4Blade.ADM","page":"Actuator Disk Type","title":"DuctAPE.C4Blade.ADM","text":"Fields:\n\nprescribed_circulation::Float=0.0 : Prescribed circulation strength\nprescribed_source_strength::Float=0.0 : Prescribed source panel strength\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/api/private_api/#Private-API","page":"Private API","title":"Private API","text":"","category":"section"},{"location":"DuctAPE/api/private_api/","page":"Private API","title":"Private API","text":"Pages = [\"private_api.md\",\n\"private_prelims.md\",\n\"private_preprocess.md\",\n\"private_process.md\",\n\"private_postprocess.md\",\n\"private_utlities.md\"]\nDepth = 5","category":"page"},{"location":"DuctAPE/advanced_usage/option/#Advanced-Option-Selection","page":"Options","title":"Advanced Option Selection","text":"","category":"section"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"DuctAPE has been written in an attempt to make as many of the available options exposed to the user as possible.  This means that there are quite a few options to select from if not using the option convenience functions. To help the user, the majority of overarching option types are defined using the @kwdef macro and have default values that should be reasonable in most cases. We will introduce some of the available options here that may be of common interest.","category":"page"},{"location":"DuctAPE/advanced_usage/option/#General-Option-Selection","page":"Options","title":"General Option Selection","text":"","category":"section"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"In general, options are all accessed through the options argument of the analysis function being called. Said options are passed via an Options struct.","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"DuctAPE.Options","category":"page"},{"location":"DuctAPE/advanced_usage/option/#DuctAPE.Options-DuctAPE-advanced_usage-option","page":"Options","title":"DuctAPE.Options","text":"struct Options\n\nType containing (nearly) all the available user options.\n\nFields\n\nGeneral Options\n\nverbose::Bool = false : flag to print verbose statements\nsilence_warnings::Bool = true : flag to silence warnings\nmultipoint_index::Int = [1] : holds current index of multi-point solver (no need for user to change this usually)\n\nPre-processing Options\n\nGeometry interpolation and generation options :\n\nfinterp::Interplation Method = FLOWMath.akima : interpolation method used for re-paneling bodies\nautoshiftduct::Bool = true : flag as to whether duct geometry should be shifted based on rotor tip location\nlu_decomp_flag::Bool = false : flag indicating if panel method LHS matrix factorization was successful\n\npaneling options\n\nitcpshift::Float = 0.05 : factor for internal trailing edge psuedo-panel placement (default is DFDC hard-coded value)\naxistol::Float = 1e-15 : tolerance for how close the the axis of rotation should be considered on the axis\ntegaptol::Float = 1e1 * eps() : tolerance for how large of a trailing edge gap should be considered a gap\n\nIntegration Options\n\nintegration_options::IntegrationOptions type = IntegrationOptions() : integration options\n\nPost-processing Options\n\nboundary_layer_options::BoundaryLayerOptions : BoundaryLayerOptions object\nwrite_outputs::AbstractArray{Bool} = [false] : Bool for whether to write the outputs of the analysis to an external file (slow)\noutfile::AbstractArray{String} = [\"outputs.jl\"] : External output file name (including path information) for files to write\ncheckoutfileexists::Bool = false : Flag for whether to check if file exists before overwriting\noutput_tuple_name::AbstractArray{String} = [\"outs\"] : variable name for named tuple written to out file\n\nSolving Options\n\ngrid_solver_options::GridSolverOptionsType = GridSolverOptions() : elliptic grid solver options\nsolver_options::SolverOptionsType = ChainSolverOptions() : solver options\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"Options are selected through the set_options function","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"DuctAPE.set_options","category":"page"},{"location":"DuctAPE/advanced_usage/option/#DuctAPE.set_options-DuctAPE-advanced_usage-option","page":"Options","title":"DuctAPE.set_options","text":"set_options(; kwargs...)\nset_options(multipoint; kwargs...)\n\nSet the options for DuctAPE to use.\n\nNote that the vast majority of the available options are defined through keyword arguments.  See the documentation for the various option types for more information.\n\nArguments\n\nmultipoint::AbstractArray{OperatingPoint} : a vector of operating points to use if running a multi-point analysis.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"There are three main sub-option objects for quadrature, wake geometry solver, and aerodyanmic solver; these are explained in more detail below. In addition, there are various options for pre- and post-processing as well as miscellaneous options for things such as supressing warnings and printing verbose statements throughout the analysis, which can be seen in the docstring above.","category":"page"},{"location":"DuctAPE/advanced_usage/option/#Quadrature","page":"Options","title":"Quadrature","text":"","category":"section"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"There are several implementations for different quadrature approaches depending on user desires; they include:","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"Gauss-Legendre quadature (default),\nGauss-Kronrod Quadrature, and\nRomberg Quadrature methods.","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"The default method is Gauss-Legendre quadrature using 8 sample points for both the nominal and singular integrals. To modify the quadrature methods and settings, an IntegrationOptions struct needs to be passed to the set_options method.","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"DuctAPE.IntegrationOptions","category":"page"},{"location":"DuctAPE/advanced_usage/option/#DuctAPE.IntegrationOptions-DuctAPE-advanced_usage-option","page":"Options","title":"DuctAPE.IntegrationOptions","text":"struct IntegrationOptions\n\nA struct used to hold the integration options for both the nominal and singular cases.\n\nFields\n\nnominal::IntegrationMethod=GaussLegendre(8) : the integration options to use for the nominal case.\nsingular::IntegrationMethod=GaussLegendre(8) : the integration options to use for the self-induced case.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"The IntegraionOptions type takes in two objects of type IntegrationMethod, one for the nominal integrals, and one for the singular integrals. These methods can be mixed and matched between quadrature methods as well as settings.","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"For example, if one wanted to use a 10-point Gauss-Legendre method for the nominal integrals, and a order 7 Gauss-Kronrod method with an absolute tolerance of 2e-16 the following would need to be included in the set_options call:","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"# set nominal options using a GaussLegendre object (which is an InterationMethod type)\n# note that a convenience method is used here that takes in the number of points and\n#calculates the appropriate sample locations and weights.\nnominal_integration_method = DuctAPE.GaussLegendre(10)\n\n# set singular options using a GaussKronrod object (which is an InterationMethod type)\n# note that like most option structs, these are defined using @kwdef allowing the fields\n#to be treated as keyword arguments.\n# also note that we haven't changed the evaluation limit (default 10^7)\nsingular_integration_method = DuctAPE.GaussKronrod(; order=7, atol=2e-16)\n\n# put the quadrature options together\nintegration_options = DuctAPE.IntegrationOptions(;\n    nominal=nominal_integration_method, singular=singular_integration_method\n)\n\n# example of calling the set_options function\noptions = DuctAPE.set_options(; integration_options=integration_options)","category":"page"},{"location":"DuctAPE/advanced_usage/option/#Elliptic-Grid-Solvers","page":"Options","title":"Elliptic Grid Solvers","text":"","category":"section"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"As part of the pre-process, an elliptic grid defining the wake geometry is solved with a system of Poisson equations. For this solve there currently two options:","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"SLOR: DFDC grid solver\nDefault: Default method compatible with ImplicitAD","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"The SLOR (successive line over relaxation) is the method employed by DFDC.","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"Selection of solver and solver settings follows the same pattern as with the quadrature settings, in that the user must pass the appropriate GridSolverOptionsType into the set_options call.","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"For the SLOR method alone, the type is","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"DuctAPE.SLORGridSolverOptions","category":"page"},{"location":"DuctAPE/advanced_usage/option/#DuctAPE.SLORGridSolverOptions-DuctAPE-advanced_usage-option","page":"Options","title":"DuctAPE.SLORGridSolverOptions","text":"struct SLORGridSolverOptions <: GridSolverOptionsType\n\nOptions for SLOR (successive line over relaxation) elliptic grid solver.\n\nFields\n\niteration_limit::Int = 100 : maximum number of iterations\natol::Float = 1e-9 : absolute convergence tolerance\nconverged::AbstractArray{Bool} = [false]\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"And for the default method compatible with ImplicitAD, the type is","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"DuctAPE.GridSolverOptions","category":"page"},{"location":"DuctAPE/advanced_usage/option/#DuctAPE.GridSolverOptions-DuctAPE-advanced_usage-option","page":"Options","title":"DuctAPE.GridSolverOptions","text":"struct GridSolverOptions <: GridSolverOptionsType\n\nOptions for Newton elliptic grid solver.\n\nFields\n\niteration_limit::Int = 10 : maximum number of iterations\natol::Float = 1e-14 : absolute convergence tolerance\nalgorithm::Symbol = :newton : algorithm to use in NLsolve.jl\nautodiff::Symbol = :forward : differentiation method to use in NLsolve.jl\nconverged::AbstractArray{Bool} = [false]\niterations::AbstractArray{Int} = [0] : iteration counter\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"As an example, this is the input that would be required to use the default method with an absolute convergence tolerance of 1e-10, and also including the quadrature settings from above:","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"# define wake grid solver settings\nwake_solve_options = DuctAPE.GridSolverOptions(; atol=1e-10)\n\n# set all options\noptions = DuctAPE.set_options(;\n    integration_options=integration_options, grid_solver_options=wake_solve_options\n)","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"note: Convergence Flags\nThe convergence flags default to false, and in general should be left alone as they are modified in-place in the various solves by the analysis.","category":"page"},{"location":"DuctAPE/advanced_usage/option/#Aerodynamics-Solvers","page":"Options","title":"Aerodynamics Solvers","text":"","category":"section"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"There are two general types of solvers available in DuctAPE, the first is very similar to the solver in DFDC and converges a residual very similar to DFDC's. The other type is for external solvers that converge an alternate residual that is default in DuctAPE. The various solver options include:","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"CSOR: the DFDC solver\nModCSOR: modified DFDC solver for ImplicitAD compatibility\nFixedPoint.jl\nSpeedMapping.jl\nMINPACK.jl\nSIAMFANLEquations.jl\nNLsolve.jl\nSimpleNonlinearSolve.jl","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"Note that the CSOR, ModCSOR, FixedPoint.jl, and SpeedMapping.jl are all different fixed-point iteration solvers, MINPACK.jl and SIAMFANLEquations.jl are primarily quasi-newton solvers, and NLsolve.jl and SimpleNonlinearSolve.jl have various solver options.","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"DuctAPE also has some poly-algorithm solvers that employ more than one solver. The Chain Solver option is the default which starts with a fixed-point iteration, and if it doesn't converge, moves on to a quasi-, then full Newton solver until either convergence is reached, or no convergence is found. The other poly-algorithm that is available, but is less robust is the Composite Solver which partially converges with one solver, and finishes with another.","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"Each of the solve methods have a variety of different settings associated with them, detailed in their respective docstrings. The following example should contain all the principles required to be able to adapt to the most complex use cases.","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"# Define settings for NLsolve's newton method\naero_solver_options = DuctAPE.NLsolveOptions(;\n    algorithm=:newton,\n    atol=1e-10,\n    iteration_limit=30,\n    linesearch_method=LineSearches.BackTracking, #don't include parentheses on method handle\n    linesearch_kwargs=(; order=3, maxstep=1e6),\n    additional_kwargs=(; autoscale=false),\n)\n\n# set all the options\nDuctAPE.set_options(;\n    integration_options=integration_options,\n    grid_solver_options=wake_solve_options,\n    solver_options=aero_solver_options,\n)","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"note: Iteration Counters\nThe iterations field (not to be confused with the iterations_limit field) in the solver options should generally not be changed.  They automatically save (in-place) the number of iterations the solver performs and can be accessed after the analysis is run.","category":"page"},{"location":"DuctAPE/advanced_usage/option/#Boundary-Layer-Solvers","page":"Options","title":"Boundary Layer Solvers","text":"","category":"section"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"If desired, a one-way turbulent boundary layer can be modeled, from which an approximate viscous drag can be determined. Currently, only the Head's method for turbulent boundary layer computation is working. In the case of separation, a separation drag penalty is applied based on values selected in the options.","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"DuctAPE.HeadsBoundaryLayerOptions","category":"page"},{"location":"DuctAPE/advanced_usage/option/#DuctAPE.HeadsBoundaryLayerOptions-DuctAPE-advanced_usage-option","page":"Options","title":"DuctAPE.HeadsBoundaryLayerOptions","text":"struct HeadsBoundaryLayerOptions\n\nFields:\n\nmodel_drag::Tb=false : flag to turn on viscous drag approximation\nn_steps::Int = Int(2e2) : number of steps to use in boundary layer integration\nfirst_step_size::Float = 1e-6 : size of first step in boundary layer integration\noffset::Float = 1e-3 : size of offset for (where to initialize) boundary layer integration\nrk::Function = RK4 : solver to use for boundary layer integration (RK4 or RK2 available)\nseparation_criteria::Float=3.0 : value of H12 after which separation should happen.\nseparation_allowance_upper::Int=10 : upper side allowance for how many steps ahead of the trailing edge we'll allow separation without penalty\nseparation_allowance_lower::Int=10 : lower side allowance for how many steps ahead of the trailing edge we'll allow separation without penalty\nseparation_penalty_upper::Float=0.2 : upper side maximum penalty value for separation (at leading edge)\nseparation_penalty_lower::Float=0.2 : lower side maximum penalty value for separation (at leading edge)\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"Here is an example of a possible boundary layer option setting:","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"# Define Boundary Layer Settings\nboundary_layer_options = DuctAPE.HeadsBoundaryLayerOptions(;\n    model_drag=true,\n    separation_penalty_upper=0.1,\n    separation_penalty_lower=0.1,\n    separation_allowance_upper=3,\n    separation_allowance_lower=25,\n)\n\n# set all the options\nDuctAPE.set_options(;\n    integration_options=integration_options,\n    grid_solver_options=wake_solve_options,\n    solver_options=aero_solver_options,\n    boundary_layer_options=boundary_layer_options,\n)","category":"page"},{"location":"DuctAPE/advanced_usage/option/#Advanced-Options-for-Multi-point-analyses","page":"Options","title":"Advanced Options for Multi-point analyses","text":"","category":"section"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"For using advanced options in multi-point analyses, there are various changes that need to be made to avoid run-time errors. Here is an example for setting options with the CSOR solver.","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"# number of operating points to analyze\nnop = 3\n\noptions = DuctAPE.set_options(;\n    solver_options=DuctAPE.ModCSORSolverOptions(;\n        converged=fill(false, (1, nop)), # need a convergence flag for each operating point\n        iterations=zeros(Int, (1, nop)), # need a iteration count for each operating point\n    ),\n    write_outputs=fill(false, nop), # we need to know which of the operating point outputs to write\n    outfile=fill(\"\", nop), # we need to include names, even if they won't be used.\n    output_tuple_name=fill(\"outs\", nop), # we need to include names, even if they won't be used.\n)","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"If using a poly-algorithm with a multi-point solve, then each of the solvers needs to have the multiple converged and iterations fields for each operating point, and the overall solve type needs to have a converged and iterations field for each solver and each operating point.","category":"page"},{"location":"DuctAPE/advanced_usage/option/","page":"Options","title":"Options","text":"options = DuctAPE.set_options(;\n    solver_options=DuctAPE.ChainSolverOptions(;\n        solvers=[ # vector of solvers to use in poly-algorithm\n            DuctAPE.NLsolveOptions(;\n                algorithm=:anderson,\n                atol=1e-12,\n                iteration_limit=200,\n                converged=fill(false, (1, nop)), # flags for each operating point\n                iterations=zeros(Int, (1, nop)), # counters for each operating point\n            ),\n            DuctAPE.MinpackOptions(;\n                atol=1e-12,\n                iteration_limit=100,\n                converged=fill(false, (1, nop)),\n                iterations=zeros(Int, (1, nop)),\n            ),\n        ],\n        converged=fill(false, (2, nop)), # flags for each solver and each operating point\n        iterations=zeros(Int, (2, nop)), # counts for each solver and each operating point\n    ),\n)","category":"page"},{"location":"C4Blade/airfoil_types/cascade/#Cascade-Types","page":"Cascade Types","title":"Cascade Types","text":"","category":"section"},{"location":"C4Blade/airfoil_types/cascade/","page":"Cascade Types","title":"Cascade Types","text":"warning: Warning\nCascade types are currently in development and not ready for general use.","category":"page"},{"location":"C4Blade/airfoil_types/cascade/","page":"Cascade Types","title":"Cascade Types","text":"Cascade types are defined analogous to CCBlade airfoil types. Instead of angle of attack, however, cascade types take in both inflow and stagger angles. In addition, cascade types are dependent on local solidity.","category":"page"},{"location":"C4Blade/airfoil_types/cascade/","page":"Cascade Types","title":"Cascade Types","text":"Modules = [DuctAPE.C4Blade]\nPages = [\"C4Blade/cascades.jl\"]","category":"page"},{"location":"C4Blade/airfoil_types/cascade/#DuctAPE.C4Blade.InReStSoMaCAS","page":"Cascade Types","title":"DuctAPE.C4Blade.InReStSoMaCAS","text":"InReStSoMaCAS(inflow, Re, stagger, solidity, Mach, cl, cd, info)\nInReStSoMaCAS(inflow, Re, stagger, solidity, Mach, cl, cd)\nInReStSoMaCAS(filenames::Matrix{String}; radians=true)\n\nData is fit recursively with Akima splines.\n\nArguments:\n\ninflow::Vector{Float64}: inflow angles\nRe::Vector{Float64}: Reynolds numbers\nstagger::Vector{Float64}: stagger angles\nsolidity::Vector{Float64}: local solidity\nMach::Vector{Float64}: Mach numbers\ncl::Array{Float64}: lift coefficients where cl[i, j, k, ell] corresponds to stagger[i], Re[j], Mach[k], solidity[ell]\ncd::Array{Float64}: drag coefficients where cd[i, j, k, ell] corresponds to stagger[i], Re[j], Mach[k], solidity[ell]\ninfo::String: a description of this airfoil data (just informational)\n\nor files with one per Re/Stagger/Solidty/Mach combination\n\nArguments:\n\nfilenames::Matrix{String}: name/path of files to read in.  filenames[i, j, k, ell] corresponds to Re[i] Stagger[j] Stagger[k] and Solidity[k] with each in ascending order.\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"C4Blade/airfoil_types/cascade/#DuctAPE.C4Blade.interp5d-NTuple{12, Any}","page":"Cascade Types","title":"DuctAPE.C4Blade.interp5d","text":" interp5d(interp1d, x1data, x2data, x3data, x4data, fdata, x1pt, x2pt, x3pt, x4pt)\n\nSame as FLOWMath.interp4d, ex1cept in five dimensions.\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/airfoil_types/cascade/#DuctAPE.C4Blade.parsecascadefile-Tuple{Any, Any}","page":"Cascade Types","title":"DuctAPE.C4Blade.parsecascadefile","text":"parsefile(filename, radians, solidity)\n\nCascade version of parsefile function from CCBlade. Assumes stagger is given before reynolds and Mach number, and solidity is given after\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/airfoil_types/cascade/#DuctAPE.C4Blade.writecascadefile-NTuple{10, Any}","page":"Cascade Types","title":"DuctAPE.C4Blade.writecascadefile","text":"writecascadefile(filename, info, Re, Mach, stagger, inflow, cl, cd, radians)\n\nCascade version of writecascadefile function from CCBlade. Writes solidity after Mach number\n\n\n\n\n\n","category":"method"},{"location":"DuctAPE/visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"DuctAPE/visualization/","page":"Visualization","title":"Visualization","text":"There are several convenience plotting methods implemented in DuctAPE based on RecipesBase. In addition a general function for plotting the suite of available plots or animations is provided in the generate_plots function.","category":"page"},{"location":"DuctAPE/visualization/","page":"Visualization","title":"Visualization","text":"DuctAPE.generate_plots","category":"page"},{"location":"DuctAPE/visualization/#DuctAPE.generate_plots-DuctAPE-visualization","page":"Visualization","title":"DuctAPE.generate_plots","text":"generate_plots(\n    ::staticPlots, (or ::animatedPlots)\n    Plots,\n    ins,\n    outs;\n    save_path=\"\",\n    static_file_type=\".pdf\",\n    suffix=nothing,\n    plot_geometry=true,\n    plot_pressure=false,\n    plot_velocity=false,\n    plot_boundary_layer=false,\n    plot_streamlines=false,\n    verbose=false,\n    kwargs...,\n)\n\nGenerate standard suite of plots or animations from input and output objects.\n\nArguments:\n\n::staticPlots (or ::animatedPlots) :\nPlots:: : the Plots package namespace\nins::NamedTuple : returned inputs from analyze function\nouts::Vector{NamedTuple} : retured outputs from analyze function\n\nKeyword Arguments:\n\nsave_path=\"\" : custom save path\nstatic_file_type=\".pdf\" : file type for static files (must be compatible with the desired backend)\nsuffix=nothing : custom suffixes, if unused plots files will be numbered starting from 1.\nplot_geometry=true : flag to generate geometry plot\nplot_panels=false : flag to include markers indicating panel edges in geometry plot\nplot_pressure=false : flag to generate surface pressures plot\nplot_velocity=false : flag to generate surface velocities plot\nplot_boundary_layer=false : flag to generate boundary layer plot\nplot_streamlines=false : flag to generate streamlines plot\nverbose=false : print verbose statements\nkwargs... : arguments passed into the plot functions (Plots keyword arguments/defaults to be used in every plot)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/visualization/","page":"Visualization","title":"Visualization","text":"using DuctAPE\ninclude(\"../assets/plots_default.jl\")\ngr()","category":"page"},{"location":"DuctAPE/visualization/","page":"Visualization","title":"Visualization","text":"The following generates animations across the given advance ratios.","category":"page"},{"location":"DuctAPE/visualization/","page":"Visualization","title":"Visualization","text":"warning: Plotting Streamlines\nCurrently, plotting streamlines, especially animations, takes an exceptionally long time.","category":"page"},{"location":"DuctAPE/visualization/","page":"Visualization","title":"Visualization","text":"using Plots\n\n# - Advance Ratio Range - #\nadvance_ratios = range(0.1, 2.0; step=0.01)\n\n# - Calculate Vinfs - #\nD = 2.0 * rotor.Rtip[1] # rotor diameter\nn = RPM / 60.0 # rotation rate in revolutions per second\nVinfs = advance_ratios * n * D\n\n# - Set Operating Points - #\noperating_points = [deepcopy(operating_point) for i in 1:length(Vinfs)]\nfor (iv, v) in enumerate(Vinfs)\n    operating_points[iv].Vinf[] = v\nend\n\n# - Run Multi-point Analysis - #\nouts, ins, success_flags = DuctAPE.analyze(\n    ducted_rotor,\n    operating_points,\n    reference_parameters,\n    DuctAPE.set_options(\n        operating_points;\n        boundary_layer_options=DuctAPE.HeadsBoundaryLayerOptions(;\n            model_drag=true, n_steps=1000, separation_criteria=3.0\n        ),\n    );\n    return_inputs=true,\n)\n\nDuctAPE.generate_plots(\n    DuctAPE.animatedPlots(),\n    Plots, # Pass in the Plots namespace\n    ins,\n    outs;\n    plot_pressure=true,\n    plot_velocity=true,\n    plot_boundary_layer=true,\n    plot_streamlines=true,\n    save_path=\"../assets/\",\n    static_file_type=\".png\",\n    (;\n        custom_defaults...,\n        # size=(600,400), # causes misalignment issues\n        cp_ylim=(-3, 3), # keyword argument to set ylim for cp plots\n        vtan_ylim=(0, 3), # keyword argument to set ylim for vtan plots\n        bl_ylim=(0.1, 0.25), # keyword argument to set ylim for boundary layer plots\n    )...,\n)\nnothing # hide","category":"page"},{"location":"DuctAPE/visualization/","page":"Visualization","title":"Visualization","text":"note: Custom Defaults\nAdditional arguments splatted into generate_plots are passed into Plots.plot directly as keyword arguments.  In this case, custom_defaults happens to be the defaults associated with the plot formatting used in these docs.  Any arguments passed in this way will override any options set in the plots recipes for all the plots.  In the plots shown here, we have overridden the color palatte, but nothing else.","category":"page"},{"location":"DuctAPE/visualization/","page":"Visualization","title":"Visualization","text":"warning: Custom Sizes\nFor some reason, specifying figure size causes misalignment with pressure and velocity distributions and the underlayed geometry.","category":"page"},{"location":"DuctAPE/visualization/","page":"Visualization","title":"Visualization","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"C4Blade/corrections/#Airfoil-Polar-Corrections","page":"Polar Modification","title":"Airfoil Polar Corrections","text":"","category":"section"},{"location":"C4Blade/corrections/","page":"Polar Modification","title":"Polar Modification","text":"In some cases various airfoil polar corrections may be required. Of specific note are modifications to airfoil polars for post-stall behavior. Thus far, DuctAPE is much more robust if the post-stall behavior in the lift polars does not exhibit a decrease in lift at angles of attack beyond that of the maximum lift coefficient. Therefore a function is provided to help modify polars as needed:","category":"page"},{"location":"C4Blade/corrections/","page":"Polar Modification","title":"Polar Modification","text":"DuctAPE.C4Blade.stall_limiters","category":"page"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.stall_limiters","page":"Polar Modification","title":"DuctAPE.C4Blade.stall_limiters","text":"stall_limiters(\n    aoa,\n    cl,\n    cd;\n    clminid=nothing,\n    clmaxid=nothing,\n    cl_cutoff_slope=0.1,\n    cd_cutoff_slope=0.9,\n    N=20,\n    blend_hardness=50\n)\n\nCuts off coefficient vs alpha curve at min and max coefficient and places rest of curve from -pi to min coeff and max coeff to pi according to user defined clcutoffslope (default 0.1)\n\nArguments:\n\naoa::AbstractVector{Float} : input angles of attack, in radians\ncl::AbstractVector{Float} : input lift coefficients\ncd::AbstractVector{Float} : input drag coefficients\n\nKeyword Arguments:\n\nclminid::Float=nothing : manually set index for minimum cl\nclmaxid::Float=nothing : manually set index for maximum cl\ncl_cutoff_slope::Float=0.1 : \"post-stall\" slope for cl\ncd_cutoff_slope::Float=0.1 : \"post-stall\" slope for cd\nblend_hardness::Float=50 : hardenss of blend between nominal polar and post-stall modifications.\n\nReturns:\n\naoa_ext::AbstractVector{Float} : angles of attack for modified polar, in radians\ncl_ext::AbstractVector{Float} : modified lift coefficients\ncd_ext::AbstractVector{Float} : modified drag coefficients\n\n\n\n\n\n","category":"function"},{"location":"C4Blade/corrections/","page":"Polar Modification","title":"Polar Modification","text":"Various other correction methods are available, including the cascade corrections inherent in the DuctAPE.C4Blade.DFDCairfoil type. The following methods are in addition to the various corrections available alongside the CCBlade Airfoil Types.","category":"page"},{"location":"C4Blade/corrections/","page":"Polar Modification","title":"Polar Modification","text":"Modules = [DuctAPE.C4Blade]\nPages = [\"C4Blade/airfoil_corrections.jl\"]","category":"page"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.corrected_clcd-Tuple{DuctAPE.C4Blade.AlphaReAF, Vararg{Any, 9}}","page":"Polar Modification","title":"DuctAPE.C4Blade.corrected_clcd","text":"corrected_clcd(af::AlphaReAF, alpha, Re, Mach, solidity, stagger; kwargs...)\n\nEvaluates and applies on-the-fly corrections for airfoil lift and drag. On-the-fly airfoil polar corrections include solidity/stagger corrections, Prandtl-Glauert compressibility corrections, and transonic lift limits and drag additions.\n\ncorrected_clcd!(cl, cd, af::AlphaReAF, Re, alpha, Mach, solidity, stagger; kwargs...)\n\nEvaluates and applies on-the-fly corrections for airfoil lift and drag in place.\n\ncorrected_clcd!(cl, cd, Mach, solidity, stagger; kwargs...)\n\nApplies on-the-fly corrections for airfoil lift and drag in place.\n\ncorrected_clcd!(cl, cd, af::AlphaAF, alpha, Re, Mach, solidity, stagger; kwargs...)\n\nEvaluates and applies on-the-fly corrections, including Reynolds corrections, for airfoil lift and drag in place\n\ncorrected_clcd(cas::InReStSoMaCAS, inflow, Re, Mach, solidity, stagger)\n\nEvaluates cascade lift and drag.\n\nArguments:\n\nCoefficients\n\ncl::Float : local lift coefficient\ncd::Float : local drag coefficient\n\nAirfoil Object\n\naf::AlphaReAF : airfoil object of CCBlade type dependent on angle of attack and Reynolds number\n\nor\n\naf::AlphaAF : airfoil object of CCBlade type dependent on angle of attack only\n\nor\n\ncas::InReStSoMaCAS : cascade object depentent on inflow angle, Reynolds number, stagger, solidity, and Mach number.\n\nFlow Angle\n\nalpha::Float : angle of attack, radians.  Used with airfoil types\n\nor\n\ninflow::Float : inflow angle, radians.  Used with cascade types\n\nFlow Conditions\n\nRe::Float : Reynolds number\nMach::Float : Mach number\n\nGeometry\n\nsolidity::Float : Local solidity\nstagger::Float : Stagger angle, radians\n\nKeyword Arguments:\n\nmcrit::Float=0.7 : Critical Mach number\n\nrotorzloc airfoil type parameters for post-stall behavior\n\ndcl_stall::Float=0.1 : change in cl from incipient to total stall, used in transonic lift limiter correction\ndclda_stall::Float=0.1 : Post-stall lift curve slope\n\nCorrection factors that were hard coded in rotorzloc and DFDC\n\ncdmfactor::Float=10.0 :\nclmfactor::Float=0.25 :\nmexp::Float=3.0 :\ncdmstall::Float=0.1 :\ncdmdd::Float=0.0020 :\n\nSmoothing Paramters\n\nssblend_hardness::Float=100.0 : sigmoid blending hardness for solidity/stagger corrections\ntransblendhardness::Float=75.0 : sigmoid blending hardness for transonic corrections\nabsdx::Float=0.0625 : smooth absolute value  (radians) for transonic drag addition\n\nMiscellaneous\n\nverbose::Bool=false : Boolean of whether to print warnings, etc.\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.prandtl_glauert!-Tuple{Any, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.prandtl_glauert!","text":"prandtl_glauert!(cl, ma)\n\nIn place version of pradtl_glauert.\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.prandtl_glauert-Tuple{Any, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.prandtl_glauert","text":"prandtl_glauert(cl, ma)\n\nApplies Prandtl-Glauert correction\n\nArguments:\n\ncl::Float : local lift coefficient\n\nReturns\n\ncl_corr::AbstractVector{Float} : corrected lift coefficients\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.prandtl_glauert_factor-Tuple{Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.prandtl_glauert_factor","text":"prandtl_glauert_factor(mach; verbose=false, blend_range=0.02)\n\nSmoothed Prandtl-Glauert Mach correction factor\n\nArguments:\n\nmach::Float : Mach number\n\nKeyword Arguments:\n\nblend_range::Float=0.02 : range for blending factor and max cutoff (allowing Mach >= 1.0 for continuity)\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.quadspline-Tuple{Any, Any, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.quadspline","text":"quadspline(xdata, ydata, xpoint)\n\nSample data in quadratic spline at give point.\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.re_drag!-Tuple{Any, Any, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.re_drag!","text":"re_drag!(cd, re, re_ref; re_exp=0.5)\n\nIn-place version of re_drag.\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.re_drag-Tuple{Any, Any, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.re_drag","text":"re_drag(cd, re, re_ref; re_exp=0.5)\n\nArguments:\n\ncd::AbstractVector{Float} : input drag coefficients\nre::Float : Current Reynolds number\nre_ref::Float : Reference Reynolds number (at which the cd's were generated)\n\nKeyword Arguments:\n\nre_exp::Float=0.5 : should be 0.2 for laminar and 0.5 for turbulent flow\n\nReturns:\n\ncd_corr::AbstractVector{Float} : Reynolds corrected drag coefficients\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.solidity_and_stagger!-Tuple{Any, Any, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.solidity_and_stagger!","text":"solidity_and_stagger!(cl, solidity, stagger; blend_hardness=100)\n\nIn-place version of solidity_and_stagger.\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.solidity_and_stagger-Tuple{Any, Any, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.solidity_and_stagger","text":"solidity_and_stagger(cl, solidity, stagger; blend_hardness=100)\n\nApply smoothed Wallis' cascade correction (see solidity_and_stagger_factor_smooth) to local lift.\n\nArguments:\n\ncl::AbstractVector{Float} : input lift coefficients\nsolidity::Float : local solidity\nstagger::Float : local stagger (in radians)\n\nKeyword Arguments:\n\nblend_hardness::Float=100 : hardness of smoothing blends\n\nReturns:\n\ncl_corr::AbstractVector{Float} : corrected lift coefficients.\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.solidity_and_stagger_factor-Tuple{Any, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.solidity_and_stagger_factor","text":"solidity_and_stagger_factor(solidity, stagger; blend_hardness=100)\n\nCorrection for airfoil data used in a high-solidity cascade application. Correction is used in DFDC airfoils nominally and come from quadratic fits to curves in fig 6-29 \"Axial Flow Fans and Ducts\" by Wallis (1983). Note that the corrections are really only meant for Wallis' custom airfoil design and specific conditions mentioned in the book.\n\nArguments:\n\nsolidity::Float : local solidity\nstagger::Float : local stagger (in radians)\n\nKeyword Arguments:\n\nblend_hardness::Float=100 : hardness for smoothing blends\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.solidity_and_stagger_factor_smooth-Tuple{Any, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.solidity_and_stagger_factor_smooth","text":"solidity_and_stagger_factor_smooth(solidity, stagger; blend_hardness=100)\n\nA smoothed version of solidity_and_stagger_factor.\n\nArguments:\n\nsolidity::Float : local solidity\nstagger::Float : local stagger (in radians)\n\nKeyword Arguments:\n\nblend_hardness::Float=100 : hardness for smoothing blends\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.stall_limiters-Tuple{Any, Any, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.stall_limiters","text":"stall_limiters(\n    aoa,\n    cl,\n    cd;\n    clminid=nothing,\n    clmaxid=nothing,\n    cl_cutoff_slope=0.1,\n    cd_cutoff_slope=0.9,\n    N=20,\n    blend_hardness=50\n)\n\nCuts off coefficient vs alpha curve at min and max coefficient and places rest of curve from -pi to min coeff and max coeff to pi according to user defined clcutoffslope (default 0.1)\n\nArguments:\n\naoa::AbstractVector{Float} : input angles of attack, in radians\ncl::AbstractVector{Float} : input lift coefficients\ncd::AbstractVector{Float} : input drag coefficients\n\nKeyword Arguments:\n\nclminid::Float=nothing : manually set index for minimum cl\nclmaxid::Float=nothing : manually set index for maximum cl\ncl_cutoff_slope::Float=0.1 : \"post-stall\" slope for cl\ncd_cutoff_slope::Float=0.1 : \"post-stall\" slope for cd\nblend_hardness::Float=50 : hardenss of blend between nominal polar and post-stall modifications.\n\nReturns:\n\naoa_ext::AbstractVector{Float} : angles of attack for modified polar, in radians\ncl_ext::AbstractVector{Float} : modified lift coefficients\ncd_ext::AbstractVector{Float} : modified drag coefficients\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.transonic_drag_addition!-NTuple{4, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.transonic_drag_addition!","text":"transonic_drag_addition!(\n    cd,\n    cl,\n    clcdmin,\n    mach;\n    mcrit=0.7,\n    cdmfactor=10.0,\n    clmfactor=0.25,\n    mexp=3.0,\n    cdmdd=0.0020,\n    cdmstall=0.1000,\n    absdx=0.0625,\n    blend_hardness=50,\n)\n\nSmoothed, vecotrized, in-place version of transonic_drag_addition.\n\nDifferent Arguments:\n\ncd::AbstractVector{Float} : vector of drag coefficients\ncl::AbstractVector{Float} : vector of lift coefficients\n\nAdditional Keyword Argument:\n\nblend_hardness::Float=50 : hardenss of smoothing blends\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.transonic_drag_addition-NTuple{4, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.transonic_drag_addition","text":"transonic_drag_addition(\n    cd,\n    cl,\n    clcdmin,\n    mach;\n    mcrit=0.7,\n    cdmfactor=10.0,\n    clmfactor=0.25,\n    mexp=3.0,\n    cdmdd=0.0020,\n    cdmstall=0.1000,\n    absdx=0.0625,\n)\n\nDrag augmentation due to transonic effects as found in XROTOR and DFDC. Note this is nominally applied to DFDC airfoil evaluation.\n\nArguments:\n\ncd::Float : input drag coefficient\ncl::Float : input lift coefficient\nclcdmin::Float : lift coefficient at minimum drag coefficient.\nmach::Float : Mach number\n\nKeyword Arguments\n\nmcrit::Float=0.7 : critical Mach number\ncdmfactor::Float=10.0 : factor hard coded in XROTOR and DFDC\nclmfactor::Float=0.25 : factor hard coded in XROTOR and DFDC\nmexp::Float=3.0 : factor hard coded in XROTOR and DFDC\ncdmstall::Float=0.1000 : factor hard coded in XROTOR and DFDC\nabsdx::Float=0.0625 : smoothing factor for smooth absolute value function\n\nReturns:\n\ncl_corr:Float : corrected lift coefficient\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.transonic_lift_limiter-NTuple{6, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.transonic_lift_limiter","text":"transonic_lift_limiter(\n    cl,\n    mach,\n    clcdmin,\n    clmax,\n    clmin,\n    dclda;\n    mcrit=0.7,\n    dcl_stall=0.1,\n    dclda_stall=0.1,\n    cdmfactor=10.0,\n    clmfactor=0.25,\n    mexp=3.0,\n    cdmstall=0.1000,\n)\n\nAirfoil polar corrections due to transonic effects as found in XROTOR and DFDC. Note that this correction is done nominally in the DFDC airfoil evaluation.\n\nArguments:\n\ncl::Float : input lift coefficient\nmach::Float : Mach number\nclcdmin::Float : lift coefficient at minimum drag coefficient.\nclmax::Float : maximum lift coefficient\nclmin::Float : minimum lift coefficient\ndclda::Float : lift-curve slope\nmcrit::Float=0.7 : critical Mach number\ndcl_stall::Float=0.1 : cl increment from initial to total stall\ndclda_stall::Float=0.1 :  lift curve slope post-stall (1/radians)\ncdmfactor::Float=10.0 : factor hard coded in XROTOR and DFDC\nclmfactor::Float=0.25 : factor hard coded in XROTOR and DFDC\nmexp::Float=3.0 : factor hard coded in XROTOR and DFDC\ncdmstall::Float=0.1000 : factor hard coded in XROTOR and DFDC\n\nReturns:\n\ncl_corr:Float : corrected lift coefficient\n\n\n\n\n\n","category":"method"},{"location":"C4Blade/corrections/#DuctAPE.C4Blade.transonic_lift_limiter_smooth!-NTuple{6, Any}","page":"Polar Modification","title":"DuctAPE.C4Blade.transonic_lift_limiter_smooth!","text":"transonic_lift_limiter_smooth!(\n    cl,\n    mach,\n    clcdmin,\n    clmax,\n    clmin,\n    dclda;\n    mcrit=0.7,\n    dcl_stall=0.1,\n    dclda_stall=0.1,\n    cdmfactor=10.0,\n    clmfactor=0.25,\n    mexp=3.0,\n    cdmstall=0.1000,\n    blend_hardness=50,\n)\n\nSmoothed, vectorized, in-place version of transonic_lift_limiter.\n\nDifferent Arguments:\n\ncl::AbstractVector{Float} : vector of lift coefficients\n\nAdditional Keyword Argument:\n\nblend_hardness::Float=50 : hardenss of smoothing blends\n\n\n\n\n\n","category":"method"},{"location":"DuctAPE/api/private_postprocess/","page":"Postprocess","title":"Postprocess","text":"Pages = [\"private_postprocess.md\"]\nDepth = 5","category":"page"},{"location":"DuctAPE/api/private_postprocess/","page":"Postprocess","title":"Postprocess","text":"DuctAPE.post_process","category":"page"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.post_process","page":"Postprocess","title":"DuctAPE.post_process","text":"post_process(\n    solver_options,\n    converged_states,\n    prepost_containers,\n    solve_container_caching,\n    solve_parameter_cache_vector,\n    solve_parameter_cache_dims,\n    operating_point,\n    reference_parameters,\n    boundary_layer_options,\n    A_bb_LU,\n    airfoils,\n    idmaps,\n    problem_dimensions,\n    multipoint_index;\n    write_outputs=options.write_outputs,\n    outfile=options.outfile,\n    checkoutfileexists=options.checkoutfileexists,\n    output_tuple_name=options.output_tuple_name,\n    verbose=options.verbose,\n)\n\nPost-process a converged nonlinear solve solution.\n\nArguments\n\nsolver_options::SolverOptionsType : A SolverOptionsType object (also used for dispatch)\nconverged_states::Vector{Float} : the converged state variables\nprepost_containers::NamedTuple : the named tuple containing pre-allocated containers for the pre- and post-processing intermediate calculations\nsolve_container_cache::NamedTuple : the cache and dimensions for intermediate values in the residual calculation\nsolve_parameter_cache_vector::Vector{Float} : the applicably typed cache vector for the solve parameters\nsolve_parameter_cache_dims::NamedTuple : the dimensions of the solver parameters\noperating_point::OperatingPoint : the operating point being analyzed\nreference_parameters::ReferenceParameters : a ReferenceParameters object\nBoundaryLayerOptions::BoundaryLayerOptions : a BoundaryLayerOptions object\nA_bb_LU::LinearAlgebra.LU : LinearAlgebra LU factorization of the LHS matrix\nairfoils::Vector{AFType} : A matrix of airfoil types associated with each of the blade elements\nidmaps::NamedTuple : A named tuple containing index mapping used in bookkeeping throughout solve and post-process\nproblem_dimensions::ProblemDimensions : A ProblemDimensions object\n\nKeyword Arguments\n\nmultipoint_index::Vector{Int} : a one-dimensional vector containing the index of which multipoint analysis operating point is being analyzed.\nwrite_outputs=options.write_outputs::Vector{Bool} : a vector with the same length as number of multipoints indicating if the outputs should be saved.\noutfile=options.outfile::Vector{String} : a vector of file paths/names for where outputs should be written\ncheckoutfileexists=options.checkoutfileexists::Bool : a flag for whether existing files should be checked for or if blind overwriting is okay.\noutput_tuple_name=options.output_tuple_name::Vector{String} : the variable name(s) of the named tuple of outputs to be written.\nverbose::Bool=false : flag to print verbose statements\n\nReturns\n\nouts::NamedTuple : A named tuple containing all the output values including\n\nbodies\npanel_strengths\ntotal_thrust\nthrust_comp\ninduced_efficiency\ncp_in\ncp_out\ncp_casing_in\ncp_casing_out\ncasing_zpts\ncp_nacelle_in\ncp_nacelle_out\nnacelle_zpts\ncp_centerbody_in\ncp_centerbody_out\ncenterbody_zpts\nVtot_in\nVtot_out\nVtot_prejump\nvtot_body\nvtot_jump\nvtot_wake\nvtot_rotors\nVtan_in\nVtan_out\nvtan_casing_in\nvtan_casing_out\nvtan_nacelle_in\nvtan_nacelle_out\nvtan_centerbody_in\nvtan_centerbody_out\nboundary_layers\nstagnation_indices\nupper_solved_states\nupper_solved_steps\nlower_solved_states\nlower_solved_steps\nsurface_length_upper\nsurface_length_lower\nsplit_ratio\nseparation_point_ratio_upper\nseparation_point_ratio_lower\nrotors\ncirculation\npanel_strengths\nefficiency\ninviscid_thrust\ninviscid_thrust_dist\nviscous_thrust\nviscous_thrust_dist\nthrust\nCT\ninviscid_torque\ninviscid_torque_dist\nviscous_torque\nviscous_torque_dist\ntorque\nCQ\ninviscid_power\ninviscid_power_dist\nviscous_power\nviscous_power_dist\npower\nCP\ncl\ncd\nalpha\nbeta1\nblade_normal_force_per_unit_span\nblade_tangential_force_per_unit_span\nwake\npanel_strengths\ntotals\nthrust\ntorque\npower\nCT\nCQ\nCP\ntotal_efficiency\nideal_efficiency\nintermediate_solve_values\nvz_rotor\nvtheta_rotor\nCm_wake\nreynolds\nmach\nCz_rotor\nCtheta_rotor\nCmag_rotor\nGamma_tilde\nH_tilde\ndeltaGamma2\ndeltaH\nvz_wake\nvr_wake\nCm_avg\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#Velocities","page":"Postprocess","title":"Velocities","text":"","category":"section"},{"location":"DuctAPE/api/private_postprocess/","page":"Postprocess","title":"Postprocess","text":"DuctAPE.get_body_tangential_velocities\nDuctAPE.get_body_tangential_velocities!\nDuctAPE.calculate_vtheta\nDuctAPE.calculate_induced_velocities_on_bodywake","category":"page"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.get_body_tangential_velocities","page":"Postprocess","title":"DuctAPE.get_body_tangential_velocities","text":"get_body_tangential_velocities(\n    gamb,\n    gamw,\n    sigr,\n    ivb,\n    Vinf,\n    totnode,\n    totpanel,\n    nnode,\n    npanel,\n    tangent,\n    controlpoints,\n    endpanelidxs,\n    wake_panel_ids_along_centerbody_wake_interface,\n    wake_panel_ids_along_casing_wake_interface,\n    centerbody_panel_ids_along_centerbody_wake_interface,\n    duct_panel_ids_along_casing_wake_interface,\n    num_casing_panels,\n)\n\nGet the tangential velocities along the body surfaces.\n\nArguments\n\ngamb::Vector{Float} : the body panel strengths\ngamw::Vector{Float} : the wake panel strengths\nsigr::Vector{Float} : the rotor panel strengths\nivb::NamedTuple : the unit induced velocities on the bodies\nVinf::Vector{Float} : one element vector containing the freestream magnitude\ntotnode::Int : total number of nodes between all bodies\ntotpanel::Int : total number of panels between all bodies\nnnode::Vector{Int} : number of nodes in each body\nnpanel::Vector{Int} : number of panels in each body.\ntangent::Matrix{Float} : unit tangent vectors for each panel\ncontrolpoints::Matrix{Float} : control point locations for each panel\nendpanelidxs::Matrix{Int} : the indices of the first and last panels for each body\nwake_panel_ids_along_centerbody_wake_interface::Vector{Int} : the indices of the wake panels coincident with the centerbody panels\nwake_panel_ids_along_casing_wake_interface::Vector{Int} : the indices of the wake panels coincident with the duct casing (inner surface) panels\ncenterbody_panel_ids_along_centerbody_wake_interface::Vector{Int} : the indices of the centerbody panels coincident with the wake panels\nduct_panel_ids_along_casing_wake_interface::Vector{Int} : the indices of the duct panels coincident with the wake panels\nnum_casing_panels::Int : the number of panels between the leading and trailing edge of the duct on the duct inner side (casing)\n\nReturns\n\nvtan_tuple::NamedTuple : a named tuple containing the body tangential surface velocities and various useful breakdowns thereof.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.get_body_tangential_velocities!","page":"Postprocess","title":"DuctAPE.get_body_tangential_velocities!","text":"function getbodytangentialvelocities!(     vtantuple,     gamb,     gamw,     sigr,     ivb,     Vinf,     totnode,     totpanel,     nnode,     npanel,     tangent,     controlpoints,     endpanelidxs,     wakepanelidsalongcenterbodywakeinterface,     wakepanelidsalongcasingwakeinterface,     centerbodypanelidsalongcenterbodywakeinterface,     ductpanelidsalongcasingwakeinterface,     zpts, )\n\nIn-place version of get_body_tangential_velocities.\n\nAdditional Arguments\n\nzpts::NamedTuple : a named tuple containing the z-coordinates of the control points of the duct casing, duct nacelle, and centerbody.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.calculate_vtheta","page":"Postprocess","title":"DuctAPE.calculate_vtheta","text":"calculate_vtheta(Gamma_tilde, r)\n\nCalculate tangential velocity for a given net circulation and radial location\n\nArguments\n\nGamma_tilde::Matrix{Float} : Sum of upstream circulation values\nr::Matrix{Float} : blade element radial positions\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.calculate_induced_velocities_on_bodywake","page":"Postprocess","title":"DuctAPE.calculate_induced_velocities_on_bodywake","text":"calculate_induced_velocities_on_bodywake(\n    vz_w, vr_w, gamw, vz_r, vr_r, sigr, vz_b, vr_b, gamb, Vinf\n)\n\nCalculate the induced velocities on one of the body wakes (unit velocity inputs determine which one)\n\nArguments\n\nvz_w::Matrix{Float} : unit axial induced velocity of the wake onto the body wake\nvr_w::Matrix{Float} : unit radial induced velocity of the wake onto the body wake\ngamw::Vector{Float} : wake panel strengths\nvz_r::Matrix{Float} : unit axial induced velocity of the rotor onto the body wake\nvr_r::Matrix{Float} : unit radial induced velocity of the rotor onto the body wake\nsigr::Vector{Float} : rotor panel strengths\nvz_b::Matrix{Float} : unit axial induced velocity of the bodies onto the body wake\nvr_b::Matrix{Float} : unit radial induced velocity of the bodies onto the body wake\ngamb::Vector{Float} : body panel strengths\nVinf::Vector{Float} : one element vector containing the velocity magnitude\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#Pressures","page":"Postprocess","title":"Pressures","text":"","category":"section"},{"location":"DuctAPE/api/private_postprocess/","page":"Postprocess","title":"Postprocess","text":"DuctAPE.steady_cp\nDuctAPE.steady_cp!\nDuctAPE.calculate_entropy_jumps\nDuctAPE.calculate_rotor_jumps\nDuctAPE.delta_cp\nDuctAPE.calculate_body_delta_cp!\nDuctAPE.calculate_bodywake_delta_cp\nDuctAPE.get_body_cps\nDuctAPE.get_body_cps!\nDuctAPE.get_bodywake_cps\nDuctAPE.forces_from_pressure\nDuctAPE.forces_from_pressure!\nDuctAPE.forces_from_TEpanels!","category":"page"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.steady_cp","page":"Postprocess","title":"DuctAPE.steady_cp","text":"steady_cp(Vs, Vinf, Vref)\n\nCalculate steady pressure coefficients for a given surface velocity.\n\nArguments\n\nVs::Vector{Float} : the surface velocities\nVinf::Vector{Float} : one element vector with freestream mangnitude\nVref::Vector{Float} : one element vector with reference velocity used for non-dimensionalization\n\nReturns\n\ncp::Vector{Float} : the steady pressure coefficients\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.steady_cp!","page":"Postprocess","title":"DuctAPE.steady_cp!","text":"steady_cp!(cp, Vs, Vinf, Vref)\n\nIn-place verison of steady_cp.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.calculate_entropy_jumps","page":"Postprocess","title":"DuctAPE.calculate_entropy_jumps","text":"calculate_entropy_jumps(sigr, Cz_rotor)\n\nCalculate jumps in entropy across the disks.\n\nArguments\n\nsigr::Matrix{Float} : rotor source panel strengths\nCz_rotor::Vector{Float} : absolute axial velocity on rotor blade elements\n\nReturns\n\ndeltaS::Vector{Float} : entropy jump across rotor disks\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.calculate_rotor_jumps","page":"Postprocess","title":"DuctAPE.calculate_rotor_jumps","text":"calculate_rotor_jumps(Gamr, Omega, B, sigr, Cz_rotor)\n\nCalculate net circulation and enthalpy and entropy disk jumps\n\nArguments\n\nGamr::Matrix{Float} : Blade element circulation strengths\nOmega::Vector{Float} : rotor rotation rates\nB::Vector{Float} : blade count for each rotor (usually integers but could be a float)\nsigr::Matrix{Float} : rotor source panel strengths\nCz_rotor::Vector{Float} : absolute axial velocity on rotor blade elements\n\nReturns\n\nGamma_tilde::Matrix{Float} : net upstream circulation\nHtilde::Matrix{Float} : net upstream enthalpy jumps\nStilde::Matrix{Float} : net upstream entropy jumps\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.delta_cp","page":"Postprocess","title":"DuctAPE.delta_cp","text":"delta_cp(deltaH, deltaS, Ctheta, Vref)\n\nCalculate change in pressure coefficient aft of rotor, due to rotor\n\nArguments\n\ndeltaH::Vector{Float} : Enthalpy jumps across disks\ndeltaS::Vector{Float} : Entropy jumps across disks`\nCtheta::Vector{Float} : tangenetial velocity\nVref::Vector{Float} : reference velocity for non-dimensionalization\n\nReturns\n\ndelta_cp::Vector{Float} : pressure rises due to rotor disks\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.calculate_body_delta_cp!","page":"Postprocess","title":"DuctAPE.calculate_body_delta_cp!","text":"calculate_body_delta_cp!(cp, Gamr, sigr, Cz_rotor, Vref, Omega, B, cpr, casing_panel_ids_aft_of_rotors, centerbody_panel_ids_aft_of_rotors)\n\nAugment surface pressure by change in pressure coefficient due to rotors specifically on the body panels aft of the rotors.\n\nArguments\n\ncp::Vector{Float} : steady pressure coeffients, modified in-place to include rotor effects.\nGamr::Matrix{Float} : Blade element circulation strengths\nsigr::Matrix{Float} : rotor source panel strengths\nCz_rotor::Vector{Float} : absolute axial velocity on rotor blade elements\nVref::Vector{Float} : one element vector with reference velocity used for non-dimensionalization\nOmega::Vector{Float} : rotor rotation rates\nB::Vector{Float} : blade count for each rotor (usually integers but could be a float)\ncpr::Vector{Float} : control point radial positions of body panels\ncasing_panel_ids_aft_of_rotors::Vector{Int} : duct indices of control point radial positions aft of rotors\ncenterbody_panel_ids_aft_of_rotors::Vector{Int} : centerbody indices of control point radial positions aft of rotors\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.calculate_bodywake_delta_cp","page":"Postprocess","title":"DuctAPE.calculate_bodywake_delta_cp","text":"calculate_bodywake_delta_cp(Gamr, sigr, Cz_rotor, Vref, Omega, B, cpr; body=\"duct\")\n\nCalculate change in pressure coefficient due to rotors specifically on the body wakes\n\nArguments\n\nGamr::Matrix{Float} : Blade element circulation strengths\nsigr::Matrix{Float} : rotor source panel strengths\nCz_rotor::Vector{Float} : absolute axial velocity on rotor blade elements\nVref::Vector{Float} : one element vector with reference velocity used for non-dimensionalization\nOmega::Vector{Float} : rotor rotation rates\nB::Vector{Float} : blade count for each rotor (usually integers but could be a float)\ncpr::Vector{Float} : control point radial positions of body wake \"panels\"\n\nKeyword Arguments\n\nbody::String=\"duct\" : flag as to whether the body in question is a duct or centerbody.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.get_body_cps","page":"Postprocess","title":"DuctAPE.get_body_cps","text":"getbodycps(     Vtanin,     Vtanout,     Gamr,     sigr,     Czrotor,     Vinf,     Vref,     B,     Omega,     casingpanelidsaftofrotors,     centerbodypanelidsaftof_rotors,     controlpoints,     endpanelidxs,     zpts, )\n\nDescription\n\nArguments\n\nVtan_in::Vector{Float} : Tangential velocity on the inside of the body panels\nVtan_out::Vector{Float} : Tangential velocity on the outside of the body panels\nGamr::Matrix{Float} : Blade element circulation strengths\nsigr::Matrix{Float} : rotor source panel strengths\nCz_rotor::Vector{Float} : absolute axial velocity on rotor blade elements\nVinf::Vector{Float} : one element vector with freestream mangnitude\nVref::Vector{Float} : one element vector with reference velocity used for non-dimensionalization\nB::Vector{Float} : blade count for each rotor (usually integers but could be a float)\nOmega::Vector{Float} : rotor rotation rates\ncasing_panel_ids_aft_of_rotors::Vector{Int} : duct indices of control point radial positions aft of rotors\ncenterbody_panel_ids_aft_of_rotors::Vector{Int} : centerbody indices of control point radial positions aft of rotors\ncontrolpoints::Matrix{Float} : control point locations for each panel\nendpanelidxs::Matrix{Int} : the indices of the first and last panels for each body\nzpts::NamedTuple : a named tuple containing the z-coordinates of the control points of the duct casing, duct nacelle, and centerbody.\n\nReturns\n\ncp_tuple::NamedTuple : body surface velocities and various useful breakdowns thereof.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.get_body_cps!","page":"Postprocess","title":"DuctAPE.get_body_cps!","text":"get_body_cps!(\n    cp_tuple,\n    Vtan_in,\n    Vtan_out,\n    Gamr,\n    sigr,\n    Cz_rotor,\n    Vinf,\n    Vref,\n    B,\n    Omega,\n    duct_panel_ids_aft_of_rotors,\n    centerbody_panel_ids_aft_of_rotors,\n    controlpoints,\n    endpanelidxs,\n    zpts,\n)\n\nIn-place version of get_body_cps.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.get_bodywake_cps","page":"Postprocess","title":"DuctAPE.get_bodywake_cps","text":"get_bodywake_cps(\n    Gamr,\n    vz_w,\n    vr_w,\n    gamw,\n    vz_r,\n    vr_r,\n    sigr,\n    vz_b,\n    vr_b,\n    gamb,\n    panels,\n    Cz_rotor,\n    Omega,\n    B,\n    Vinf,\n    Vref;\n    body=\"duct\",\n)\n\nCalculate the pressure coefficient distributions on one of the body wakes\n\nArguments\n\nGamr::Matrix{Float} : Blade element circulation strengths\nvz_w::Matrix{Float} : unit axial induced velocity of the wake onto the body wake\nvr_w::Matrix{Float} : unit radial induced velocity of the wake onto the body wake\ngamw::Vector{Float} : wake panel strengths\nvz_r::Matrix{Float} : unit axial induced velocity of the rotor onto the body wake\nvr_r::Matrix{Float} : unit radial induced velocity of the rotor onto the body wake\nsigr::Vector{Float} : rotor panel strengths\nvz_b::Matrix{Float} : unit axial induced velocity of the bodies onto the body wake\nvr_b::Matrix{Float} : unit radial induced velocity of the bodies onto the body wake\ngamb::Vector{Float} : body panel strengths\npanels::NamedTuple : A named tuple containing bodywake \"panel\" geometries\nCz_rotor::Vector{Float} : absolute axial velocity on rotor blade elements\nOmega::Vector{Float} : rotor rotation rates\nB::Vector{Float} : blade count for each rotor (usually integers but could be a float)\nVinf::Vector{Float} : one element vector containing the velocity magnitude\nVref::Vector{Float} : one element vector with reference velocity used for non-dimensionalization\n\nKeyword Arguments\n\nbody::String=\"duct\" : flag as to whether the body in question is a duct or centerbody.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.forces_from_pressure","page":"Postprocess","title":"DuctAPE.forces_from_pressure","text":"forces_from_pressure(cp_in, cp_out, panels; rhoinf=1.225, Vref=1.0)\n\nCalculate dimensional and non-dimensional axial force on a single body\n\nArguments\n\ncp_in::Vector{Float} : pressure coefficient on inside of body surfaces\ncp_out::Vector{Float} : pressure coefficients on outside of body surfaces\npanels::NamedTuple : A named tuple containing panel geometry information\n\nKeyword Arguments\n\nrhoinf::Float=1.225 : reference density for non-dimensionalization\nVref::Float=1.0 : reference velocity for non-dimensionalization\n\nReturns\n\nthrust::Vector{Float} : dimensional axial force\nforce_coeff::Vector{Float} : non-dimensional axial force\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.forces_from_pressure!","page":"Postprocess","title":"DuctAPE.forces_from_pressure!","text":"forces_from_pressure!(CFx, cfx, cp_in, cp_out, panels; rhoinf=1.225, Vref=1.0)\n\nIn-place version of forces_from_pressure.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.forces_from_TEpanels!","page":"Postprocess","title":"DuctAPE.forces_from_TEpanels!","text":"forces_from_TEpanels!(\n    thrust, force_coeff, cp_in, cp_out, panels; rhoinf=1.225, Vref=1.0\n)\n\nAdd force induced by trailing edge gap panels to total forces.\n\nArguments\n\nthrust::Vector{Float} : dimensional axial force\nforce_coeff::Vector{Float} : non-dimensional axial force\ncp_in::Vector{Float} : pressure coefficient on inside of body surfaces\ncp_out::Vector{Float} : pressure coefficients on outside of body surfaces\npanels::NamedTuple : A named tuple containing panel geometry information\n\nKeyword Arguments\n\nrhoinf::Float=1.225 : reference density for non-dimensionalization\nVref::Float=1.0 : reference velocity for non-dimensionalization\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#Rotor-Performance","page":"Postprocess","title":"Rotor Performance","text":"","category":"section"},{"location":"DuctAPE/api/private_postprocess/","page":"Postprocess","title":"Postprocess","text":"DuctAPE.inviscid_rotor_thrust\nDuctAPE.inviscid_rotor_thrust!\nDuctAPE.viscous_rotor_thrust\nDuctAPE.viscous_rotor_thrust!\nDuctAPE.inviscid_rotor_torque\nDuctAPE.inviscid_rotor_torque!\nDuctAPE.viscous_rotor_torque\nDuctAPE.viscous_rotor_torque!\nDuctAPE.rotor_power\nDuctAPE.rotor_power!\nDuctAPE.get_total_efficiency\nDuctAPE.get_total_efficiency!\nDuctAPE.get_induced_efficiency\nDuctAPE.get_induced_efficiency!\nDuctAPE.get_ideal_efficiency\nDuctAPE.tqpcoeff\nDuctAPE.tqpcoeff!\nDuctAPE.get_blade_loads\nDuctAPE.get_blade_loads!","category":"page"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.inviscid_rotor_thrust","page":"Postprocess","title":"DuctAPE.inviscid_rotor_thrust","text":"inviscid_rotor_thrust(Ctheta_rotor, Gamma_tilde, rotor_panel_length, rhoinf)\n\nCalculate inviscid rotor thrust.\n\nArguments\n\nCtheta_rotor::Vector{Float} : Absolute tangential velocity on rotor blade elements\nGamma_tilde::Matrix{Float} : net upstream rotor circulation\nrotor_panel_length::Vector{Float} : dimensional lengths on which blade element values apply\nrhoinf::Float : freestream density\n\nReturns\n\nTinv::Vector{Float} : inviscid dimensional thrust\ndTi::Vector{Float} : inviscid dimensional thrust distribution\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.inviscid_rotor_thrust!","page":"Postprocess","title":"DuctAPE.inviscid_rotor_thrust!","text":"inviscid_rotor_thrust!(\n    Tinv, dTi, Ctheta_rotor, Gamma_tilde, rotor_panel_length, rhoinf\n)\n\nIn-place version of inviscid_rotor_thrust.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.viscous_rotor_thrust","page":"Postprocess","title":"DuctAPE.viscous_rotor_thrust","text":"viscous_rotor_thrust(\n    Cz_rotor, Cmag_rotor, B, chord, rotor_panel_length, cd, rhoinf\n)\n\nCalculate visous rotor \"thrust.\"\n\nArguments\n\nCz_rotor::Vector{Float} : Absolute axial velocity on rotor blade elements\nCmag_rotor::Vector{Float} : Absolute inflow velocity magnitude on rotor blade elements\nB::Vector{Float} : blade count for each rotor (usually integers but could be a float)\nchord::Vector{Float} : blade element chord lengths\nrotor_panel_length::Vector{Float} : dimensional lengths on which blade element values apply\ncd::Vector{Float} : drag coefficient for each blade element\nrhoinf::Float : freestream density\n\nReturns\n\nTvisc::Vector{Float} : viscous dimensional thrust\ndTv::Vector{Float} : viscous dimensional thrust distribution\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.viscous_rotor_thrust!","page":"Postprocess","title":"DuctAPE.viscous_rotor_thrust!","text":"viscous_rotor_thrust!(\n    Tvisc, dTv, Cz_rotor, Cmag_rotor, B, chord, rotor_panel_length, cd, rhoinf\n)\n\nIn-place version of viscous_rotor_thrust.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.inviscid_rotor_torque","page":"Postprocess","title":"DuctAPE.inviscid_rotor_torque","text":"inviscid_rotor_torque(\n    Cz_rotor, rotor_panel_center, rotor_panel_length, Gamma_tilde, rhoinf\n)\n\nCalculate inviscid rotor torque.\n\nArguments\n\nCz_rotor::Vector{Float} : Absolute axial velocity on rotor blade elements\nrotor_panel_center::Vector{Float} : radial location of rotor blade elements\nrotor_panel_length::Vector{Float} : dimensional lengths on which blade element values apply\nGamma_tilde::Matrix{Float} : net upstream rotor circulation\nrhoinf::Float : freestream density\n\nReturns\n\nQinv::Vector{Float} : inviscid dimensional thrust\ndQi::Vector{Float} : inviscid dimensional thrust distribution\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.inviscid_rotor_torque!","page":"Postprocess","title":"DuctAPE.inviscid_rotor_torque!","text":"inviscid_rotor_torque!(\n    Qinv, dQi, Cz_rotor, rotor_panel_center, rotor_panel_length, Gamma_tilde, rhoinf\n)\n\nIn-place version of inviscid_rotor_torque.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.viscous_rotor_torque","page":"Postprocess","title":"DuctAPE.viscous_rotor_torque","text":"viscous_rotor_torque(\n    Ctheta_rotor, Cmag_rotor, B, chord, rotor_panel_center, rotor_panel_length, cd, rhoinf\n)\n\nCalculate viscous rotor torque.\n\nArguments\n\nCtheta_rotor::Vector{Float} : Absolute tangential velocity on rotor blade elements\nCmag_rotor::Vector{Float} : Absolute inflow velocity magnitude on rotor blade elements\nB::Vector{Float} : blade count for each rotor (usually integers but could be a float)\nchord::Vector{Float} : blade element chord lengths\nrotor_panel_center::Vector{Float} : radial location of rotor blade elements\nrotor_panel_length::Vector{Float} : dimensional lengths on which blade element values apply\ncd::Vector{Float} : drag coefficient for each blade element\nrhoinf::Float : freestream density\n\nReturns\n\nQvisc::Vector{Float} : viscous dimensional thrust\ndQv::Vector{Float} : viscous dimensional thrust distribution\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.viscous_rotor_torque!","page":"Postprocess","title":"DuctAPE.viscous_rotor_torque!","text":"viscous_rotor_torque!(\n    Qvisc,\n    dQv,\n    Ctheta_rotor,\n    Cmag_rotor,\n    B,\n    chord,\n    rotor_panel_center,\n    rotor_panel_length,\n    cd,\n    rhoinf\n)\n\nIn-place version of viscous_rotor_torque.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.rotor_power","page":"Postprocess","title":"DuctAPE.rotor_power","text":"rotor_power(Q, dQ, Omega)\n\nCalculate power from torque and rotation rate.\n\nArguments\n\nQ::Vector{Float} : dimensional thrust\ndQ::Vector{Float} : dimensional thrust distribution\nOmega::Vector{Float} : rotor rotation rates\n\nReturns\n\nP::Vector{Float} : dimensional power\ndP::Vector{Float} : dimensional thrust distribution\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.rotor_power!","page":"Postprocess","title":"DuctAPE.rotor_power!","text":"rotor_power!(P, dP, Q, dQ, Omega)\n\nIn-place version of rotor_power.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.get_total_efficiency","page":"Postprocess","title":"DuctAPE.get_total_efficiency","text":"get_total_efficiency(total_thrust, total_power, Vinf)\n\nGet total efficiency.\n\nArguments\n\ntotal_thrust::Vector{Float} : total thrust\ntotal_power::Vector{Float} : total power\nVinf::Vector{Float} : one element vector freestream velocity magnitude\n\nReturns\n\n`total_efficiency::Vector{Float} : total efficiency\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.get_total_efficiency!","page":"Postprocess","title":"DuctAPE.get_total_efficiency!","text":"get_total_efficiency!(eta, total_thrust, total_power, Vinf)\n\nIn-place version of get_total_efficiency.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.get_induced_efficiency","page":"Postprocess","title":"DuctAPE.get_induced_efficiency","text":"get_induced_efficiency(Tinv, Tduct, Pinv, Vinf)\n\nGet rotor efficiency induced by presence of the duct.\n\nArguments\n\nTinv::Vector{Float} : inviscid dimensional thrust\nTduct::Vector{Float} : duct thrust\nPinv::Vector{Float} : inviscid dimensional power\nVinf::Vector{Float} : one element vector freestream velocity magnitude\n\nReturns\n\ninduced_efficiency::Vector{Float} : rotor efficiency induced by duct\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.get_induced_efficiency!","page":"Postprocess","title":"DuctAPE.get_induced_efficiency!","text":"get_induced_efficiency!(eta_inv, Tinv, Tduct, Pinv, Vinf)\n\nIn-place version of get_induced_efficiency.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.get_ideal_efficiency","page":"Postprocess","title":"DuctAPE.get_ideal_efficiency","text":"get_ideal_efficiency(total_thrust, rhoinf, Vinf, Rref)\n\nCompute ducted fan ideal efficiency\n\nArguments\n\ntotal_thrust::Vector{Float} : total thrust from rotors and duct\nrhoinf::Float : freestream density\nVinf::Vector{Float} : one element vector freestream velocity magnitude\nRref::Vector{Float} : one element vector reference rotor tip radius\n\nReturns\n\nideal_efficiency::Vector{Float} : ideal ducted fan efficiency\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.tqpcoeff","page":"Postprocess","title":"DuctAPE.tqpcoeff","text":"tqpcoeff(thrust, torque, power, rhoinf, Omega, Rref)\n\nCalculate non-dimensional thrust, torque, and power coefficients\n\nArguments\n\nthrust::Vector{Float} : dimensional thrust\ntorque::Vector{Float} : dimensional torque\npower::Vector{Float} : dimensional power\nrhoinf::Float : freestream density\nOmega::Vector{Float} : rotor rotation rates\nRref::Vector{Float} : one element vector reference rotor tip radius\n\nReturns\n\nCT::Vector{Float} : thrust coefficient\nCQ::Vector{Float} : torque coefficient\nCP::Vector{Float} : power coefficient\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.tqpcoeff!","page":"Postprocess","title":"DuctAPE.tqpcoeff!","text":"tqpcoeff!(CT, CQ, CP, thrust, torque, power, rhoinf, Omega, Rref)\n\nIn-place version of tqpcoeff.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.get_blade_loads","page":"Postprocess","title":"DuctAPE.get_blade_loads","text":"get_blade_loads(Cmag_rotor, beta1, cl, cd, chords, rhoinf)\n\nGet loading along blades.\n\nArguments\n\nCmag_rotor::Vector{Float} : blade element inflow magnitudes\nbeta1::Vector{Float} : blade element inflow angles\ncl::Vector{Float} : blade element lift coefficients\ncd::Vector{Float} : blade element drag coefficients\nchords::Vector{Float} : blade element chord lengths\nrhoinf::Vector{Float} : one element freestream density\n\nReturns\n\nNp::Vector{Float} : blade loading per unit length in the normal direction: N'\nTp::Vector{Float} : blade loading per unit length in the tangential direction: T'\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.get_blade_loads!","page":"Postprocess","title":"DuctAPE.get_blade_loads!","text":"get_blade_loads!(Np, Tp, Cmag_rotor, beta1, cl, cd, chords, rhoinf, cache)\n\nIn-place version of get_blade_loads.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#Boundary-Layer","page":"Postprocess","title":"Boundary Layer","text":"","category":"section"},{"location":"DuctAPE/api/private_postprocess/#Thermodynamics","page":"Postprocess","title":"Thermodynamics","text":"","category":"section"},{"location":"DuctAPE/api/private_postprocess/","page":"Postprocess","title":"Postprocess","text":"DuctAPE.sa1\nDuctAPE.sa2\nDuctAPE.standard_atmosphere\nDuctAPE.ideal_gas_rho\nDuctAPE.sutherlands_law\nDuctAPE.speed_of_sound\nDuctAPE.calculate_mach\nDuctAPE.total_temperature\nDuctAPE.total_pressure\nDuctAPE.static_temperature\nDuctAPE.static_pressure\nDuctAPE.static_density\nDuctAPE.convert_temperature_to_kelvin\nDuctAPE.convert_viscosity","category":"page"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.sa1","page":"Postprocess","title":"DuctAPE.sa1","text":"sa1(altitude; hardness=50)\n\nStandard atmosphere temperature and pressure in SI units blended between the first linear portion and the constant portion.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.sa2","page":"Postprocess","title":"DuctAPE.sa2","text":"sa2(altitude; hardness=50)\n\nStandard atmosphere temperature and pressure in SI units blended between the the constant portion and the second linear portion.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.standard_atmosphere","page":"Postprocess","title":"DuctAPE.standard_atmosphere","text":"standard_atmosphere(altitude; hardness=25)\nstandard_atmosphere(::Imperial, altitude; hardness=25)\n\nSmoothed fits to the Standard Atmosphere model.\n\nAssumes calorically imperfect gas.\n\nArguments\n\naltitude::Float : Altitude in meters for SI units, or feet for Imperial units\n\nKeyword Arguments:\n\nhardness::float : hardness factor for sigmoid blend\n\nReturns\n\nstatic_temperature::Float : Static temperature\nstatic_pressure::Float : Static pressure\nstatic_density::Float : Static density\nstatic_dynamic_viscosity::Float : Static dynamic Viscosity\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.ideal_gas_rho","page":"Postprocess","title":"DuctAPE.ideal_gas_rho","text":"ideal_gas_rho(P, T)\n\nIdeal gas law for calculating density in SI units.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.sutherlands_law","page":"Postprocess","title":"DuctAPE.sutherlands_law","text":"sutherlands_law(\n    static_temperure, mu_sea_level=1.789e-5, T_sea_level=288.15, S=110.4\n)\n\nSutherland's law in SI units for calculating air viscosity relative to sea level.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.speed_of_sound","page":"Postprocess","title":"DuctAPE.speed_of_sound","text":"speed_of_sound(static_pressure, static_density; gamma=1.4)\n\nSpeed of sound from isentropic relations\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.calculate_mach","page":"Postprocess","title":"DuctAPE.calculate_mach","text":"calculate_mach(edge_velocity, speed_of_sound)\n\nMach number from velocity and speed of sound\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.total_temperature","page":"Postprocess","title":"DuctAPE.total_temperature","text":"total_temperature(static_temperature, M; gamma=1.4)\n\nTotal temperature from isentropic relations\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.total_pressure","page":"Postprocess","title":"DuctAPE.total_pressure","text":"total_pressure(static_pressure, M; gamma=1.4)\n\nTotal pressure from isentropic relations\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.static_temperature","page":"Postprocess","title":"DuctAPE.static_temperature","text":"static_temperature(total_temperature, M; gamma=1.4)\n\nStatic temperature from isentropic relations\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.static_pressure","page":"Postprocess","title":"DuctAPE.static_pressure","text":"static_pressure(total_pressure, M; gamma=1.4)\n\nStatic pressure from isentropic relations\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.static_density","page":"Postprocess","title":"DuctAPE.static_density","text":"static_density(static_pressure, speed_of_sound; gamma=1.4)\n\nStatic density from isentropic relations\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.convert_temperature_to_kelvin","page":"Postprocess","title":"DuctAPE.convert_temperature_to_kelvin","text":"convert_temperature_to_kelvin(::Units, T)\n\nConvert from Fahrenheit to Kelvin or Return temperature if already in SI units\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.convert_viscosity","page":"Postprocess","title":"DuctAPE.convert_viscosity","text":"convert_viscosity(::SI, mu)\n\nConvert viscosity from Imperial units to SI or Return input if already SI units.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#General-Boundary-Layer-Functions","page":"Postprocess","title":"General Boundary Layer Functions","text":"","category":"section"},{"location":"DuctAPE/api/private_postprocess/","page":"Postprocess","title":"Postprocess","text":"DuctAPE.arc_lengths_from_panel_lengths\nDuctAPE.split_at_stagnation_point\nDuctAPE.bl_step_fun\nDuctAPE.set_boundary_layer_steps\nDuctAPE.RK2\nDuctAPE.RK4","category":"page"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.arc_lengths_from_panel_lengths","page":"Postprocess","title":"DuctAPE.arc_lengths_from_panel_lengths","text":"arc_lengths_from_panel_lengths(duct_panel_lengths, bl_ids)\n\nCumulative sum of panel lengths for the given section of surface associated with the upper or lower boundary layer.\n\nArguments:\n\nduct_panel_lengths::Vector{Float} : vector of panel lengths (called influencelength in bodyvortex_panels) associated with the duct (casing + nacelle).\n\nReturns:\n\ns::Vector{Float} : cumulative sum of panel lengths between control points in the given index range, starting from zero.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.split_at_stagnation_point","page":"Postprocess","title":"DuctAPE.split_at_stagnation_point","text":"splitatstagnationpoint(ductpanellengths, npanels_casing)\n\nSplit the duct body surface at the leading edge of the duct.\n\nArguments:\n\nduct_panel_lengths::Vector{Float} : Vector of panel lengths for the duct from casing trailing edge clockwise to nacelle trailing edge.\nn_panels_casing::Int : number of panels comprising the casing side of the duct\n\nReturns:\n\ns_upper::Vector{Float} : cumulative sum of upper side (nacelle) panel lengths\ns_lower::Vector{Float} : cumulative sum of lower side (casing) panel lengths\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.bl_step_fun","page":"Postprocess","title":"DuctAPE.bl_step_fun","text":"bl_step_fun(n, m, p)\n\nFunction used in determining step sizes for boundary layer calculation. f(n) = m*n^p\n\nGiven a number of steps, n  [1:N], provides the cumulative step lengths according to the power, p, and the multiplicative factor, m; where p determined from the set_boundary_layer_steps functions.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.set_boundary_layer_steps","page":"Postprocess","title":"DuctAPE.set_boundary_layer_steps","text":"set_boundary_layer_steps(N::Int, first_step_size, total_length)\n\nSets boundary layer steps based on desired number of steps (must be an Integer), an initial step size, and the total cumulative length of the steps.\n\nArguments:\n\nN::Int : Number of steps to take\nfirst_step_size::Float : size of first step (which is m in bl_step_fun)\ntotal_length::Float : total surface length to divide up.\n\nReturns:\n\nsteps::Vector{Float} : steps along surface length satisfying the equation: f(n) = m*n^p with the condition that m is the first step size and f(N) = total_length\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.RK2","page":"Postprocess","title":"DuctAPE.RK2","text":"RK2(f, y, s, ds, parameters)\n\n2nd Order Runge-Kutta integration scheme.\n\nArguments:\n\nf::function_handle : residual function for integration\ny::Vector{Float} : current states\ns::Float : current position\nds::Float : step size\nparameters::NamedTuple : BoundaryLayerOptions and other various parameters\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.RK4","page":"Postprocess","title":"DuctAPE.RK4","text":"RK4(f, y, s, ds, parameters)\n\n4th Order Runge-Kutta integration scheme.\n\nArguments:\n\nf::function_handle : residual function for integration\ny::Vector{Float} : current states\ns::Float : current position\nds::Float : step size\nparameters::NamedTuple : BoundaryLayerOptions and other various parameters\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#Head's-Method-Specific-Functions","page":"Postprocess","title":"Head's Method Specific Functions","text":"","category":"section"},{"location":"DuctAPE/api/private_postprocess/","page":"Postprocess","title":"Postprocess","text":"DuctAPE.setup_boundary_layer_functions_head\nDuctAPE.calculate_H\nDuctAPE.calculate_cf\nDuctAPE.boundary_layer_residual_head\nDuctAPE.boundary_layer_residual_head!\nDuctAPE.solve_head_boundary_layer!","category":"page"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.setup_boundary_layer_functions_head","page":"Postprocess","title":"DuctAPE.setup_boundary_layer_functions_head","text":"setup_boundary_layer_functions_head(\n    s,\n    vtan_duct,\n    duct_control_points,\n    operating_point,\n    boundary_layer_options;\n    verbose=false\n)\n\nArguments:\n\ns::Vector{Float} : cumulative sum of panel lengths between control points in the given index range, starting from zero.\nvtan_duct::Vector{Float} : tangential velocity magnitudes for the entire duct\nduct_control_points::Matrix{Float} : Control point coordinates along the duct surface\noperating_point::OperatingPoint : OperatingPoint object\nboundary_layer_options::BoundaryLayerOptions : BoundaryLayerOptions object\n\nReturns:\n\nboundary_layer_parameters::NamedTuple : Namped Tuple containing boundary layer solver parameters:\nedge_velocity::FLOWMath.Akima : spline of edge velocities relative to surface length\nedge_acceleration::FLOWMath.Akima : spline of edge acceleration (dUe/ds) relative to surface length\nedge_density::FLOWMath.Akima : spline of edge density relative to surface length\nedge_viscosity::FLOWMath.Akima : spline of edge viscosity relative to surface length\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.calculate_H","page":"Postprocess","title":"DuctAPE.calculate_H","text":"calculate_H(H1)\n\nCalculate the value of the shape factor used in Head's method.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.calculate_cf","page":"Postprocess","title":"DuctAPE.calculate_cf","text":"calculate_cf(H, Red2)\n\nCalculate the skin friction coefficient used in Head's method\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.boundary_layer_residual_head","page":"Postprocess","title":"DuctAPE.boundary_layer_residual_head","text":"boundary_layer_residual_head(y, s, parameters)\n\nOut of place residual function for Head's method.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.boundary_layer_residual_head!","page":"Postprocess","title":"DuctAPE.boundary_layer_residual_head!","text":"boundary_layer_residual_head!(dy, y, s, parameters)\n\nCalculate dy give the current states, y, the input position, s, and various parameters.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.solve_head_boundary_layer!","page":"Postprocess","title":"DuctAPE.solve_head_boundary_layer!","text":"solve_head_boundary_layer!(f, rk, initial_states, steps, parameters; verbose=false)\n\nIntegrate the turbulent boundary layer using a Runge-Kutta method.\n\nArguments:\n\nf::function_handle : Governing residual equations to integrate\nrk::function_handle : Runge-Kutta method to use (RK2 or RK4)\ninitial_states::Float : initial states\nsteps::Vector{Float} : steps for integration\nparameters::NamedTuple : boundary layer solve options and other parameters\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#Viscous-Drag","page":"Postprocess","title":"Viscous Drag","text":"","category":"section"},{"location":"DuctAPE/api/private_postprocess/","page":"Postprocess","title":"Postprocess","text":"DuctAPE.squire_young\nDuctAPE.total_viscous_drag_duct\nDuctAPE.compute_viscous_drag_duct\nDuctAPE.compute_single_side_drag_coefficient_head\nDuctAPE.compute_viscous_drag_duct_schlichting","category":"page"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.squire_young","page":"Postprocess","title":"DuctAPE.squire_young","text":"squire_young(d2, Ue, Uinf, H12)\n\nSquire-Young formula for the viscous drag coeffiecient of one side of a 2D body.\n\nArguments:\n\nd2::Float : Momentum thickness at separation extrapolated back to the trailing edge (d2 = d2sep+rsep-rTE)\nUe::Float : Edge velocity at separation point\nUinf::Float : Freestream velocity\nH12::Float : Boundary layer shape factor at separation point\n\nNote: if no separation occurs, the inputs are simply the final values for the boundary layer.\n\nReturns:\n\ncdc::Float : viscous drag coefficient times reference chord\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.total_viscous_drag_duct","page":"Postprocess","title":"DuctAPE.total_viscous_drag_duct","text":"total_viscous_drag_duct(cd_upper, cd_lower, exit_radius, Vref, rhoinf)\n\nCalculate the total viscous drag of the duct from Squire-Young drag coefficients, integrated about exit circumference.\n\nArguments:\n\ncdc_upper::Float : upper side drag coefficient times refernce chord\ncdc_lower::Float : lower side drag coefficient times refernce chord\nexit_radius::Float : radius used for integrating circumferentially\nVref::Float : reference velocity (Vinf)\nrhoinf::Float : freestream density\n\nReturns:\n\nviscous_drag::Float : viscous drag on duct\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.compute_viscous_drag_duct","page":"Postprocess","title":"DuctAPE.compute_viscous_drag_duct","text":"compute_viscous_drag_duct(\n    boundary_layer_options::BoundaryLayerOptions,\n    Vtan_duct,\n    cp_duct,\n    duct_panel_lengths,\n    exit_radius,\n    operating_point,\n)\n\nDetermine total, dimensional viscous drag on the duct.\n\nArguments:\n\nboundary_layer_options::BoundaryLayerOptions : BoundaryLayerOptions object, used for dispatch as well\nVtan_duct::Vector{Float} : tangential velocity magnitudes for the entire duct\nduct_panel_lengths::Vector{Float} : panel lengths for the entire duct\nexit_radius::Float : radius at duct trailing edge (casing side)\noperating_point::Float : OperatingPoint object\n\nReturns:\n\nduct_viscous_drag::Float : total viscous drag of duct\nboundary_layer_outputs::NamedTuple : named tuple of various boundary layer related outputs:\nstagnation_indices\nupper_solved_states\nupper_solved_steps\nlower_solved_states\nlower_solved_steps\nsurface_length_upper\nsurface_length_lower\nsplit_ratio\nseparation_point_ratio_upper\nseparation_point_ratio_lower\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.compute_single_side_drag_coefficient_head","page":"Postprocess","title":"DuctAPE.compute_single_side_drag_coefficient_head","text":"compute_single_side_drag_coefficient_head(\n    steps,\n    exit_radius,\n    operating_point,\n    boundary_layer_options;\n    verbose=false,\n)\n\nSolve integral boundary layer and obtain viscous drag coefficient from Squire-Young formula for one side of the duct (side being defined as portion of surface on once side of the stagnation point)\n\nArguments:\n\nsteps::Vector{Float} : positions along surface for integration\nexit_radius::Float : radius at duct trailing edge (casing side)\noperating_point::Float : OperatingPoint object\nboundary_layer_functions::NamedTuple : Various Akima splines and other functions for boundary layer values\nboundary_layer_options::BoundaryLayerOptions : BoundaryLayerOptions object\n\nReturns:\n\ncd::Float : viscous drag coefficient\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/api/private_postprocess/#DuctAPE.compute_viscous_drag_duct_schlichting","page":"Postprocess","title":"DuctAPE.compute_viscous_drag_duct_schlichting","text":"compute_viscous_drag_duct_schlichting(\n    vtan_duct_TE, duct_chord, TE_radius, operating_point\n)\n\nComputes Schlichting approximation of skin friction drag dimensionalized to drag per unit length using duct chord, and using the trailing edge circuference as the total length.\n\nArguments:\n\nvtan_duct_TE::Float : tangential velocity at the duct trailing edge\nduct_chord::Float : length of duct\nTE_radius::Float : radius of the trailing edge point\noperating_point::OperatingPoint : OperatingPoint object\n\n\n\n\n\n","category":"function"},{"location":"C4Blade/intro/#C\\textrm{4}Blade-[[C](#)ascade-[C](#)ompatible-[CCBlade](https://flow.byu.edu/CCBlade.jl/stable/)]","page":"Intro","title":"C^textrm4Blade [Cascade Compatible CCBlade]","text":"","category":"section"},{"location":"C4Blade/intro/","page":"Intro","title":"Intro","text":"C^4Blade is a DuctAPE submodule containing a modified version of CCBlade that includes capabilities for cascade types.","category":"page"},{"location":"DuctAPE/api/visualiztion_api/","page":"-","title":"-","text":"DuctAPE.generate_plots","category":"page"},{"location":"DuctAPE/api/visualiztion_api/#DuctAPE.generate_plots","page":"-","title":"DuctAPE.generate_plots","text":"generate_plots(\n    ::staticPlots, (or ::animatedPlots)\n    Plots,\n    ins,\n    outs;\n    save_path=\"\",\n    static_file_type=\".pdf\",\n    suffix=nothing,\n    plot_geometry=true,\n    plot_pressure=false,\n    plot_velocity=false,\n    plot_boundary_layer=false,\n    plot_streamlines=false,\n    verbose=false,\n    kwargs...,\n)\n\nGenerate standard suite of plots or animations from input and output objects.\n\nArguments:\n\n::staticPlots (or ::animatedPlots) :\nPlots:: : the Plots package namespace\nins::NamedTuple : returned inputs from analyze function\nouts::Vector{NamedTuple} : retured outputs from analyze function\n\nKeyword Arguments:\n\nsave_path=\"\" : custom save path\nstatic_file_type=\".pdf\" : file type for static files (must be compatible with the desired backend)\nsuffix=nothing : custom suffixes, if unused plots files will be numbered starting from 1.\nplot_geometry=true : flag to generate geometry plot\nplot_panels=false : flag to include markers indicating panel edges in geometry plot\nplot_pressure=false : flag to generate surface pressures plot\nplot_velocity=false : flag to generate surface velocities plot\nplot_boundary_layer=false : flag to generate boundary layer plot\nplot_streamlines=false : flag to generate streamlines plot\nverbose=false : print verbose statements\nkwargs... : arguments passed into the plot functions (Plots keyword arguments/defaults to be used in every plot)\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"DuctAPE/theory/","page":"Theory","title":"Theory","text":"For a brief overview of the theory behind DuctAPE, see:","category":"page"},{"location":"DuctAPE/theory/","page":"Theory","title":"Theory","text":"Mehr, J. and Ning, A., \"DuctAPE: A steady-state, axisymmetric ducted fan analysis code designed for gradient-based optimization.,\" AIAA Aviation Forum, July 2024.","category":"page"},{"location":"DuctAPE/theory/","page":"Theory","title":"Theory","text":"For a more thorough dive into the details see this pdf document.","category":"page"},{"location":"#DuctAPE.jl-[[Duct](#)ed-[A](#)xisymmetric-[P](#)ropulsor-[E](#)valuation]","page":"Home","title":"DuctAPE.jl [Ducted Axisymmetric Propulsor Evaluation]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Author: Judd Mehr","category":"page"},{"location":"","page":"Home","title":"Home","text":"Contributer: Taylor McDonnell","category":"page"},{"location":"","page":"Home","title":"Home","text":"DuctAPE is a code for the aerodynamic evaluation of axisymmetric ducted ducted_rotors designed for incompressible (low mach) applications. It is strongly influenced by the underlying theory of Ducted Fan Design Code (DFDC), utilizing a linear axisymmetric vortex panel method for duct and center body, blade element lifting line rotor representation, and wake model axisymmetrically smeared onto an elliptic grid for efficient computation. DuctAPE has been developed specifically for applications in gradient-based optimization settings.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/byuflowlab/DuctAPE.jl.git","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Getting Started will have you up and running quickly.\nThe Advanced Usage tab includes several pages of additional information for customizing your usage.\nThe API tab contains public and private method descriptions.\nThe Theory tab contain several pages on the underlying theory of DuctAPE.\nThe C^4Blade tab contains documentation for the C^4Blade submodule used for airfoil/cascade management within DuctAPE as well as state initialization.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mehr, J. and Ning, A., \"DuctAPE: A steady-state, axisymmetric ducted fan analysis code designed for gradient-based optimization.,\" AIAA Aviation Forum, July 2024.","category":"page"},{"location":"DuctAPE/tutorial/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"Pages = [\"tutorial.md\"]\nDepth = 5","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"The following is a basic tutorial on how to set up and run an analysis of a ducted fan in DuctAPE.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"include(\"../assets/plots_default.jl\")\ngr()","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"We begin by loading the package:","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"using DuctAPE\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/#Assemble-Inputs","page":"Getting Started","title":"Assemble Inputs","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"The next step is to create the input object of type DuctedRotor.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.DuctedRotor","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.DuctedRotor-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.DuctedRotor","text":"DuctedRotor(duct_coordinates, centerbody_coordinates, rotor, paneling_constants)\n\nArguments\n\nduct_coordinates::AbstractMatrix : The [z, r] coordinates of the duct geometry beginning at the inner (casing) side trailing edge and proceeding clockwise. Note that the duct geometry absolute radial position does not need to be included here if the autoshiftduct option is selected.\ncenterbody_coordinates::AbstractMatrix : The [z, r] coordinates of the centerbody beginning at the leading edge and ending at the trailing edge. Note that the leading edge is assumed to be placed at a radial distance of 0.0 from the axis of rotation.\nrotor::Rotor : Rotor (and possibly stator) geometric paramters.\npaneling_constants::PanelingConstants : Constants used in re-paneling the geometry.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/tutorial/#Body-Geometry","page":"Getting Started","title":"Body Geometry","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"We begin by defining a matrix of coordinates for the duct and another for the centerbody geometries. For example:","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"duct_coordinates = [\n    0.304466  0.158439\n    0.294972  0.158441\n    0.28113   0.158423\n    0.266505  0.158365\n    0.251898  0.158254\n    0.237332  0.158088\n    0.222751  0.157864\n    0.208123  0.157586\n    0.193399  0.157258\n    0.178507  0.156897\n    0.16349   0.156523\n    0.148679  0.156177\n    0.134222  0.155902\n    0.12      0.155721\n    0.106044  0.155585\n    0.092531  0.155498\n    0.079836  0.155546\n    0.067995  0.155792\n    0.057025  0.156294\n    0.046983  0.157103\n    0.037937  0.158256\n    0.029956  0.159771\n    0.02311   0.161648\n    0.017419  0.163862\n    0.012842  0.166404\n    0.009324  0.169289\n    0.006854  0.172546\n    0.005484  0.176154\n    0.005242  0.180005\n    0.006112  0.184067\n    0.00809   0.188086\n    0.011135  0.192004\n    0.015227  0.19579\n    0.020339  0.199393\n    0.026403  0.202735\n    0.033312  0.205736\n    0.040949  0.208332\n    0.049193  0.210487\n    0.057935  0.212174\n    0.067113  0.21339\n    0.076647  0.214136\n    0.086499  0.214421\n    0.09661   0.214255\n    0.10695   0.213649\n    0.117508  0.212618\n    0.12838   0.211153\n    0.139859  0.209267\n    0.151644  0.207051\n    0.163586  0.204547\n    0.175647  0.201771\n    0.187807  0.198746\n    0.20002   0.19549\n    0.212269  0.192017\n    0.224549  0.188335\n    0.236794  0.18447\n    0.249026  0.180416\n    0.261206  0.176188\n    0.273301  0.171796\n    0.28524   0.16727\n    0.29644   0.162842\n    0.304542  0.159526\n]\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"centerbody_coordinates = [\n    0.0       0.0\n    0.000586  0.005293\n    0.002179  0.010047\n    0.004736  0.014551\n    0.008231  0.018825\n    0.012632  0.022848\n    0.01788   0.026585\n    0.023901  0.030001\n    0.030604  0.033068\n    0.0379    0.035771\n    0.045705  0.038107\n    0.053933  0.040075\n    0.06254   0.04169\n    0.071451  0.042966\n    0.08063   0.043916\n    0.090039  0.044561\n    0.09968   0.044922\n    0.109361  0.044999\n    0.12      0.044952\n    0.135773  0.04495\n    0.151899  0.04493\n    0.16806   0.044913\n    0.184232  0.044898\n    0.200407  0.044882\n    0.21658   0.044866\n    0.232723  0.044847\n    0.248578  0.044839\n    0.262095  0.044564\n    0.274184  0.043576\n    0.285768  0.041795\n    0.296701  0.039168\n    0.306379  0.035928\n]\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"pg = plot( # hide\n    duct_coordinates[:, 1], # hide\n    duct_coordinates[:, 2]; # hide\n    aspectratio=1, # hide\n    color=1, # hide\n    linewidth=2, # hide\n    label=\"Duct\", # hide\n    xlabel=\"z\", # hide\n    ylabel=\"r\", # hide\n    legend=:left, # hide\n) # hide\nplot!( # hide\n    pg, # hide\n    centerbody_coordinates[:, 1], # hide\n    centerbody_coordinates[:, 2]; # hide\n    color=2, # hide\n    linewidth=2, # hide\n    label=\"Center Body\", # hide\n) # hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"note: Note\nThe body geometry coordinates must be input as columns of z (axial) and r (radial) coordinates, in that order.","category":"page"},{"location":"DuctAPE/tutorial/#Rotor-Geometry","page":"Getting Started","title":"Rotor Geometry","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"The next step is to assemble an object of type Rotor which contains the geometric information required to define the rotor(s) and their respective blade elements.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.Rotor","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.Rotor-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.Rotor","text":"Rotor(\n    B, rotorzloc, r, Rhub, Rtip, chords, twists, tip_gap, airfoils, fliplift\n)\n\nComposite type containing the rotor(s) geometric properties.\n\nNote that the actual struct requires the inputs to be arrays, but there is a constructor function that will take in scalars and automatically build the array-based struct.\n\nArguments\n\nB::AbstractVector{Float} : The number of blades for each rotor. May not be an integer, but usually is.\nrotorzloc::AbstractVector{Float} : Dimensional, axial position of each rotor.\nr::AbstractArray{Float} : Non-dimensional radial locations of each blade element.\nRhub::AbstractVector{Float} : Dimensional hub radius of rotor. (may be changed if it does not match the radial position of the centerbody geometry at the selected rotorzloc.\nRtip::AbstractVector{Float} : Dimensional tip radius of rotor. Is used to determine the radial position of the duct if the autoshiftduct option is selected.\nchords::AbstractArray{Float} : Dimensional chord lengths of the blade elements.\ntwists::AbstractArray{Float} : Blade element angles, in radians.\ntip_gap::AbstractVector{Float} : Currently unused, do not set to anything other than zeros.\nairfoils::AbstractArray{AFType} : Airfoil types describing the airfoil polars for each blade element. Currently only fully tested with C4Blade.DFDCairfoil types.\nfliplift::AbstractVector{Bool} : Flag to indicate if the airfoil lift values should be flipped or not.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"In this example, we have a single rotor defined as follows.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# number of rotors\nB = 5\n\n# rotor axial location\nrotorzloc = 0.12\n\n# rotor tip radius\nRtip = 0.15572081487373543\n\n# rotor hub radius\nRhub = 0.04495252299071941\n\n# non-dimensional blade element radial stations\nr = [\n    0.050491\n    0.061567\n    0.072644\n    0.083721\n    0.094798\n    0.10587\n    0.11695\n    0.12803\n    0.13911\n    0.15018\n] ./ Rtip\n\n# dimensional chord lengths\nchords = [\n    0.089142\n    0.079785\n    0.0713\n    0.063979\n    0.057777\n    0.052541\n    0.048103\n    0.044316\n    0.041061\n    0.038243\n]\n\n# twist angles (from plane of rotation) in radians\ntwists = [\n    69.012\n    59.142\n    51.825\n    46.272\n    41.952\n    38.509\n    35.699\n    33.354\n    31.349\n    29.596\n] .* pi / 180.0\n\n# DFDC-type airfoil object\nafparams = DuctAPE.c4b.DFDCairfoil(;\n    alpha0=0.0,\n    clmax=1.5,\n    clmin=-1.0,\n    dclda=6.28,\n    dclda_stall=0.5,\n    dcl_stall=0.2,\n    cdmin=0.012,\n    clcdmin=0.1,\n    dcddcl2=0.005,\n    cmcon=0.0,\n    Re_ref=2e5,\n    Re_exp=0.35,\n    mcrit=0.7,\n)\n\n# all airfoils are the same\nairfoils = fill(afparams, length(r)) # specify the airfoil array\n\n# assemble rotor parameters\nrotor = DuctAPE.Rotor(\n    [B],\n    [rotorzloc],\n    r,\n    [Rhub],\n    [Rtip],\n    chords,\n    twists,\n    [0.0], # currently only zero tip gaps work.\n    airfoils,\n    [0.0], # can flip the cl lookups on the fly if desired, say, for stator sections\n)\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"plot!( # hide\n    pg, # hide\n    rotorzloc * ones(length(r)), # hide\n    r .* Rtip; # hide\n    seriestype=:scatter, # hide\n    markersize=3, # hide\n    markerstrokewidth=0, # hide\n    label=\"Blade Elements\", # hide\n) # hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"note: Airfoils\nAirfoil types for DuctAPE are currently contained in the C4Blade (Cascade Compatible CCBlade) sub-module of DuctAPE which is exported as c4b and also contains the various airfoil evaluation functions used for the blade element lookups. The available airfoil types include all the airfoil types from CCBlade, as well as DFDCairfoil which is an XROTOR-like parametric cascade polar used in DFDC. In addition there are untested cascade types with similar structure to CCBlades airfoil types called DTCascade. Furthermore, there is an experimental actuator disk model implemented via the ADM airfoil type in C4Blade.","category":"page"},{"location":"DuctAPE/tutorial/#Paneling-Constants","page":"Getting Started","title":"Paneling Constants","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"The PanelingConstants object contains the constants required for DuctAPE to re-panel the provided geometry into a format compatible with the solve structure. Specifically, the DuctAPE solver makes some assumptions on the relative positioning of the body surfaces relative to the wakes and each other; and this is most easily guarenteed by a re-paneling of the provided body surface geometry. The PanelingConstants object is also used to build all of the preallocated caches inside DuctAPE, which can be done up-front if desired. Note that there is some functionality in place for cases when the user wants to keep their own specified geometry, but this functionality should be used with caution and only by users who are certain their provided geometry is in the compatible format.  See the Examples for an example.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.PanelingConstants","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.PanelingConstants-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.PanelingConstants","text":"PanelingConstants(\n    nduct_inlet,\n    ncenterbody_inlet,\n    npanels,\n    dte_minus_cbte,\n    nwake_sheets,\n    wake_length=1.0,\n)\n\nConstants used in re-paneling geometry.\n\nNote that unlike other input structures, this one, in general, does not define fields as vectors.  This is because these values should not change throughout an optimization, even if the geometry may change.  Otherwise, discontinuities could be experienced.\n\nArguments\n\nnduct_inlet::Int : The number of panels to use for the duct inlet (this number is used for both the casing and nacelle re-paneling)\nncenterbody_inlet::Int : The number of panels to use for the centerbody inlet.\nnpanels::AbstractVector{Int} : A vector containing the number of panels between discrete locations inside the wake. Specifically, the number of panels between the rotors, between the last rotor and the first body trailing edge, between the body trailing edges (if different), and between the last body trailing edge and the end of the wake.  The length of this vector should be N+1 (where N is the number of rotors) if the duct and centerbody trailing edges are aligned, and N+2 if not.\ndte_minus_cbte::Float : An indicator concerning the hub and duct trailing edge relative locations. Should be set to -1 if the duct trailing edge axial position minus the centerbody trailing edge axial position is negative, +1 if positive (though any positive or negative number will suffice), and zero if the trailing edges are aligned.\nnwake_sheets::Int : The number of wake sheets to use. Note this will also be setting the number of blade elements to use.\nwake_length::Float=1.0 : Non-dimensional (based on the length from the foremost body leading edge and the aftmost body trailing edge) length of the wake extending behind the aftmost body trailing edge.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# number of panels for the duct inlet\nnduct_inlet = 30\n\n# number of panels for the center body inlet\nncenterbody_inlet = 30\n\n# number of panels from:\n#  - rotor to duct trailing edge\n#  - duct trailing edge to center body trailing edge\n#  - center body trailing edge to end of wake\nnpanels = [30, 1, 30]\n\n# the duct trailing edge is ahead of the centerbody trailing edge.\ndte_minus_cbte = -1.0\n\n# number of wake sheets (one more than blade elements to use)\nnwake_sheets = 11\n\n# non-dimensional wake length aft of rear-most trailing edge\nwake_length = 0.8\n\n# assemble paneling constants\npaneling_constants = DuctAPE.PanelingConstants(\n    nduct_inlet, ncenterbody_inlet, npanels, dte_minus_cbte, nwake_sheets, wake_length\n)\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/#Assembling-the-DuctedRotor","page":"Getting Started","title":"Assembling the DuctedRotor","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"We are now posed to construct the DuctedRotor input type.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# assemble ducted_rotor object\nducted_rotor = DuctAPE.DuctedRotor(\n    duct_coordinates,\n    centerbody_coordinates,\n    rotor,\n    paneling_constants,\n)\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/#Operating-Point","page":"Getting Started","title":"Operating Point","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"Next we will assemble the operating point which contains information about the freestream as well as the rotor rotation rate(s).","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.OperatingPoint","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.OperatingPoint-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.OperatingPoint","text":"OperatingPoint(Vinf, Minf, rhoinf, muinf, asound, Ptot, Ttot, Omega)\nOperatingPoint(\n    Vinf, Omega, rhoinf=nothing, muinf=nothing, asound=nothing; altitude=0.0\n)\nOperatingPoint(\n    ::Imperial, Vinf, Omega, rhoinf=nothing, muinf=nothing, asound=nothing; altitude=0.0\n)\n\nDuctedRotor operating point information.\n\nFunctions that take in altitude will populate undefined thermodynamic properties of the freestream using a standard_atmosphere model, ideal gas law, and Sutherland's law; defaulting to SI units. If the ::Imperial dispatch type is input, then the thermodynamic properties will be converted to Imperial units.\n\nFields/Arguments\n\nVinf::AbstractVector{Float} : Freestream velocity magnitude (which is only in the axial direction).\nMinf::AbstractVector{Float} : Freestream Mach number\nrhoinf::AbstractVector{Float} : Freestream density\nmuinf::AbstractVector{Float} : Freestream viscosity\nasound::AbstractVector{Float} : Freestream speed of sound\nPtot::AbstractVector{Float} : Freestream total pressure\nTtot::AbstractVector{Float} : Freestream total temperature\nOmega::AbstractVector{Float} : Rotor rototation rate(s)\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# Freestream\nVinf = 30.0\nrhoinf = 1.226\nasound = 340.0\nmuinf = 1.78e-5\n\n# Rotation Rate\nRPM = 8000.0\nOmega = RPM * pi / 30 # if using RPM, be sure to convert to rad/s\n\n# utilizing the constructor function to put things in vector types\noperating_point = DuctAPE.OperatingPoint(Vinf, Omega, rhoinf, muinf, asound)\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/#Reference-Parameters","page":"Getting Started","title":"Reference Parameters","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"The reference parameters are used in the post-processing non-dimensionalizations.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.ReferenceParameters","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.ReferenceParameters-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.ReferenceParameters","text":"ReferenceParameters(Vref, Rref)\n\nReference parameters for post-process non-dimensionalization.\n\nNote that the actual struct requires the inputs to be arrays, but there is a constructor function that will take in scalars and automatically build the array-based struct.\n\nArguments\n\nVref::AbstractVector{Float} : Reference velocity.\nRref::AbstractVector{Float} : Reference rotor tip radius.\n\n\n\n\n\n","category":"type"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# reference velocity (close to average axial velocity at rotor in this case)\nVref = 50.0\n\n# reference radius (usually tip radius of rotor)\nRref = Rtip\n\n# assemble reference parameters\nreference_parameters = DuctAPE.ReferenceParameters([Vref], [Rref])\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/#Set-Options","page":"Getting Started","title":"Set Options","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"The default options should be sufficient for just starting out and are set through the set_options function.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.set_options","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.set_options-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.set_options","text":"set_options(; kwargs...)\nset_options(multipoint; kwargs...)\n\nSet the options for DuctAPE to use.\n\nNote that the vast majority of the available options are defined through keyword arguments.  See the documentation for the various option types for more information.\n\nArguments\n\nmultipoint::AbstractArray{OperatingPoint} : a vector of operating points to use if running a multi-point analysis.\n\n\n\n\n\n","category":"function"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"options = DuctAPE.set_options()","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"For more advanced option selection, see the examples and API reference.","category":"page"},{"location":"DuctAPE/tutorial/#Run-a-Single-Analysis","page":"Getting Started","title":"Run a Single Analysis","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"With the ducted_rotor input build, and the options selected, we are now ready to run an analysis. This is done simply with the analyze function which dispatches the appropriate analysis, solve, and post-processing functions based on the selected options.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.analyze(::DuctAPE.DuctedRotor, ::DuctAPE.OperatingPoint, ::DuctAPE.ReferenceParameters, ::DuctAPE.Options)","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.analyze-Tuple{DuctedRotor, OperatingPoint, ReferenceParameters, Options}-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.analyze","text":"analyze(\n    ducted_rotor::DuctedRotor,\n    operating_point::OperatingPoint,\n    reference_parameters::ReferenceParameters,\n    options::Options=set_options();\n    prepost_container_caching=nothing,\n    solve_parameter_caching=nothing,\n    solve_container_caching=nothing,\n    return_inputs=false,\n)\n\nAnalyze ducted_rotor, including preprocessing.\n\nArguments\n\nducted_rotor::DuctedRotor : DuctedRotor input object (see docstring for DuctedRotor type)\noperating_point::OperatingPoint : OperatingPoint input object (see docstring for OperatingPoint type)\nreference_parameters::ReferenceParameters : ReferenceParameters input object (see docstring for ReferenceParameters type)\noptions::Options=set_options() : Options object (see set_options and related functions)\n\nKeyword Arguments\n\nprepost_container_caching=nothing : Output of allocate_prepost_container_cache\nsolve_parameter_caching=nothing : Output of allocate_solve_parameter_container_cache\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::NamedTuple : Named Tuple of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\n","category":"method"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"outs, success_flag = DuctAPE.analyze(\n    ducted_rotor, operating_point, reference_parameters, options\n)\nnothing # hide","category":"page"},{"location":"DuctAPE/tutorial/#Single-Run-Outputs","page":"Getting Started","title":"Single Run Outputs","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"There are many outputs contained in the named tuple output from the analyze function (see the post_process docstring), but some that may be of immediate interest include:","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# Total Thrust Coefficient\nouts.totals.CT","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# Total Torque Coefficient\nouts.totals.CQ","category":"page"},{"location":"DuctAPE/tutorial/#Run-a-Multi-Point-Analysis","page":"Getting Started","title":"Run a Multi-Point Analysis","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"In the case that one wants to run the same geometry at several different operating points, for example: for a range of advance ratios, there is another dispatch of the analyze function that accepts an input, multipoint, that is a vector of operating points.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"DuctAPE.analyze(ducted_rotor::DuctedRotor,operating_point::AbstractVector{TO},reference_parameters::ReferenceParameters,options::Options) where TO<:OperatingPoint","category":"page"},{"location":"DuctAPE/tutorial/#DuctAPE.analyze-Union{Tuple{TO}, Tuple{DuctedRotor, AbstractVector{TO}, ReferenceParameters, Options}} where TO<:OperatingPoint-DuctAPE-tutorial","page":"Getting Started","title":"DuctAPE.analyze","text":"analyze(\n    ducted_rotor::DuctedRotor,\n    operating_point::AbstractVector{OperatingPoint},\n    reference_parameters::ReferenceParameters,\n    options::Options=set_options();\n    prepost_container_caching=nothing,\n    solve_parameter_caching=nothing,\n    solve_container_caching=nothing,\n    return_inputs=false,\n)\n\nAnalyze ducted_rotor, including preprocessing, for a set of operating points.\n\nArguments\n\nducted_rotor::DuctedRotor : DuctedRotor input object\noperating_point::AbstractVector{OperatingPoint} : Vector of Operating Points at which to analyze the ducted_rotor\nreference_parameters::ReferenceParameters : ReferenceParameters input object (see docstring for ReferenceParameters type)\noptions::Options=set_options() : Options object\n\nKeyword Arguments\n\nprepost_container_caching=nothing : Output of allocate_prepost_container_cache\nsolve_parameter_caching=nothing : Output of allocate_solve_parameter_container_cache\nsolve_container_caching=nothing : Output of allocate_solve_container_cache\nreturn_inputs=false : flag as to whether or not to return the pre-processed inputs\n\nReturns\n\nouts::Vector{NamedTuple} : Vector of named tuples of various analysis outputs (see docstring for postprocess for details), note, if linear system decomposition fails, no solve is performed and an empty vector is returned.\nins::NamedTuple : Named Tuple of various pre-processed inputs (e.g. panels and body linear system), will only be returned if return_inputs=true\nconvergence_flag : Flag for successful solve convergence\n\n\n\n\n\n","category":"method"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"Running a multi-point analysis on the example geometry given there, it might look something like this:","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# - Advance Ratio Range - #\nJs = range(0.1, 2.0; step=0.01)\n\n# - Calculate Vinfs - #\nD = 2.0 * rotor.Rtip[1] # rotor diameter\nn = RPM / 60.0 # rotation rate in revolutions per second\nVinfs = Js * n * D\n\n# - Set Operating Points - #\noperating_points = [deepcopy(operating_point) for i in 1:length(Vinfs)]\nfor (iv, v) in enumerate(Vinfs)\n    operating_points[iv].Vinf[] = v\nend\n\n# - Run Multi-point Analysis - #\nouts_vec, success_flags = DuctAPE.analyze(\n    ducted_rotor,\n    operating_points,\n    reference_parameters,\n    DuctAPE.set_options(operating_points),\n)\nnothing #hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"There are a few things to note here.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"We want to make sure that the operating point objects we put into the input vector are unique instances.\nWe need to use the dispatch of set_options that accepts the operating point vector to set up the right number of things in the background (like convergence flags for each operating point).\nThe outputs of the analysis are vectors of the same outputs for a single analysis.","category":"page"},{"location":"DuctAPE/tutorial/#Multi-point-Outputs","page":"Getting Started","title":"Multi-point Outputs","text":"","category":"section"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"For multi-point analysis outputs, which are given as a vector of output objects, we might access and plot things as follows. We also take the opportunity to present some verification against DFDC, showing that DuctAPE matches remarkably well (within 0.5%) of DFDC. We therefore first provide data from DFDC analyses of the above example geometry at various advance ratios.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# Verification Data From DFDC\n\ndfdc_jept = [\n    0.0 0.0 0.64763 0.96692\n    0.1 0.1366 0.64716 0.88394\n    0.2 0.2506 0.6448 0.80785\n    0.3 0.3457 0.64044 0.73801\n    0.4 0.4251 0.63401 0.67382\n    0.5 0.4915 0.62534 0.61468\n    0.6 0.547 0.61428 0.56001\n    0.7 0.5935 0.6006 0.50925\n    0.8 0.6326 0.58411 0.46187\n    0.9 0.6654 0.56452 0.41738\n    1.0 0.693 0.54158 0.37531\n    1.1 0.716 0.51499 0.33522\n    1.2 0.7349 0.48446 0.2967\n    1.3 0.7499 0.44966 0.25937\n    1.4 0.7606 0.41031 0.2229\n    1.5 0.7661 0.36604 0.18694\n    1.6 0.7643 0.31654 0.15121\n    1.7 0.7506 0.26153 0.11547\n    1.8 0.7126 0.20061 0.07941\n    1.9 0.61 0.13355 0.04287\n    2.0 0.1861 0.05993 0.00558\n]\n\ndfdc_J = dfdc_jept[:,1]\ndfdc_eta = dfdc_jept[:,2]\ndfdc_cp = dfdc_jept[:,3]\ndfdc_ct = dfdc_jept[:,4]\nnothing #hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"We can then access the various multi-point analysis outputs however is convenient, we choose a broadcasting approach here:","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# - extract efficiency, power, and thrust coefficients - #\n\n# efficiency\neta = (p->p.totals.total_efficiency[1]).(outs_vec)\n\n# power\nc_p = (p->p.totals.CP[1]).(outs_vec)\n\n# thrust\nc_t = (p->p.totals.CT[1]).(outs_vec)\nnothing #hide","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"And then we can plot the data to compare DFDC and DuctAPE.","category":"page"},{"location":"DuctAPE/tutorial/","page":"Getting Started","title":"Getting Started","text":"# set up efficiency plot\npe = plot(; xlabel=\"Advance Ratio\", ylabel=\"Efficiency\")\n\n# plot DFDC data\nplot!(\n    pe,\n    dfdc_J,\n    dfdc_eta;\n    seriestype=:scatter,\n    markersize=5,\n    markercolor=plotsgray, # hide\n    markerstrokecolor=plotsgray, # hide\n    label=\"DFDC\",\n)\n\n# Plot DuctAPE outputs\nplot!(\n    pe,\n    Js,\n    eta;\n    linewidth=2,\n    color=primary, # hide\n    label=\"DuctAPE\",\n)\n\n# setup c_p/c_t plot\nppt = plot(; xlabel=\"Advance Ratio\")\n\n# plot DFDC data\nplot!(\n    ppt,\n    dfdc_J,\n    dfdc_cp;\n    seriestype=:scatter,\n    markersize=5,\n    markercolor=plotsgray, # hide\n    markerstrokecolor=primary, # hide\n    markerstrokewidth=2,\n    label=\"DFDC Cp\",\n)\n\nplot!(\n    ppt,\n    dfdc_J,\n    dfdc_ct;\n    seriestype=:scatter,\n    markersize=5,\n    markercolor=plotsgray, # hide\n    markerstrokecolor=secondary, # hide\n    markerstrokewidth=2,\n    label=\"DFDC Ct\",\n)\n\n# plot DuctAPE outputs\nplot!(\n    ppt,\n    Js,\n    c_p;\n    linewidth=1.5,\n    color=primary, # hide\n    label=\"DuctAPE c_p\",\n)\n\nplot!(\n    ppt,\n    Js,\n    c_t;\n    linewidth=1.5,\n    color=secondary, # hide\n    label=\"DuctAPE Ct\",\n)\n\nplot(\n    pe,\n    ppt;\n    size=(700, 350),\n    layout=(1, 2),\n    margin=2mm, # hide\n)","category":"page"},{"location":"DuctAPE/api/api_index/#Index","page":"API Index","title":"Index","text":"","category":"section"},{"location":"DuctAPE/api/api_index/","page":"API Index","title":"API Index","text":"Modules=[DuctAPE]","category":"page"}]
}
