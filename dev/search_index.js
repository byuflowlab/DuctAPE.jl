var documenterSearchIndex = {"docs":
[{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"At this point, the user is referred to the DFDC documentation for the general theory. Additional theory documentation is in development.","category":"page"},{"location":"examples/#Guided-Examples","page":"Guided Examples","title":"Guided Examples","text":"","category":"section"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Public","page":"API Reference","title":"Public","text":"","category":"section"},{"location":"reference/#Private","page":"API Reference","title":"Private","text":"","category":"section"},{"location":"reference/#Grid-Functions","page":"API Reference","title":"Grid Functions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The wake grid initalization function actually calls two functions. The first is a method for initializing the grid geometry based on conservation of mass:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"DuctTAPE.generate_grid_points","category":"page"},{"location":"reference/#DuctTAPE.generate_grid_points","page":"API Reference","title":"DuctTAPE.generate_grid_points","text":"generate_grid_points(ductgeometry, ductsplines, rotors, grid_options, debug=false)\n\nGet grid boundary and initial interior points.\n\nArguments:\n\nduct::DuctTAPE.Duct : Duct Object.\nrotors::Array{DuctTAPE.Rotor} : Array of Rotor objects\ngrid_options::DuctTAPE.GridOptions : GridOptions object\n\nReturns:\n\nx_grid_points::Matrix{Float64,2} : 2D Array of x grid points\nr_grid_points::Matrix{Float64,2} : 2D Array of r grid points\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The second is an elliptic grid solver using successive line over relaxation (SLOR) to relax the grid, meaning more accurately place the radial grid points along streamlines:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"DuctTAPE.relax_grid","category":"page"},{"location":"reference/#DuctTAPE.relax_grid","page":"API Reference","title":"DuctTAPE.relax_grid","text":"relax_grid(xg, rg, nxi, neta; max_iterations, tol)\n\nRelax grid using elliptic grid solver.\n\nArguments:\n\nxg::Matrix{Float64} : Initial x grid points guess\nrg::Matrix{Float64} : Initial r grid points guess\nnxi::Int : number of xi (x) stations in the grid\nneta::Int : number of eta (r) stations in the grid\n\nKeyword Arguments:\n\nmax_iterations::Int : maximum number of iterations to run, default=100\ntol::Float : convergence tolerance, default = 1e-9\n\nReturns:\n\nx_relax_points::Matrix{Float64} : Relaxed x grid points guess\nr_relax_points::Matrix{Float64} : Relaxed r grid points guess\n\n\n\n\n\n","category":"function"},{"location":"","page":"Intro","title":"Intro","text":"CurrentModule = DuctTAPE","category":"page"},{"location":"#DuctTAPE-([Duct](#)ed-[T](#)wo-dimensional-[A](#)ero[P](#)ropulsor-[E](#)valuation)","page":"Intro","title":"DuctTAPE (Ducted Two-dimensional AeroPropulsor Evaluation)","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Documentation for DuctTAPE.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"DuctTAPE is a code for the aerodynamic evaluation of 2D, axisymmetric, ducted propulsors design for incompressible aerodynamic applications (although hydrodynamic applications could also apply, but aero made the acronym work).","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"It is heavily based on the code DFDC, but has been developed specifically for use in gradient based optimization.","category":"page"},{"location":"tutorial/#Quick-Start-Guide","page":"Quick Start","title":"Quick Start Guide","text":"","category":"section"},{"location":"tutorial/#Setting-up-Duct-Geometry","page":"Quick Start","title":"Setting up Duct Geometry","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"For this example, we are going to set up an example available in the DFDC source files. We have taken one of the case files and transcribed it into a julia file located in the data directory.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"using DuctTAPE\nusing Plots\nusing Measures\n\ndefault()\ndefault(;\n    fontfamily=\"Palatino Roman\",\n    size=(800, 600), #it appears that 100 â‰ˆ 1inch in LaTeX\n    fillalpha=0.125,\n    fillcolor=RGB(128 / 255, 128 / 255, 128 / 255),\n    linewidth=1.0,\n    annotationfontfamily=\"Palatino Roman\",\n    markerstrokewidth=0.1,\n    annotationfontsize=10,\n    background_color_inside=nothing,\n    background_color_legend=nothing,\n    background_color_subplot=nothing,\n    color_palette=[\n        RGB(0.0, 46.0 / 255.0, 93.0 / 255.0), #BYU Blue\n        RGB(155.0 / 255.0, 0.0, 0.0), #\"BYU\" Red\n        RGB(128.0 / 255.0, 128.0 / 255.0, 128.0 / 255.0), #Middle Gray\n        RGB(162.0 / 255.0, 227.0 / 255.0, 162.0 / 255.0), #Light Green\n        RGB(243.0 / 255.0, 209.0 / 255.0, 243.0 / 255.0), #Pink\n        RGB(205.0 / 255.0, 179.0 / 255.0, 0.0), #Yellow\n        RGB(161.0 / 255.0, 161.0 / 255.0, 226.0 / 255.0), #Purple\n    ],\n    foreground_color_legend=nothing,\n    legend=false, # include legend true/false\n    grid=false, # background grid true/false\n    gridlinewidth=0.5,\n    margin = 10mm,\n)\n\nplot(xlabel=\"x\", ylabel=\"r\", aspectratio=:equal)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We'll go ahead and load that file and grab pieces of it as we go.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# --- WALL GEOMETRY DEFINITION\ninclude(\"../../data/dfdc/dstestr2_case.jl\");\n","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The geometry is defined for a complete airfoil as the duct wall. We actually want to split the duct wall coordinates for easier navigation as we set up the flow field.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.split_wall","category":"page"},{"location":"tutorial/#DuctTAPE.split_wall","page":"Quick Start","title":"DuctTAPE.split_wall","text":"split_wall(x,r)\n\nSplits full airfoil coordinates into upper and lower halves.\n\nOnly works based on geometry.  Splits at lowest x-value, does not split based on stagnation point.\n\nArguments:\n\nx::Array{Float} : Array of x-coordinates, assumed to start at the bottom trailing edge and proceed clockwise\nr::Array{Float} : Array of r-coordinates, assumed to start at the bottom trailing edge and proceed clockwise\n\nReturns:\n\nxlower::Array{Float} : Array of lower x-coordinates\nxupper::Array{Float} : Array of upper x-coordinates\nrlower::Array{Float} : Array of lower r-coordinates\nrupper::Array{Float} : Array of upper r-coordinates\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# - Split Wall Coordinates\nouterwallx, innerwallx, outerwallr, innerwallr = DuctTAPE.split_wall(ductx, ductr)\n\n# - Plot Geometry\nplot!(innerwallx, innerwallr, linewidth=2)\nplot!(outerwallx, outerwallr, linestyle=:dash, color=1, linewidth=2)\nplot!(hubx, hubr, color=2, linewidth=2)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Now we want to put all the geometry together in a DuctGeometry object.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.DuctGeometry\nDuctTAPE.defineDuctGeometry","category":"page"},{"location":"tutorial/#DuctTAPE.DuctGeometry","page":"Quick Start","title":"DuctTAPE.DuctGeometry","text":"DuctGeometry{TA,TF}\n\nFields:\n\nwallinnerxcoordinates::Array{Float} : x coordinates of inner (lower) wall geometry\nwallouterxcoordinates::Array{Float} : x coordinates of outer (upper) wall geometry\nwallinnerrcoordinates::Array{Float} : r coordinates of inner (lower) wall geometry\nwallouterrcoordinates::Array{Float} : r coordinates of outer (upper) wall geometry\nhubxcoordinates::Array{Float} : x coordinates of hub geometry\nhubrcoordinates::Array{Float} : r coordinates of hub geometry\nLEx::Float : x-position of leading edge\nTEx::Float : x-position of trailing edge\nchord::Float : chord length\nwallbluntTE::Bool : flag for blunt trailing edge on wall\nhubbluntTE::Bool : flag for blunt trailing edge on hub\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DuctTAPE.defineDuctGeometry","page":"Quick Start","title":"DuctTAPE.defineDuctGeometry","text":"defineDuctGeometry(\n    wallinnerxcoordinates,\n    wallinnerrcoordinates,\n    wallouterxcoordinates,\n    wallouterrcoordinates,\n    hubxcoordinates=nothing,\n    hubrcoordinates=nothing;\n    LEx=nothing,\n    TEx=nothing,\n    chord=nothing,\n)\n\nConstructor function for the DuctGeometry Object.\n\nRequired Arguments:\n\nwallinnerxcoordinates::Array{Float} : x coordinates of inner (lower) wall geometry\nwallouterxcoordinates::Array{Float} : x coordinates of outer (upper) wall geometry\nwallinnerrcoordinates::Array{Float} : r coordinates of inner (lower) wall geometry\nwallouterrcoordinates::Array{Float} : r coordinates of outer (upper) wall geometry\n\nOptional Arguments:\n\nhubxcoordinates::Array{Float} : x coordinates of hub geometry\nhubrcoordinates::Array{Float} : r coordinates of hub geometry\n\nNote, if hub x and r coordinates are not set, the x coordinates for the inner wall will be used and the r coordinates will be set to zero.  Also note that if one of these is unset, the other must also be unset.\n\nKeyword Arguments:\n\nLEx::Float : x-position of manually defined leading edge.  Set to foremost x-coordinate of duct and hub geometry otherwise.\nTEx::Float : x-position of mannually defined trailing edge.  Set to the rear-most x-coordinate of duct and hub geometry otherwise.\nchord::Float : manuall defined chord length.  Set to difference between leading and trailing edges otherwise.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Using the defineDuctGeometry contructor function, we can input our wall and hub geometries and let the leading and trailing edges and chord length be calculated automatically. Note that this function also outputs a spline object for the inner duct wall and the hub wall. These splines are used throughout the initialization process to help with rotor placement.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# --- DEFINE DUCT OBJECT\nductgeometry, ductsplines = DuctTAPE.defineDuctGeometry(\n    innerwallx,\n    innerwallr,\n    outerwallx,\n    outerwallr,\n    hubx,\n    hubr\n)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The ductgeometry and ductsplines objects now contains all the geometry information we'll need.","category":"page"},{"location":"tutorial/#Defining-Rotors","page":"Quick Start","title":"Defining Rotors","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Along with the duct geometry, we will need to define an array of Rotor objects.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.RotorGeometry","category":"page"},{"location":"tutorial/#DuctTAPE.RotorGeometry","page":"Quick Start","title":"DuctTAPE.RotorGeometry","text":"RotorGeometry{TF, TI, TA, TC, TT, TAF, TR, TM}\n\nFields:\n\nxlocation::Float : x location of rotor plane, non-dimensional based on duct chord (max TE location - min LE location of hub/wall)\nnumblades::Int : number of rotor blades\nradialstations::Array{Float} : array of radial stations defining rotor blade, non-dimensional with hub=0, tip=1\ntipgap::Float : gap between blade tip and duct wall (not implemented yet)\nchords::Array{Float} : array of chord lengths at radial stations defining rotor blade, non-dimensional based on blade tip radius\ntwists::Array{Float} : array of twist values (in degrees) at radial stations defining rotor blade\nskews::Array{Float} : array of skew values (similar to sweep) at radial stations defining rotor blade, non-dimensional based on rotor tip radius. (note: this is for reference only, the solver can't use this information)\nrakes::Array{Float} : array of rake values (similar to dihedral) at radial stations defining rotor blade, non-dimensional based on rotor tip radius. (note: this is for reference only right now. it may be implemented into the grid initialization functions later.)\nairfoils::Array{Airfoil} : array of airfoil data objects at radial stations defining rotor blade\nsolidity:Array{Float} : array of rotor solidity at radial stations defining rotor blade, chord/distance between blade sections\nrpm::Float : RPM of rotor\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Note that we want to create an array, even if we only have one rotor.  When we initialize the grid, it will expect an array. Also, our rotor object has more fields than are used in the original dfdc, for now, we'll set the section skew, rake, and solidity to nothing. For the airfoils, we will use the CCBlade.jl functionality and for our case here, define our airfoils as ccb.AlphaReAF objects (where CCBlade has been included in the DuctTAPE package and renamed 'ccb') using data files from digitized dfdc plots.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# -- GENERATE ROTOR OBJECT ARRAY\n\n# set datapath for airfoil data files. Remember to grab these files and change the data path for your case.\ndatapath = \"../../data/dfdc/airfoils/\"\n\n# generate airfoils for rotor\naf1 = DuctTAPE.ccb.AlphaReAF([\n    datapath * \"disk1_re5e5.dat\",\n    datapath * \"disk1_re1e6.dat\",\n    datapath * \"disk1_re1.5e6.dat\",\n    datapath * \"disk1_re2e6.dat\",\n])\n\n# generate airfoils for stator\naf2 = DuctTAPE.ccb.AlphaReAF([\n    datapath * \"disk2_re5e5.dat\",\n    datapath * \"disk2_re1e6.dat\",\n    datapath * \"disk2_re1.5e6.dat\",\n    datapath * \"disk2_re2e6.dat\",\n])\n\n#generate rotor object\nrotor1 = DuctTAPE.RotorGeometry(\n    xdisk1, #x position of rotor\n    nblade1, #number of blades\n    rnondim1, #radial stations\n    0.0, #tip gap\n    chord1, #chords\n    beta1, #twists\n    nothing, #skews\n    nothing, #rakes\n    fill(af1,length(rnondim1)), #airfoils\n    nothing, #solidities\n    rpm, #RPM\n)\n\n#generate stator object (rpm is zero for stator)\nrotor2 = DuctTAPE.RotorGeometry(\n    xdisk2, #x position of rotor\n    nblade2, #number of blades\n    rnondim2, #radial stations\n    0.0, #tip gap\n    chord2, #chords\n    beta2, #twists\n    nothing, #skews\n    nothing, #rakes\n    fill(af2,length(rnondim2)), #airfoils\n    nothing, #solidities\n    0.0, #RPM\n)\n\n#assemble array\nrotors = [rotor1; rotor2]","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Take note that the rotor objects are defined using non-dimensional parameters. If we want to visualize things at this point, we'll have to dimensionalize things, which is done internally in the code using BladeDimensions objects.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.BladeDimensions\nDuctTAPE.initialize_blade_dimensions","category":"page"},{"location":"tutorial/#DuctTAPE.BladeDimensions","page":"Quick Start","title":"DuctTAPE.BladeDimensions","text":"BladeDimensions{TF, TA}\n\nFields:\n\nrhub::Float : hub radius (dimensional)\nrtip::Float : tip radius (dimensional)\nrdim::Array{Float} : array of dimensional radial stations\ncdim::Array{Float} : array of dimensional chords\ntdim::Array{Float} : array of twists (already dimensional in rotorgeometry)\nsweptannulus::Float : area of blade swept annulus\nsweptarea::Float : area of blade tip swept disk\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DuctTAPE.initialize_blade_dimensions","page":"Quick Start","title":"DuctTAPE.initialize_blade_dimensions","text":"initialize_blade_dimensions(ductsplines, Rotor)\n\nInitilialize needed blade information for various calculations during the solution process.\n\nArguments:\n\nductsplines::DuctTAPE.ductsplines : ductsplines object containing splines for duct wall and hub\nRotor::DuctTAPE.Rotor : Rotor object for which to define blade information\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"blade1 = DuctTAPE.initialize_blade_dimensions(ductgeometry, ductsplines, rotor1)\nblade2 = DuctTAPE.initialize_blade_dimensions(ductgeometry, ductsplines, rotor2)\n\nnr = length(blade1.rdim)\n\nplot!(rotor1.xlocation.*ductgeometry.chord*ones(nr), blade1.rdim, color=4, linewidth=2)\nplot!(rotor2.xlocation.*ductgeometry.chord*ones(nr), blade2.rdim, color=4, linewidth=2)\n","category":"page"},{"location":"tutorial/#Wake-Grid-Initialization","page":"Quick Start","title":"Wake Grid Initialization","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"With the duct geometry and rotor data defined, we can now initialize the rotor wake grid. We'll begin by setting some grid options.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"note: Note\nThe number of radial stations set for grid options must match the number of radial stations defined for the rotor objects. Furthermore, the rotors must have the same number of radial stations defined.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.GridOptions\nDuctTAPE.defineGridOptions","category":"page"},{"location":"tutorial/#DuctTAPE.GridOptions","page":"Quick Start","title":"DuctTAPE.GridOptions","text":"GridOptions{TF,TI}\n\nFields:\n\nnum_radial_stations::Integer : Number of radial stations (equal to number of rotor blade elements used in analysis)\ninlet_length::Float : inlet length (unused)\nwake_length::Float : length of wake behind duct relative to chord length\nwake_expansion_factor::Float : expansion factor to apply to wake grid generation\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DuctTAPE.defineGridOptions","page":"Quick Start","title":"DuctTAPE.defineGridOptions","text":"defineGridOptions(\n    num_radial_stations;\n    inlet_length=0.5,\n    wake_length=1.0,\n    wake_expansion_factor=1.1\n)\n\nConstructor function for the GridOptions object.\n\nRequired Argument:\n\nnum_radial_stations::Integer : Number of radial stations (equal to number of rotor blade elements used in analysis)\n\nKeyword Arguments:\n\ninlet_length::Float : inlet length (unused)\nwake_length::Float : length of wake behind duct in terms of chord length\nwake_expansion_factor::Float : expansion factor to apply to wake grid generation\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# --- SET GRID OPTIONS\nnum_radial_stations = length(rnondim1)\ngrid_options = DuctTAPE.defineGridOptions(num_radial_stations)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"With options set, rotor location chosen, and the wall and hub geometry available, we're finally ready to initialize the wake grid object.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.initialize_grid\nDuctTAPE.WakeGridGeometry","category":"page"},{"location":"tutorial/#DuctTAPE.initialize_grid","page":"Quick Start","title":"DuctTAPE.initialize_grid","text":"initialize_grid(ductgeometry, ductsplines, rotors, grid_options; max_iterations=-1, tol=1e-9)\n\nInitialize grid via zero-thrust, unit freestream solution.\n\nArguments:\n\nductgeometry::DuctTAPE.DuctGeometry : ductgeometry Geometry Object\nductsplines::DuctTAPE.DuctSplines : ductsplines object\nrotors::Array{DuctTAPE.Rotor} : Array of rotor objects\ngrid_options::DuctTAPE.GridOptions : Grid options object\n\nKeyword Arguments:\n\nmax_iterations::Int : maximum number of iterations to run, default=100\ntol::Float : convergence tolerance, default = 1e-9\n\nReturns:\n\nWakeGrid::DuctTAPE.WakeGridGeometry : WakeGridGeometry Object\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#DuctTAPE.WakeGridGeometry","page":"Quick Start","title":"DuctTAPE.WakeGridGeometry","text":"WakeGridGeometry{TF,TI,TA,TW,TH}\n\nWake grid geometry object\n\nFields:\n\nx_grid_points::Matrix{Float} : 2D Array of x grid points\nr_grid_points::Matrix{Float} : 2D Array of radial grid points\nnx::Int : number of x stations\nnr::Int : number of radial stations\nwallTEidx::Int : index of duct wall trailing edge x location\nhubTEidx::Int : index of hub wall trailing edge x location\nrotoridxs::Array{Int} : array of indices of rotor x locations\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# --- INITIALIZE GRID\nwakegrid = DuctTAPE.initialize_grid(ductgeometry, ductsplines, rotors, grid_options)\n\nxg = wakegrid.x_grid_points\nrg = wakegrid.r_grid_points\nnx = wakegrid.nx\nnr = wakegrid.nr\n\nplot(; xlabel=\"x\", ylabel=\"r\", aspectratio=:equal)\nplot!(\n    ductgeometry.wallinnerxcoordinates,\n    ductgeometry.wallinnerrcoordinates;\n    color=1,\n    linewidth=2,\n)\nplot!(\n    ductgeometry.wallouterxcoordinates,\n    ductgeometry.wallouterrcoordinates;\n    color=1,\n    linestyle=:dash,\n    linewidth=2,\n)\nplot!(ductgeometry.hubxcoordinates, ductgeometry.hubrcoordinates; color=2, linewidth=2)\n\nplot!(rotor1.xlocation .* ductgeometry.chord * ones(nr), blade1.rdim; color=4, linewidth=2)\nplot!(rotor2.xlocation .* ductgeometry.chord * ones(nr), blade2.rdim; color=4, linewidth=2)\n\nplot!(xg, rg; color=3, linewidth=0.5)\nplot!(xg', rg'; color=3, linewidth=0.5)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"note: Note\nThis process should be relatively robust in that most combinations of wall and hub and rotor position should generate a grid. However, in the case that there is no overlap in the x-positions of the wall and hub, problems may occur later in the solver. In addition if the rotor is positioned somewhere not between the wall and hub, for example, if the rotor is out in front of the duct, then if a solution is found, it will likely be inaccurate. And finally, things will break if the hub and wall overlap in the radial direction, in other words, if the duct is blocked.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"As can be seen in the plot above, there are a few features of the wake grid that deserve mention for the user's information. First, the grid is designed such that the grid spacing in the axial direction will line up with the rotor positions as well as the trailing edge positions of the duct wall and hub (as well as the leading edge positions if they happen to be behind a rotor, which is not advised). In addition, the grid axial spacing is taken to be as close as possible to the radial spacing, which is defined directly from the rotor radial station positions. The wake spacing is started at the average of the axial spacing inside the duct area and then expanded by an expansion factor that can be defined by the user and is set to 1.1 by default.  This means that the end of the wake will actually not lie directly at the length input by the user (default 2x duct chord), but should be close enough.","category":"page"},{"location":"tutorial/#System-Paneling","page":"Quick Start","title":"System Paneling","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"With the geometry defined and the grid initialized, we can define the system panels and their control points (centers). To do so, we use the generate_paneling function:","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"DuctTAPE.generate_paneling","category":"page"},{"location":"tutorial/#DuctTAPE.generate_paneling","page":"Quick Start","title":"DuctTAPE.generate_paneling","text":"generate_paneling(ductgeometry, ductsplines, rotors, wakegrid)\n\nGenerate panel edges and centers.\n\nArguments:\n\nductgeometry::DuctTAPE.DuctGeometry : Duct Geometry object\nductsplines::DuctTAPE.DuctSplines : Duct Splines object\nrotors::Array{DuctTAPE.Rotor} : Array of rotor objects\nwakegrid::DuctTAPE.WakeGridGeometry : Wake Grid object\n\nReturns:\n\nwall_panels::DuctTAPE.Panels : Panels object for duct wall\nhub_panels::DuctTAPE.Panels : Panels object for hub\nwake_panels::DuctTAPE.Panels : Panels object for vortex wake sheets\nrotor_source_panels::Array{DuctTAPE.Panels} : Array of Panels objects for each rotor\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"For our case here, we are going to use a rough sampling of the geometry data in order to more clearly see the paneling.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# --- DEFINE DUCT OBJECT\nductgeometry, ductsplines = DuctTAPE.defineDuctGeometry(\n    innerwallx[1:4:end],\n    innerwallr[1:4:end],\n    outerwallx[1:4:end],\n    outerwallr[1:4:end],\n    hubx[1:4:end],\n    hubr[1:4:end]\n)\n# -- GENERATE ROTOR OBJECT ARRAY\n\n#generate rotor object\nrotor1 = DuctTAPE.RotorGeometry(\n    xdisk1,\n    nblade1,\n    rnondim1[1:2:end],\n    0.0,\n    chord1[1:2:end],\n    beta1[1:2:end],\n    nothing,\n    nothing,\n    nothing,\n    nothing,\n    rpm,\n)\n\n#generate stator object (rpm is zero for stator)\nrotor2 = DuctTAPE.RotorGeometry(\n    xdisk2,\n    nblade2,\n    rnondim2[1:2:end],\n    0.0,\n    chord2[1:2:end],\n    beta2[1:2:end],\n    nothing,\n    nothing,\n    nothing,\n    nothing,\n    0.0,\n)\n\n#assemble array\nrotors = [rotor1; rotor2]\n\n# --- SET GRID OPTIONS\nnum_radial_stations = length(rnondim1[1:2:end])\ngrid_options = DuctTAPE.defineGridOptions(num_radial_stations)\n\n\n# --- INITIALIZE GRID\nwakegrid = DuctTAPE.initialize_grid(ductgeometry, ductsplines, rotors, grid_options)\n\nxg = wakegrid.x_grid_points\nrg = wakegrid.r_grid_points\nnx = wakegrid.nx\nnr = wakegrid.nr\n","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# Get paneling of various objects\n\nwall_panels, hub_panels, wake_panels, rotor_source_panels = DuctTAPE.generate_paneling(\n    ductgeometry, ductsplines, rotors, wakegrid\n)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"\n# PLOT PANELS\n\nplot(; xlabel=\"x\", ylabel=\"r\", aspectratio=:equal, legend=true, label=\"\")\n\n# wall panels:\nfor i in 1:length(wall_panels.panel_edges_x)\n    plot!(\n        [wall_panels.panel_edges_x[i][1]; wall_panels.panel_edges_x[i][2]],\n        [wall_panels.panel_edges_r[i][1]; wall_panels.panel_edges_r[i][2]];\n        color=1,\n        linewidth=0.5,\n        markershape=:diamond,\n        markersize=2,\n        label=\"\",\n    )\nend\n\nscatter!(\n    getindex.(wall_panels.panel_centers, 1),\n    getindex.(wall_panels.panel_centers, 2);\n    color=1,\n    markersize=3,\n    markershape=:circle,\n    label=\"wall panel centers\",\n)\n\n#hub panels:\nfor i in 1:length(hub_panels.panel_edges_x)\n    plot!(\n        [hub_panels.panel_edges_x[i][1]; hub_panels.panel_edges_x[i][2]],\n        [hub_panels.panel_edges_r[i][1]; hub_panels.panel_edges_r[i][2]];\n        markersize=2,\n        markershape=:diamond,\n        color=2,\n        linewidth=0.5,\n        label=\"\",\n    )\nend\n\nscatter!(\n    getindex.(hub_panels.panel_centers, 1),\n    getindex.(hub_panels.panel_centers, 2);\n    markersize=3,\n    markershape=:circle,\n    color=2,\n    label=\"hub panel centers\",\n)\n\n#vortex sheet panels\nfor i in 1:length(wake_panels.panel_centers)\n    plot!(\n        [wake_panels.panel_edges_x[i][1]; wake_panels.panel_edges_x[i][2]],\n        [wake_panels.panel_edges_r[i][1]; wake_panels.panel_edges_r[i][2]];\n        markersize=2,\n        markershape=:diamond,\n        color=3,\n        linewidth=0.5,\n        label=\"\",\n    )\nend\n\nscatter!(\n    getindex.(wake_panels.panel_centers, 1),\n    getindex.(wake_panels.panel_centers, 2);\n    markersize=3,\n    markershape=:circle,\n    color=3,\n    label=\"vortex sheet panel centers\",\n)\n\n#rotor source panels:\nfor i in 1:length(rotor_source_panels[1].panel_centers)\n    plot!(\n        [\n            rotor_source_panels[1].panel_edges_x[i][1]\n            rotor_source_panels[1].panel_edges_x[i][2]\n        ],\n        [\n            rotor_source_panels[1].panel_edges_r[i][1]\n            rotor_source_panels[1].panel_edges_r[i][2]\n        ];\n        markersize=2,\n        markershape=:diamond,\n        color=4,\n        linewidth=0.5,\n        label=\"\",\n    )\nend\n\nscatter!(\n    getindex.(rotor_source_panels[1].panel_centers, 1),\n    getindex.(rotor_source_panels[1].panel_centers, 2);\n    markersize=3,\n    markershape=:circle,\n    color=4,\n    label=\"rotor source panel centers\",\n)\n\n# stator source panels\nfor i in 1:length(rotor_source_panels[2].panel_centers)\n    plot!(\n        [\n            rotor_source_panels[2].panel_edges_x[i][1]\n            rotor_source_panels[2].panel_edges_x[i][2]\n        ],\n        [\n            rotor_source_panels[2].panel_edges_r[i][1]\n            rotor_source_panels[2].panel_edges_r[i][2]\n        ];\n        markersize=2,\n        markershape=:diamond,\n        color=4,\n        linewidth=0.5,\n        label=\"\",\n    )\nend\n\nscatter!(\n    getindex.(rotor_source_panels[2].panel_centers, 1),\n    getindex.(rotor_source_panels[2].panel_centers, 2);\n    markersize=3,\n    markershape=:circle,\n    color=4,\n    label=\"\",\n)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The paneling for the rotor sources and the vortex wake sheets is based directly on the wake grid initialized in the previous section (remember that we used a rougher dataset here for visual clarity). The paneling of the duct wall and hub are set such that the panels aft of the foremost rotor also align perfectly with the wake grid. The points in front of the foremost rotor are set using cosine spacing such that the last panel before the foremost rotor is roughly similar in length to the average of the panel lenghts in the remainder of the duct. (Note that the estimation process for this is not particularly robust at this point.)","category":"page"}]
}
