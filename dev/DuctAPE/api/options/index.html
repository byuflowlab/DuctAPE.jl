<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Options · DuctAPE.jl</title><meta name="title" content="Options · DuctAPE.jl"/><meta property="og:title" content="Options · DuctAPE.jl"/><meta property="twitter:title" content="Options · DuctAPE.jl"/><meta name="description" content="Documentation for DuctAPE.jl."/><meta property="og:description" content="Documentation for DuctAPE.jl."/><meta property="twitter:description" content="Documentation for DuctAPE.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="DuctAPE.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">DuctAPE.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">DuctAPE</span><ul><li><a class="tocitem" href="../../tutorial/">Quick Start</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../inputs/">Required Inputs</a></li><li class="is-active"><a class="tocitem" href>Options</a><ul class="internal"><li><a class="tocitem" href="#Bookkeeping-Options"><span>Bookkeeping Options</span></a></li><li><a class="tocitem" href="#General-Options"><span>General Options</span></a></li><li><a class="tocitem" href="#Preprocess-Options"><span>Preprocess Options</span></a></li><li><a class="tocitem" href="#Solver-Options"><span>Solver Options</span></a></li><li><a class="tocitem" href="#Postprocess-Options"><span>Postprocess Options</span></a></li><li class="toplevel"><a class="tocitem" href="#Advanced-Options-for-Multi-point-analyses"><span>Advanced Options for Multi-point analyses</span></a></li></ul></li><li><a class="tocitem" href="../caches/">Precompiled Caches</a></li><li><a class="tocitem" href="../outputs/">Outputs</a></li><li><a class="tocitem" href="../api_index/">API Index</a></li></ul></li><li><a class="tocitem" href="../../visualization/">Visualization</a></li><li><a class="tocitem" href="../../theory/">Theory</a></li></ul></li><li><span class="tocitem">C<span>$^4$</span>Blade</span><ul><li><a class="tocitem" href="../../../C4Blade/intro/">Intro</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Blade Element Types</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../C4Blade/airfoil_types/DFDC/">DFDC Airfoil Type</a></li><li><a class="tocitem" href="../../../C4Blade/airfoil_types/CCBlade/">CCBlade Airfoil Types</a></li><li><a class="tocitem" href="../../../C4Blade/airfoil_types/actuator_disk/">Actuator Disk Type</a></li><li><a class="tocitem" href="../../../C4Blade/airfoil_types/cascade/">Cascade Types</a></li></ul></li><li><a class="tocitem" href="../../../C4Blade/api/">API Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">DuctAPE</a></li><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Options</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Options</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/byuflowlab/DuctAPE.jl/blob/{commit}{path}#L{line}" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/byuflowlab/DuctAPE.jl/blob/main/docs/src/DuctAPE/api/options.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h1><p>There are quite a few options to choose from in DuctAPE. As DuctAPE was developed, various options were added as different approaches were considered. The current defaults were selected as the best set of options for the studies in the publications metioned in DuctAPE&#39;s README. However, most of the options implemented during development have been maintained in case of future need. The <code>Options</code> object contains various general options as well as several more detailed option objects. To make the process of setting options easier, the <code>set_options</code> method can be used to make only the desired changes from the defaults without having to define everything in the <code>Options</code> object. Note that the <code>Options</code> object is implemented using the <code>@kwdef</code> macro, so the <code>set_options</code> function doesn&#39;t really do anything in the case of a single operating point, but the other dispatch of <code>set_options</code> is especially helpful in initializing several of the sub-option objects to defaults of the correct size. Note that there are several fields in the options that are used for bookkeeping, especially in the case of multiple operating points.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.Options" href="#DuctAPE.Options"><code>DuctAPE.Options</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Options</code></pre><p>Type containing (nearly) all the available user options.</p><p><strong>Fields</strong></p><p><strong>General Options</strong></p><ul><li><code>verbose::Bool = false</code> : flag to print verbose statements</li><li><code>silence_warnings::Bool = true</code> : flag to silence warnings</li><li><code>hard_fail::Bool = true</code> : flag as to whether DuctAPE should return nothing immediately after a failed initialization of the elliptic grid or a failed decomposition of the body influence matrix.  If set to false, DuctAPE will attempt to return objects of the correct size, but with initialized values only.</li></ul><p><strong>Pre-processing Options</strong></p><p><strong>Geometry Interpolation and Generation Options</strong></p><ul><li><code>finterp::Interplation Method = FLOWMath.akima</code> : interpolation method used for re-paneling bodies</li><li><code>autoshiftduct::Bool = true</code> : flag as to whether duct geometry should be shifted based on rotor tip location</li></ul><p><strong>Paneling Options</strong></p><ul><li><code>itcpshift::Float = 0.05</code> : factor for internal trailing edge psuedo-panel placement (default is DFDC hard-coded value)</li><li><code>axistol::Float = 1e-15</code> : tolerance for how close the the axis of rotation should be considered on the axis</li><li><code>tegaptol::Float = 1e1 * eps()</code> : tolerance for how large of a trailing edge gap should be considered a gap</li></ul><p><strong>Integration Options</strong></p><ul><li><code>integration_options::IntegrationOptions type = IntegrationOptions()</code> : integration options</li></ul><p><strong>Post-processing Options</strong></p><ul><li><code>boundary_layer_options::BoundaryLayerOptions</code> : BoundaryLayerOptions object</li><li><code>write_outputs::AbstractArray{Bool} = [false]</code> : Bool for whether to write the outputs of the analysis to an external file (slow)</li><li><code>outfile::AbstractArray{String} = [&quot;outputs.jl&quot;]</code> : External output file name (including path information) for files to write</li><li><code>checkoutfileexists::Bool = false</code> : Flag for whether to check if file exists before overwriting</li><li><code>output_tuple_name::AbstractArray{String} = [&quot;outs&quot;]</code> : variable name for named tuple written to out file</li></ul><p><strong>Solving Options</strong></p><ul><li><code>grid_solver_options::GridSolverOptionsType = GridSolverOptions()</code> : elliptic grid solver options</li><li><code>solver_options::SolverOptionsType = ChainSolverOptions()</code> : solver options</li></ul><p><strong>Bookkeeping Options</strong></p><ul><li><code>multipoint_index::Int = [1]</code> : holds current index of multi-point solver (no need for user to change this usually)</li><li><code>lu_decomp_flag::Bool = false</code> : flag indicating if panel method LHS matrix factorization was successful</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L748-L780">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.set_options" href="#DuctAPE.set_options"><code>DuctAPE.set_options</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_options(; kwargs...)
set_options(multipoint; kwargs...)</code></pre><p>Set the options for DuctAPE to use.</p><p>Note that the vast majority of the available options are defined through keyword arguments.  See the documentation for the various option types for more information.</p><p><strong>Arguments</strong></p><ul><li><code>multipoint::AbstractArray{OperatingPoint}</code> : a vector of operating points to use if running a multi-point analysis.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L821-L831">source</a></section></article><p>The major sub-categories of options include general options, pre-processing options, solver options for both determining the wake sheet positions as well as the overall aerodyanmics solve, post-processing options, and bookkeeping options.</p><hr/><h2 id="Bookkeeping-Options"><a class="docs-heading-anchor" href="#Bookkeeping-Options">Bookkeeping Options</a><a id="Bookkeeping-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Bookkeeping-Options" title="Permalink"></a></h2><p>These are options that can be changed by the user for development/debugging purposes, but at this point, it would be wise in general usage to not change them. In future revisions, these will likely no longer be accessible to the user.</p><hr/><h2 id="General-Options"><a class="docs-heading-anchor" href="#General-Options">General Options</a><a id="General-Options-1"></a><a class="docs-heading-anchor-permalink" href="#General-Options" title="Permalink"></a></h2><p>The verbose and silence warnings options are simply about what get&#39;s printed as the analysis runs. Warnings are printed when some sort of automated adjustment is made to the inputs in order to ensure they conform to the format required. The verbose option at this level is for verbose statements that are not within any solvers.  Solver verbosity is constrolled in the individual solver options.</p><p>Occasionally, something in the preprocessing will fail, likely the LU decomposition of the linear system defining the bodies&#39; panel system. If such a failure occurs, DuctAPE cannot continue to the main solve and will exit. The <code>hard_fail</code> option dictates what the exit behavior is. If true, DuctAPE will just return <code>nothing</code> immediately, which is quicker for turn-around on single runs. If false, DuctAPE will attempt to return an output object of the correct size and type, which is convenient for some optimization frameworks for which you&#39;ll want some output to be available even if passing a failure flag for the specific analysis.</p><hr/><h2 id="Preprocess-Options"><a class="docs-heading-anchor" href="#Preprocess-Options">Preprocess Options</a><a id="Preprocess-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Preprocess-Options" title="Permalink"></a></h2><h3 id="Geometry-Interpolation-and-Generation-Options"><a class="docs-heading-anchor" href="#Geometry-Interpolation-and-Generation-Options">Geometry Interpolation and Generation Options</a><a id="Geometry-Interpolation-and-Generation-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-Interpolation-and-Generation-Options" title="Permalink"></a></h3><p>The <code>autoshiftduct</code> option may be convenient depending on how the duct coordinates are being input. It allows the user to input the duct coordinates at an arbitrary radial location, for example if a standard airfoil is used with leading edge at (0,0). In the preprocessing, the duct geometry will be shifted to the radial location at which the rotor tip is coincident with the duct surface at the axial location at which the first rotor is situated. If you are already inputting the duct geometry at the correct position, this option may be turned off, but it usually doesn&#39;t hurt to be left on.</p><h3 id="Paneling-Options"><a class="docs-heading-anchor" href="#Paneling-Options">Paneling Options</a><a id="Paneling-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Paneling-Options" title="Permalink"></a></h3><p>These, in general, do not need to be touched by users; thus we do not include them in the <code>PanelingConstants</code>, but we do make them available.</p><h3 id="Integration-Options"><a class="docs-heading-anchor" href="#Integration-Options">Integration Options</a><a id="Integration-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-Options" title="Permalink"></a></h3><p>DuctAPE uses numerical integration to determine the influence of axisymmetric vortex and source panels on the restof the system. There are several options for numerical integration, and the methods can be mixed and matched with their own specific options for the nominal (panel on other panels) and singular (panel on itself) cases. The Gauss-Legendre method is useful in optimization cases to avoid noise in the integration error. The Gauss-Kronrod method is implemented via QuadGK.jl and is more accurate, especially in for the singular cases, but is less useful for optimization purposes due to noise in the error from the adaptive nature. Similarly, the Romberg method similar to that implemented in DFDC is adaptive and can be fast, but is also not usually the best choice. Thus we default to Gauss-Legendre methods.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.IntegrationOptions" href="#DuctAPE.IntegrationOptions"><code>DuctAPE.IntegrationOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IntegrationOptions</code></pre><p>A struct used to hold the integration options for both the nominal and singular cases.</p><p><strong>Fields</strong></p><ul><li><code>nominal::IntegrationMethod=GaussLegendre(8)</code> : the integration options to use for the nominal case.</li><li><code>singular::IntegrationMethod=GaussLegendre(8)</code> : the integration options to use for the self-induced case.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L158-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.GaussLegendre" href="#DuctAPE.GaussLegendre"><code>DuctAPE.GaussLegendre</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GaussLegendre &lt;: IntegrationMethod</code></pre><p>Options for Gauss-Legendre integration method</p><p><strong>Fields</strong></p><ul><li><code>sample_points::Int</code> : Sample Points</li><li><code>weights::Int</code> : Gauss weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L120-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.GaussKronrod" href="#DuctAPE.GaussKronrod"><code>DuctAPE.GaussKronrod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GaussKronrod &lt;: IntegrationMethod</code></pre><p>Options for Gauss-Kronrod integration method</p><p><strong>Fields</strong></p><ul><li><code>order::Int = 7</code> : order of Legendre polynomial to use on each interval</li><li><code>maxevales::Int = 10^7</code> : maximum number of evaluations in the adaptive method</li><li><code>atol::Float = 0.0</code> : absolute error tolerance. (note, if zero, QuadGK uses sqrt(eps()) relative tolerance).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L104-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.Romberg" href="#DuctAPE.Romberg"><code>DuctAPE.Romberg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Romberg &lt;: IntegrationMethod</code></pre><p>Options for Romberg integration method</p><p><strong>Fields</strong></p><ul><li><code>max_subdivisions::Int = 10</code> : maximum number of subdivisions. Note, total number of internvals is 2^N, where N is number of subdivisions.</li><li><code>atol::Float = 1e-6</code> : absolute error tolerance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L90-L98">source</a></section></article><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><pre><code class="language-julia hljs">using DuctAPE

# set nominal options using a GaussLegendre object (which is an InterationMethod type)
# note that a convenience method is used here that takes in the number of points and
#calculates the appropriate sample locations and weights.
nominal_integration_method = DuctAPE.GaussLegendre(10)

# set singular options using a GaussKronrod object (which is an InterationMethod type)
# note that like most option structs, these are defined using @kwdef allowing the fields
#to be treated as keyword arguments.
# also note that we haven&#39;t changed the evaluation limit (default 10^7)
singular_integration_method = DuctAPE.GaussKronrod(; order=7, atol=2e-16)

# put the quadrature options together
integration_options = DuctAPE.IntegrationOptions(;
    nominal=nominal_integration_method, singular=singular_integration_method
)

# example of calling the set_options function
options = DuctAPE.set_options(; integration_options=integration_options)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Options{Bool, DuctAPE.HeadsBoundaryLayerOptions{Bool, Float64, Float64, typeof(RK2), Int64, Float64, Float64, Float64, DuctAPE.RK, Nothing, Nothing}, Vector{Bool}, Float64, Vector{Int64}, Vector{String}, Vector{String}, DuctAPE.var&quot;#56#61&quot;, IntegrationOptions{GaussLegendre{Vector{Float64}, Vector{Float64}}, GaussKronrod{Float64, Int64}}, ModCSORSolverOptions{Bool, Float64, Int64, @NamedTuple{nrf::Float64, bt1::Float64, bt2::Float64, pf1::Float64, pf2::Float64, btw::Float64, pfw::Float64}}, GridSolverOptions{Bool, Float64, Int64, Symbol}}(false, true, [1], DuctAPE.var&quot;#56#61&quot;(), true, false, 0.05, 1.0e-15, 2.220446049250313e-15, IntegrationOptions{GaussLegendre{Vector{Float64}, Vector{Float64}}, GaussKronrod{Float64, Int64}}(GaussLegendre{Vector{Float64}, Vector{Float64}}([0.013046735741414128, 0.06746831665550773, 0.16029521585048778, 0.2833023029353764, 0.4255628305091844, 0.5744371694908156, 0.7166976970646236, 0.8397047841495122, 0.9325316833444923, 0.9869532642585859], [0.033335672154344104, 0.07472567457529028, 0.10954318125799103, 0.13463335965499826, 0.14776211235737646, 0.14776211235737646, 0.13463335965499826, 0.10954318125799103, 0.07472567457529028, 0.033335672154344104]), GaussKronrod{Float64, Int64}(7, 10000000, 2.0e-16)), DuctAPE.HeadsBoundaryLayerOptions{Bool, Float64, Float64, typeof(RK2), Int64, Float64, Float64, Float64, DuctAPE.RK, Nothing, Nothing}(false, true, true, false, 5000, 1.0e-6, nothing, nothing, 0.001, DuctAPE.RK(), DuctAPE.RK2, 3.0, 10, 10, 0.2, 0.2, false, 0.0, 0.0001, 0.0, false), Bool[0], [&quot;outputs.jl&quot;], false, [&quot;outs&quot;], GridSolverOptions{Bool, Float64, Int64, Symbol}(30, 3.0e-10, :newton, :forward, false, 3, Bool[0], [0], [0.0]), ModCSORSolverOptions{Bool, Float64, Int64, @NamedTuple{nrf::Float64, bt1::Float64, bt2::Float64, pf1::Float64, pf2::Float64, btw::Float64, pfw::Float64}}(false, 500, (nrf = 0.4, bt1 = 0.2, bt2 = 0.6, pf1 = 0.4, pf2 = 0.5, btw = 0.6, pfw = 1.2), 5.0e-10, Bool[0], [0], [-1.0]), true)</code></pre><hr/><h2 id="Solver-Options"><a class="docs-heading-anchor" href="#Solver-Options">Solver Options</a><a id="Solver-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-Options" title="Permalink"></a></h2><h3 id="Elliptic-Grid-Solver-Options"><a class="docs-heading-anchor" href="#Elliptic-Grid-Solver-Options">Elliptic Grid Solver Options</a><a id="Elliptic-Grid-Solver-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Elliptic-Grid-Solver-Options" title="Permalink"></a></h3><p>The wake geometry is obtained by solving for approximate streamlines on an elliptic grid with the bodies as boundaries. There are two methods available, a successive line over relaxiation (SLOR) method that can be used in isolation or as a preconditioner to a Newton solve method from the NLsolve.jl package. The default option is to run a few iterations of SLOR to precondition and smooth out the initial grid, and then finish up with the Newton solve, usually within 3-5 iterations. Note that the SLOR method is not implemented using ImplicitAD.jl since there isn&#39;t a clean residual definition separate from the solve method. The Newton solve is implemented using ImplicitAD.jl which helps speed up automatic differentiation in an optimization setting, but it still benefits from a few iterations of SLOR beforehand.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.SLORGridSolverOptions" href="#DuctAPE.SLORGridSolverOptions"><code>DuctAPE.SLORGridSolverOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SLORGridSolverOptions &lt;: GridSolverOptionsType</code></pre><p>Options for SLOR (successive line over relaxation) elliptic grid solver.</p><p><strong>Fields</strong></p><ul><li><code>iteration_limit::Int = 100</code> : maximum number of iterations</li><li><code>atol::Float = 1e-9</code> : absolute convergence tolerance</li><li><code>converged::AbstractArray{Bool}</code> = [false]</li><li><code>iterations::AbstractArray{Int} = [0]</code> : iteration counter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L597-L607">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.GridSolverOptions" href="#DuctAPE.GridSolverOptions"><code>DuctAPE.GridSolverOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GridSolverOptions &lt;: GridSolverOptionsType</code></pre><p>Options for Newton elliptic grid solver.</p><p><strong>Fields</strong></p><ul><li><code>iteration_limit::Int = 20</code> : maximum number of iterations</li><li><code>atol::Float = 3e-10</code> : absolute convergence tolerance</li><li><code>algorithm::Symbol = :newton</code> : algorithm to use in NLsolve.jl</li><li><code>autodiff::Symbol = :forward</code> : differentiation method to use in NLsolve.jl</li><li><code>precondition = false</code> : flag to precondition with SLOR</li><li><code>precondition_max_iterations = 3</code> : number of precondition iterations</li><li><code>converged::AbstractArray{Bool}</code> = [false]</li><li><code>iterations::AbstractArray{Int} = [0]</code> : iteration counter</li><li><code>residual_value::AbstractArray{Int} = [0]</code> : residual value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L615-L630">source</a></section></article><h4 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h4><pre><code class="language-julia hljs">using DuctAPE

# define wake grid solver settings
wake_solve_options = DuctAPE.GridSolverOptions(; atol=1e-10)

# set all options
options = DuctAPE.set_options(; grid_solver_options=wake_solve_options)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Options{Bool, DuctAPE.HeadsBoundaryLayerOptions{Bool, Float64, Float64, typeof(RK2), Int64, Float64, Float64, Float64, DuctAPE.RK, Nothing, Nothing}, Vector{Bool}, Float64, Vector{Int64}, Vector{String}, Vector{String}, DuctAPE.var&quot;#56#61&quot;, IntegrationOptions{GaussLegendre{Vector{Float64}, Vector{Float64}}, GaussLegendre{Vector{Float64}, Vector{Float64}}}, ModCSORSolverOptions{Bool, Float64, Int64, @NamedTuple{nrf::Float64, bt1::Float64, bt2::Float64, pf1::Float64, pf2::Float64, btw::Float64, pfw::Float64}}, GridSolverOptions{Bool, Float64, Int64, Symbol}}(false, true, [1], DuctAPE.var&quot;#56#61&quot;(), true, false, 0.05, 1.0e-15, 2.220446049250313e-15, IntegrationOptions{GaussLegendre{Vector{Float64}, Vector{Float64}}, GaussLegendre{Vector{Float64}, Vector{Float64}}}(GaussLegendre{Vector{Float64}, Vector{Float64}}([0.019855071751231856, 0.10166676129318664, 0.2372337950418355, 0.4082826787521751, 0.591717321247825, 0.7627662049581645, 0.8983332387068134, 0.9801449282487682], [0.05061426814518838, 0.11119051722668723, 0.15685332293894372, 0.18134189168918097, 0.18134189168918097, 0.15685332293894372, 0.11119051722668723, 0.05061426814518838]), GaussLegendre{Vector{Float64}, Vector{Float64}}([0.019855071751231856, 0.10166676129318664, 0.2372337950418355, 0.4082826787521751, 0.591717321247825, 0.7627662049581645, 0.8983332387068134, 0.9801449282487682], [0.05061426814518838, 0.11119051722668723, 0.15685332293894372, 0.18134189168918097, 0.18134189168918097, 0.15685332293894372, 0.11119051722668723, 0.05061426814518838])), DuctAPE.HeadsBoundaryLayerOptions{Bool, Float64, Float64, typeof(RK2), Int64, Float64, Float64, Float64, DuctAPE.RK, Nothing, Nothing}(false, true, true, false, 5000, 1.0e-6, nothing, nothing, 0.001, DuctAPE.RK(), DuctAPE.RK2, 3.0, 10, 10, 0.2, 0.2, false, 0.0, 0.0001, 0.0, false), Bool[0], [&quot;outputs.jl&quot;], false, [&quot;outs&quot;], GridSolverOptions{Bool, Float64, Int64, Symbol}(30, 1.0e-10, :newton, :forward, false, 3, Bool[0], [0], [0.0]), ModCSORSolverOptions{Bool, Float64, Int64, @NamedTuple{nrf::Float64, bt1::Float64, bt2::Float64, pf1::Float64, pf2::Float64, btw::Float64, pfw::Float64}}(false, 500, (nrf = 0.4, bt1 = 0.2, bt2 = 0.6, pf1 = 0.4, pf2 = 0.5, btw = 0.6, pfw = 1.2), 5.0e-10, Bool[0], [0], [-1.0]), true)</code></pre><h3 id="Aerodynamics-Solver-Options"><a class="docs-heading-anchor" href="#Aerodynamics-Solver-Options">Aerodynamics Solver Options</a><a id="Aerodynamics-Solver-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Aerodynamics-Solver-Options" title="Permalink"></a></h3><p>Quite a few solve methods were explored in the development of DuctAPE which can be separated into three broad categories: Fixed-point iteration solvers, quasi-Newton solvers, and Newton solvers. In general, the fixed-point solvers have been faster and more robust than other methods, but all the methods have been kept in case they are desired for future development.</p><p>There are two methods that are implemented directly in DuctAPE: the CSOR and ModCSOR methods which are the controlled successive over relaxation fixed-point approach taken in DFDC and a modified version compatible with ImplicitAD.jl that is the current default and is currently the best (fastest/most robust) for optimization.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.CSORSolverOptions" href="#DuctAPE.CSORSolverOptions"><code>DuctAPE.CSORSolverOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct CSORSolverOptions &lt;: InternalSolverOptions</code></pre><p>Type containing all the options for the CSOR (controlled successive over relaxation) solver.</p><p>Note that the defaults match DFDC settings.</p><p><strong>Fields</strong></p><ul><li><code>verbose::Bool = false</code> : flag to print verbose statements</li><li><code>iteration_limit::Float = 1e2</code> : maximum number of iterations</li><li><code>nrf::Float = 0.4</code> : nominal relaxation factor</li><li><code>bt1::Float = 0.2</code> : backtracking factor 1</li><li><code>bt2::Float = 0.6</code> : backtracking factor 2</li><li><code>pf1::Float = 0.4</code> : press forward factor 1</li><li><code>pf2::Float = 0.5</code> : press forward factor 2</li><li><code>btw::Float = 0.6</code> : backtracking factor for wake</li><li><code>pfw::Float = 1.2</code> : press forward factor for wake</li><li><code>f_circ::Float = 1e-3</code> : convergence tolerance for rotor circulation</li><li><code>f_dgamw::Float = 2e-4</code> : convergence tolerance for wake vortex strength</li><li><code>convergence_type::ConvergenceType = Relative()</code> : dispatch for relative or absolute convergence criteria.</li><li><code>Vconv::AbstractArray{Float} = [1.0]</code> : velocity used in relative convergence criteria (should be set to Vref).</li><li><code>converged::AbstractArray{Bool} = [false]</code> : flag to track if convergence took place.</li><li><code>iterations::AbstractArray{Int} = [0]</code> : iteration counter</li><li><code>residuals::AbstractArray{Float} = [-1.0]</code> : final residual values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L194-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.ModCSORSolverOptions" href="#DuctAPE.ModCSORSolverOptions"><code>DuctAPE.ModCSORSolverOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ModCSORSolverOptions &lt;: InternalSolverOptions</code></pre><p>Type containing all the options for the modified CSOR solver.</p><p><strong>Fields</strong></p><ul><li><code>verbose::Bool = false</code> : flag to print verbose statements</li><li><code>iteration_limit::Float = 350</code> : maximum number of iterations</li><li><code>relaxation_parameters::NamedTuple</code> = (;<ul><li><code>nrf::Float = 0.4</code> : nominal relaxation factor</li><li><code>bt1::Float = 0.2</code> : backtracking factor 1</li><li><code>bt2::Float = 0.6</code> : backtracking factor 2</li><li><code>pf1::Float = 0.4</code> : press forward factor 1</li><li><code>pf2::Float = 0.5</code> : press forward factor 2</li><li><code>btw::Float = 0.6</code> : backtracking factor for wake</li><li><code>pfw::Float = 1.2</code> : press forward factor for wake</li></ul>) : parameters for determining relaxation level of states in each iteration.</li><li><code>converged::AbstractArray{Bool} = [false]</code> : flag to track if convergence took place.</li><li><code>iterations::AbstractArray{Int} = [0]</code> : iteration counter</li><li><code>residuals::AbstractArray{Float} = [-1.0]</code> : final residual values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L264-L284">source</a></section></article><p>The other methods are implemented via external dependencies and some do better than others. In our experience, the other strictly fixed-point methods work relatively well, but are middle of the road.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.SpeedMappingOptions" href="#DuctAPE.SpeedMappingOptions"><code>DuctAPE.SpeedMappingOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SpeedMappingOptions &lt;: ExternalSolverOptions</code></pre><p>Options for the SpeedMapping.jl package solver</p><p><strong>Fields</strong></p><ul><li><code>orders::AbstractArray{Int} = [3, 2]</code></li><li><code>sig_min::Int = 0</code> : maybe set to 1?</li><li><code>stabilize::Bool = false</code> : stabilizes before extrapolation</li><li><code>check_obj::Bool = false</code> : checks for inf&#39;s and nan&#39;s and starts from previous finite point</li><li><code>atol::Float = 1e-10</code> : absolute convergence tolerance</li><li><code>iteration_limit::Float = 1000</code> : maximum number of iterations</li><li><code>time_limit::Float = Inf</code> : time limit in seconds</li><li><code>lower::Float = nothing</code> : box lower bounds</li><li><code>upper::Float = nothing</code> : box upper bounds</li><li><code>buffer::Float = 0.01</code> : if using bounds, buffer brings x inside bounds by buffer amountd</li><li><code>Lp::Float = Inf</code> : p value for p-norm for convergence criteria</li><li><code>converged::AbstractArray{Bool} = [false]</code> : flag to track if convergence took place.</li><li><code>iterations::AbstractArray{Int} = [0]</code> : iteration counter</li><li><code>residuals::AbstractArray{Float} = [-1.0]</code> : final residual values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L344-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.FixedPointOptions" href="#DuctAPE.FixedPointOptions"><code>DuctAPE.FixedPointOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FixedPointOptions &lt;: ExternalSolverOptions</code></pre><p>Options for the FixedPoint.jl package solver</p><p><strong>Fields</strong></p><ul><li><code>iteration_limit::Int = 1000</code> : maximum number of iterations</li><li><code>vel::Float = 0.9</code> : vel keyword argument, default is package default</li><li><code>ep::Float = 0.01</code> : ep keyword argument, default is package default</li><li><code>atol::Float = 1e-12</code> : absolute convergence tolerance</li><li><code>converged::AbstractArray{Bool} = [false]</code> : flag to track if convergence took place.</li><li><code>iterations::AbstractArray{Int} = [0]</code> : iteration counter</li><li><code>residuals::AbstractArray{Float} = [-1.0]</code> : final residual values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L320-L333">source</a></section></article><p>The quasi-Newton methods are hit or miss, with Minpack doing well enough to make it into some of the compound solver options discussed below, but we have had very little success wth SIAMFANLEquations up to this point.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.MinpackOptions" href="#DuctAPE.MinpackOptions"><code>DuctAPE.MinpackOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MinpackOptions &lt;: ExternalSolverOptions</code></pre><p>Options for the MINPACK&#39;s HYBRJ solver</p><p><strong>Fields</strong></p><ul><li><code>algorithm::Symbol = :hybr</code> : algorithm to use in MINPACK.jl (hybr is HYBRJ when the jacobian is provided)</li><li><code>atol::FLoat = 1e-10</code> : absolute convergence tolerance</li><li><code>iteration_limit::FLoat = 100</code> : maximum number of iterations</li><li><code>converged::AbstractArray{Bool} = [false]</code> : flag to track if convergence took place.</li><li><code>iterations::AbstractArray{Int} = [0]</code> : iteration counter</li><li><code>residuals::AbstractArray{Float} = [-1.0]</code> : final residual values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L384-L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.SIAMFANLEOptions" href="#DuctAPE.SIAMFANLEOptions"><code>DuctAPE.SIAMFANLEOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SIAMFANLEOptions &lt;: ExternalSolverOptions</code></pre><p>Options for the SIAMFANLEquations pacakge solvers</p><p><strong>Fields</strong></p><ul><li><code>algorithm::SIAMFANLEquations algorithm = SIAMFANLEquations.nsoli</code> : algorithm to use</li><li><code>rtol::Float = 0.0</code> : relative convergence tolerance</li><li><code>atol::Float = 1e-10</code> : absolute convergence tolerance</li><li><code>iteration_limit::Int = 1000</code> : maximum number of iterations</li><li><code>linear_iteration_limit::Float = 5</code> : maximum number of linear solve iterations (GMRES)</li><li><code>additional_kwargs = (;)</code> : any additional keyword arguments for the solver</li><li><code>converged::AbstractArray{Bool} = [false]</code> : flag to track if convergence took place.</li><li><code>iterations::AbstractArray{Int} = [0]</code> : iteration counter</li><li><code>residuals::AbstractArray{Float} = [-1.0]</code> : final residual values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L406-L421">source</a></section></article><p>NonlinearSolve is generally faster than NLsolve if the problem is large enough, but we find it to be significantly less robust.  NLsolve&#39;s Anderson method is perhaps the best external method in terms of speed and robustness, but is just barely edged out by the CSOR methods.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.NLsolveOptions" href="#DuctAPE.NLsolveOptions"><code>DuctAPE.NLsolveOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct NLsolveOptions &lt;: ExternalSolverOptions</code></pre><p>Options for the NLsolve pacakge solvers</p><p><strong>Fields</strong></p><ul><li><code>algorithm::Symbol = :anderson</code> : algorithm to use</li><li><code>additional_kwargs = (;)</code> : any additional keyword arguments for the solver</li><li><code>atol::Float = 1e-12</code> : absolute convergence tolerance</li><li><code>iteration_limit::Int = 25</code> : maximum number of iterations</li><li><code>linesearch_method::LineSearches method = LineSearches.MoreThuente</code> : line search method to use</li><li><code>linesearch_kwargs = (;)</code> : any additional lineseach keyword arguments</li><li><code>converged::AbstractArray{Bool} = [false]</code> : flag to track if convergence took place.</li><li><code>iterations::AbstractArray{Int} = [0]</code> : iteration counter</li><li><code>residuals::AbstractArray{Float} = [-1.0]</code> : final residual values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L464-L479">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.NonlinearSolveOptions" href="#DuctAPE.NonlinearSolveOptions"><code>DuctAPE.NonlinearSolveOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct NonlinearSolveOptions &lt;: ExternalSolverOptions</code></pre><p>Options for the SimpleNonlinearSolve pacakge solvers</p><p><strong>Fields</strong></p><ul><li><code>algorithm::SimpleNonlinearSolve algorithm = SimpleNonlinearSolve.SimpleNewtonRaphson</code> : algorithm to use</li><li><code>additional_kwargs = (;)</code> : any additional keyword arguments for the solver</li><li><code>atol::Float = 1e-12</code> : absolute convergence tolerance</li><li><code>iteration_limit::Float = 25</code> : maximum number of iterations</li><li><code>converged::AbstractArray{Bool} = [false]</code> : flag to track if convergence took place.</li><li><code>iterations::AbstractArray{Int} = [0]</code> : iteration counter</li><li><code>residuals::AbstractArray{Float} = [-1.0]</code> : final residual values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L438-L451">source</a></section></article><p>Finally, there are several compound solve methods implemented, the first chaining solvers together.  The solver chain can be defined as the user wishes, but the defaults start with the fixed-point Anderson method, move to the Minpack quasi-Newton method if the fixed-point method doesn&#39;t converge in the given number of iterations, and then finishes with a full Newton method if the quasi-newton method doesn&#39;t converge. The other compound solver combines solvers in a composite manner, typically starting with a few iterations of a full Newton method to get the solver going in the right direction and then finishing with a fixed-point method. The <code>ChainSolverOptions</code> was at one point the default method, but once the modified CSOR method was developed, the compound solvers weren&#39;t used much. Note that due to the way the solvers are implemented and dispatched, it is currently not possible to mix and match the CSOR methods with any of the external package methods.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.ChainSolverOptions" href="#DuctAPE.ChainSolverOptions"><code>DuctAPE.ChainSolverOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ChainSolverOptions &lt;:ExternalPolyAlgorithmOptions</code></pre><p>Options for Chain Solvers (try one solver, if it doesn&#39;t converge, try another)</p><p><strong>Fields</strong></p><ul><li><code>solvers::AbstractArray{SolverOptionsType} = [       NLsolveOptions(; algorithm=:anderson, atol=1e-10),       MinpackOptions(; atol=1e-10),       NonlinearSolveOptions(;           algorithm=SimpleNonlinearSolve.SimpleNewtonRaphson,           atol=1e-12,           additional_kwargs=(; autodiff=SimpleNonlinearSolve.AutoForwardDiff()),       ),   ]</code> : Vector of solver options to use.</li><li><code>converged::AbstractArray{Bool} = [false]</code> : flag to track if convergence took place.</li><li><code>iterations::AbstractArray{Int} = [0]</code> : iteration counter</li><li><code>residuals::AbstractArray{Float} = [-1.0]</code> : final residual values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L521-L539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.CompositeSolverOptions" href="#DuctAPE.CompositeSolverOptions"><code>DuctAPE.CompositeSolverOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct CompositeSolverOptions &lt;: ExternalPolyAlgorithmOptions</code></pre><p>Options for Composite Solvers (start with a partial solve of one solve, then finish with another starting where the first left off).</p><p><strong>Fields</strong></p><ul><li><code>solvers::AbstractArray{SolverOptionsType} = [       NLsolveOptions(; algorithm=:newton, iteration_limit=3),       NLsolveOptions(; algorithm=:anderson, atol=1e-10),   ]</code> : Vector of solver options to use.</li><li><code>converged::AbstractArray{Bool} = [false]</code> : flag to track if convergence took place.</li><li><code>iterations::AbstractArray{Int} = [0]</code> : iteration counter</li><li><code>residuals::AbstractArray{Float} = [-1.0]</code> : final residual values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L495-L508">source</a></section></article><h4 id="Example-3"><a class="docs-heading-anchor" href="#Example-3">Example</a><a class="docs-heading-anchor-permalink" href="#Example-3" title="Permalink"></a></h4><pre><code class="language-julia hljs">using DuctAPE
using LineSearches

# Define settings for NLsolve&#39;s newton method
aero_solver_options = DuctAPE.NLsolveOptions(;
    algorithm=:newton,
    atol=1e-10,
    iteration_limit=30,
    linesearch_method=LineSearches.BackTracking, #don&#39;t include parentheses on method handle
    linesearch_kwargs=(; order=3, maxstep=1e6),
)

# set all the options
DuctAPE.set_options(; solver_options=aero_solver_options)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Options{Bool, DuctAPE.HeadsBoundaryLayerOptions{Bool, Float64, Float64, typeof(RK2), Int64, Float64, Float64, Float64, DuctAPE.RK, Nothing, Nothing}, Vector{Bool}, Float64, Vector{Int64}, Vector{String}, Vector{String}, DuctAPE.var&quot;#56#61&quot;, IntegrationOptions{GaussLegendre{Vector{Float64}, Vector{Float64}}, GaussLegendre{Vector{Float64}, Vector{Float64}}}, NLsolveOptions{Bool, Float64, Int64, UnionAll, @NamedTuple{order::Int64, maxstep::Float64}, Symbol}, GridSolverOptions{Bool, Float64, Int64, Symbol}}(false, true, [1], DuctAPE.var&quot;#56#61&quot;(), true, false, 0.05, 1.0e-15, 2.220446049250313e-15, IntegrationOptions{GaussLegendre{Vector{Float64}, Vector{Float64}}, GaussLegendre{Vector{Float64}, Vector{Float64}}}(GaussLegendre{Vector{Float64}, Vector{Float64}}([0.019855071751231856, 0.10166676129318664, 0.2372337950418355, 0.4082826787521751, 0.591717321247825, 0.7627662049581645, 0.8983332387068134, 0.9801449282487682], [0.05061426814518838, 0.11119051722668723, 0.15685332293894372, 0.18134189168918097, 0.18134189168918097, 0.15685332293894372, 0.11119051722668723, 0.05061426814518838]), GaussLegendre{Vector{Float64}, Vector{Float64}}([0.019855071751231856, 0.10166676129318664, 0.2372337950418355, 0.4082826787521751, 0.591717321247825, 0.7627662049581645, 0.8983332387068134, 0.9801449282487682], [0.05061426814518838, 0.11119051722668723, 0.15685332293894372, 0.18134189168918097, 0.18134189168918097, 0.15685332293894372, 0.11119051722668723, 0.05061426814518838])), DuctAPE.HeadsBoundaryLayerOptions{Bool, Float64, Float64, typeof(RK2), Int64, Float64, Float64, Float64, DuctAPE.RK, Nothing, Nothing}(false, true, true, false, 5000, 1.0e-6, nothing, nothing, 0.001, DuctAPE.RK(), DuctAPE.RK2, 3.0, 10, 10, 0.2, 0.2, false, 0.0, 0.0001, 0.0, false), Bool[0], [&quot;outputs.jl&quot;], false, [&quot;outs&quot;], GridSolverOptions{Bool, Float64, Int64, Symbol}(30, 3.0e-10, :newton, :forward, false, 3, Bool[0], [0], [0.0]), NLsolveOptions{Bool, Float64, Int64, UnionAll, @NamedTuple{order::Int64, maxstep::Float64}, Symbol}(:newton, 1.0e-10, 30, LineSearches.BackTracking, (order = 3, maxstep = 1.0e6), Bool[0], [0], [-1.0]), true)</code></pre><div class="admonition is-info" id="Iteration-Counters-b8ab8bed2dc829e1"><header class="admonition-header">Iteration Counters<a class="admonition-anchor" href="#Iteration-Counters-b8ab8bed2dc829e1" title="Permalink"></a></header><div class="admonition-body"><p>The <code>iterations</code> field (not to be confused with the <code>iterations_limit</code> field) in the solver options should generally not be changed.  They automatically save (in-place) the number of iterations the solver performs and can be accessed after the analysis is run.</p></div></div><hr/><h2 id="Postprocess-Options"><a class="docs-heading-anchor" href="#Postprocess-Options">Postprocess Options</a><a id="Postprocess-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Postprocess-Options" title="Permalink"></a></h2><p>Most of the postprocess options have to do with writing the outputs to files, with the default behavior being to not write anything.  These options can be useful for debugging purposes or saving outputs, though it is usually more efficient to manually save a select few outputs rather than all the outputs. The one option that is slightly more involved is the boundary layer options. Currently, only Head&#39;s method is fully implemented, but there has also been some development started on Green&#39;s method. The boundary layer options include choices regarding type of solver, with a simple 2nd-order Runge-Kutta method being the default (and appears to be best for optimization). There is also a 4th-order Runge-Kutta method implemented as well as the RadauIIA5 method from DifferentialEquations.jl which may be more accurate for single runs. Note that the default setting is to not run the boundary layer method. The <code>model_drag</code> option in the boundary layer options needs to be set to true if it is desired to include the drag model.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DuctAPE.HeadsBoundaryLayerOptions" href="#DuctAPE.HeadsBoundaryLayerOptions"><code>DuctAPE.HeadsBoundaryLayerOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct HeadsBoundaryLayerOptions</code></pre><p><strong>Fields:</strong></p><ul><li><code>model_drag::Bool=false</code> : flag to turn on viscous drag approximation</li><li><code>termiante::Bool=true</code> : flag to terminate solver when separation criteria is met.</li><li><code>return_last_max_shape_factor::Bool=true</code> : return the last maximum shape factor to avoid false drops near the trailing edge.</li><li><code>cutoff_Hsep::Bool=false</code> : Cutoff returned Hsep vector at separation criteria</li><li><code>n_steps::Int = Int(5e3)</code> : number of steps to use in boundary layer integration</li><li><code>first_step_size::Float = 1e-6</code> : size of first step in boundary layer integration</li><li><code>upper_step_size::Float=nothing</code> : uses fixed step size rather than total number of steps.</li><li><code>lower_step_size::Float=nothing</code> : uses fixed step size rather than total number of steps.</li><li><code>offset::Float = 1e-3</code> : size of offset for (where to initialize) boundary layer integration</li><li><code>solver_type::AbstractODESolverType=RK()</code> : type of ODE solver (RK() or DiffEq())</li><li><code>ode::Function=RK2</code> : solver to use for boundary layer integration (RadauIIA5, RK4, or RK2 available)</li><li><code>separation_criteria::Float=3.0</code> : value of H12 after which separation should happen.</li><li><code>separation_allowance_upper::Int=10</code> : upper side allowance for how many steps ahead of the trailing edge we&#39;ll allow separation without penalty</li><li><code>separation_allowance_lower::Int=10</code> : lower side allowance for how many steps ahead of the trailing edge we&#39;ll allow separation without penalty</li><li><code>separation_penalty_upper::Float=0.2</code> : upper side maximum penalty value for separation (at leading edge)</li><li><code>separation_penalty_lower::Float=0.2</code> : lower side maximum penalty value for separation (at leading edge)</li><li><code>apply_separation_penalty_to_rotor::Bool=false</code> : flag to apply separation penalty to rotor performance.</li><li><code>dy_eps::Float=0.0</code> : temporary development parameter.</li><li><code>H1_eps::Float=1e-4</code>: temporary development parameter.</li><li><code>H_eps::Float=0.0</code>: temporary development parameter.</li><li><code>verbose::Bool=false</code> : flag to print verbose statements each iterations (beware; it&#39;s a lot)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/DuctAPE.jl/blob/71603b5dce3622beb7597f4fa9746654ac552a2a/src/utilities/options.jl#L646-L671">source</a></section></article><h4 id="Example-4"><a class="docs-heading-anchor" href="#Example-4">Example</a><a class="docs-heading-anchor-permalink" href="#Example-4" title="Permalink"></a></h4><pre><code class="language-julia hljs">using DuctAPE

# Define Boundary Layer Settings
boundary_layer_options = DuctAPE.HeadsBoundaryLayerOptions(;
    model_drag=true,
    separation_penalty_upper=0.1,
    separation_penalty_lower=0.1,
    separation_allowance_upper=3,
    separation_allowance_lower=25,
)

# set all the options
DuctAPE.set_options(; boundary_layer_options=boundary_layer_options)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Options{Bool, DuctAPE.HeadsBoundaryLayerOptions{Bool, Float64, Float64, typeof(RK2), Int64, Float64, Float64, Float64, DuctAPE.RK, Nothing, Nothing}, Vector{Bool}, Float64, Vector{Int64}, Vector{String}, Vector{String}, DuctAPE.var&quot;#56#61&quot;, IntegrationOptions{GaussLegendre{Vector{Float64}, Vector{Float64}}, GaussLegendre{Vector{Float64}, Vector{Float64}}}, ModCSORSolverOptions{Bool, Float64, Int64, @NamedTuple{nrf::Float64, bt1::Float64, bt2::Float64, pf1::Float64, pf2::Float64, btw::Float64, pfw::Float64}}, GridSolverOptions{Bool, Float64, Int64, Symbol}}(false, true, [1], DuctAPE.var&quot;#56#61&quot;(), true, false, 0.05, 1.0e-15, 2.220446049250313e-15, IntegrationOptions{GaussLegendre{Vector{Float64}, Vector{Float64}}, GaussLegendre{Vector{Float64}, Vector{Float64}}}(GaussLegendre{Vector{Float64}, Vector{Float64}}([0.019855071751231856, 0.10166676129318664, 0.2372337950418355, 0.4082826787521751, 0.591717321247825, 0.7627662049581645, 0.8983332387068134, 0.9801449282487682], [0.05061426814518838, 0.11119051722668723, 0.15685332293894372, 0.18134189168918097, 0.18134189168918097, 0.15685332293894372, 0.11119051722668723, 0.05061426814518838]), GaussLegendre{Vector{Float64}, Vector{Float64}}([0.019855071751231856, 0.10166676129318664, 0.2372337950418355, 0.4082826787521751, 0.591717321247825, 0.7627662049581645, 0.8983332387068134, 0.9801449282487682], [0.05061426814518838, 0.11119051722668723, 0.15685332293894372, 0.18134189168918097, 0.18134189168918097, 0.15685332293894372, 0.11119051722668723, 0.05061426814518838])), DuctAPE.HeadsBoundaryLayerOptions{Bool, Float64, Float64, typeof(RK2), Int64, Float64, Float64, Float64, DuctAPE.RK, Nothing, Nothing}(true, true, true, false, 5000, 1.0e-6, nothing, nothing, 0.001, DuctAPE.RK(), DuctAPE.RK2, 3.0, 3, 25, 0.1, 0.1, false, 0.0, 0.0001, 0.0, false), Bool[0], [&quot;outputs.jl&quot;], false, [&quot;outs&quot;], GridSolverOptions{Bool, Float64, Int64, Symbol}(30, 3.0e-10, :newton, :forward, false, 3, Bool[0], [0], [0.0]), ModCSORSolverOptions{Bool, Float64, Int64, @NamedTuple{nrf::Float64, bt1::Float64, bt2::Float64, pf1::Float64, pf2::Float64, btw::Float64, pfw::Float64}}(false, 500, (nrf = 0.4, bt1 = 0.2, bt2 = 0.6, pf1 = 0.4, pf2 = 0.5, btw = 0.6, pfw = 1.2), 5.0e-10, Bool[0], [0], [-1.0]), true)</code></pre><hr/><h1 id="Advanced-Options-for-Multi-point-analyses"><a class="docs-heading-anchor" href="#Advanced-Options-for-Multi-point-analyses">Advanced Options for Multi-point analyses</a><a id="Advanced-Options-for-Multi-point-analyses-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Options-for-Multi-point-analyses" title="Permalink"></a></h1><p>For using advanced options in multi-point analyses, there are various changes that need to be made to avoid run-time errors. Here is an example for setting options with the CSOR solver.</p><pre><code class="language-julia hljs">using DuctAPE

# number of operating points to analyze
nop = 3

options = DuctAPE.set_options(;
    solver_options=DuctAPE.ModCSORSolverOptions(;
        converged=fill(false, (1, nop)), # need a convergence flag for each operating point
        iterations=zeros(Int, (1, nop)), # need a iteration count for each operating point
    ),
    write_outputs=fill(false, nop), # we need to know which of the operating point outputs to write
    outfile=fill(&quot;&quot;, nop), # we need to include names, even if they won&#39;t be used.
    output_tuple_name=fill(&quot;outs&quot;, nop), # we need to include names, even if they won&#39;t be used.
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Options{Bool, DuctAPE.HeadsBoundaryLayerOptions{Bool, Float64, Float64, typeof(RK2), Int64, Float64, Float64, Float64, DuctAPE.RK, Nothing, Nothing}, Vector{Bool}, Float64, Vector{Int64}, Vector{String}, Vector{String}, DuctAPE.var&quot;#56#61&quot;, IntegrationOptions{GaussLegendre{Vector{Float64}, Vector{Float64}}, GaussLegendre{Vector{Float64}, Vector{Float64}}}, ModCSORSolverOptions{Bool, Float64, Int64, @NamedTuple{nrf::Float64, bt1::Float64, bt2::Float64, pf1::Float64, pf2::Float64, btw::Float64, pfw::Float64}}, GridSolverOptions{Bool, Float64, Int64, Symbol}}(false, true, [1], DuctAPE.var&quot;#56#61&quot;(), true, false, 0.05, 1.0e-15, 2.220446049250313e-15, IntegrationOptions{GaussLegendre{Vector{Float64}, Vector{Float64}}, GaussLegendre{Vector{Float64}, Vector{Float64}}}(GaussLegendre{Vector{Float64}, Vector{Float64}}([0.019855071751231856, 0.10166676129318664, 0.2372337950418355, 0.4082826787521751, 0.591717321247825, 0.7627662049581645, 0.8983332387068134, 0.9801449282487682], [0.05061426814518838, 0.11119051722668723, 0.15685332293894372, 0.18134189168918097, 0.18134189168918097, 0.15685332293894372, 0.11119051722668723, 0.05061426814518838]), GaussLegendre{Vector{Float64}, Vector{Float64}}([0.019855071751231856, 0.10166676129318664, 0.2372337950418355, 0.4082826787521751, 0.591717321247825, 0.7627662049581645, 0.8983332387068134, 0.9801449282487682], [0.05061426814518838, 0.11119051722668723, 0.15685332293894372, 0.18134189168918097, 0.18134189168918097, 0.15685332293894372, 0.11119051722668723, 0.05061426814518838])), DuctAPE.HeadsBoundaryLayerOptions{Bool, Float64, Float64, typeof(RK2), Int64, Float64, Float64, Float64, DuctAPE.RK, Nothing, Nothing}(false, true, true, false, 5000, 1.0e-6, nothing, nothing, 0.001, DuctAPE.RK(), DuctAPE.RK2, 3.0, 10, 10, 0.2, 0.2, false, 0.0, 0.0001, 0.0, false), Bool[0, 0, 0], [&quot;&quot;, &quot;&quot;, &quot;&quot;], false, [&quot;outs&quot;, &quot;outs&quot;, &quot;outs&quot;], GridSolverOptions{Bool, Float64, Int64, Symbol}(30, 3.0e-10, :newton, :forward, false, 3, Bool[0], [0], [0.0]), ModCSORSolverOptions{Bool, Float64, Int64, @NamedTuple{nrf::Float64, bt1::Float64, bt2::Float64, pf1::Float64, pf2::Float64, btw::Float64, pfw::Float64}}(false, 500, (nrf = 0.4, bt1 = 0.2, bt2 = 0.6, pf1 = 0.4, pf2 = 0.5, btw = 0.6, pfw = 1.2), 5.0e-10, Bool[0 0 0], [0 0 0], [-1.0]), true)</code></pre><p>If using a compound algorithm with a multi-point solve, then each of the solvers needs to have the multiple <code>converged</code> and <code>iterations</code> fields for each operating point, and the overall solve type needs to have a <code>converged</code> and <code>iterations</code> field for each solver and each operating point.</p><pre><code class="language-julia hljs">options = DuctAPE.set_options(;
    solver_options=DuctAPE.ChainSolverOptions(;
        solvers=[ # vector of solvers to use in poly-algorithm
            DuctAPE.NLsolveOptions(;
                algorithm=:anderson,
                atol=1e-12,
                iteration_limit=200,
                converged=fill(false, (1, nop)), # flags for each operating point
                iterations=zeros(Int, (1, nop)), # counters for each operating point
            ),
            DuctAPE.MinpackOptions(;
                atol=1e-12,
                iteration_limit=100,
                converged=fill(false, (1, nop)),
                iterations=zeros(Int, (1, nop)),
            ),
        ],
        converged=fill(false, (2, nop)), # flags for each solver and each operating point
        iterations=zeros(Int, (2, nop)), # counts for each solver and each operating point
    ),
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Options{Bool, DuctAPE.HeadsBoundaryLayerOptions{Bool, Float64, Float64, typeof(RK2), Int64, Float64, Float64, Float64, DuctAPE.RK, Nothing, Nothing}, Vector{Bool}, Float64, Vector{Int64}, Vector{String}, Vector{String}, DuctAPE.var&quot;#56#61&quot;, IntegrationOptions{GaussLegendre{Vector{Float64}, Vector{Float64}}, GaussLegendre{Vector{Float64}, Vector{Float64}}}, ChainSolverOptions{Bool, Int64, Float64, DuctAPE.ExternalSolverOptions}, GridSolverOptions{Bool, Float64, Int64, Symbol}}(false, true, [1], DuctAPE.var&quot;#56#61&quot;(), true, false, 0.05, 1.0e-15, 2.220446049250313e-15, IntegrationOptions{GaussLegendre{Vector{Float64}, Vector{Float64}}, GaussLegendre{Vector{Float64}, Vector{Float64}}}(GaussLegendre{Vector{Float64}, Vector{Float64}}([0.019855071751231856, 0.10166676129318664, 0.2372337950418355, 0.4082826787521751, 0.591717321247825, 0.7627662049581645, 0.8983332387068134, 0.9801449282487682], [0.05061426814518838, 0.11119051722668723, 0.15685332293894372, 0.18134189168918097, 0.18134189168918097, 0.15685332293894372, 0.11119051722668723, 0.05061426814518838]), GaussLegendre{Vector{Float64}, Vector{Float64}}([0.019855071751231856, 0.10166676129318664, 0.2372337950418355, 0.4082826787521751, 0.591717321247825, 0.7627662049581645, 0.8983332387068134, 0.9801449282487682], [0.05061426814518838, 0.11119051722668723, 0.15685332293894372, 0.18134189168918097, 0.18134189168918097, 0.15685332293894372, 0.11119051722668723, 0.05061426814518838])), DuctAPE.HeadsBoundaryLayerOptions{Bool, Float64, Float64, typeof(RK2), Int64, Float64, Float64, Float64, DuctAPE.RK, Nothing, Nothing}(false, true, true, false, 5000, 1.0e-6, nothing, nothing, 0.001, DuctAPE.RK(), DuctAPE.RK2, 3.0, 10, 10, 0.2, 0.2, false, 0.0, 0.0001, 0.0, false), Bool[0], [&quot;outputs.jl&quot;], false, [&quot;outs&quot;], GridSolverOptions{Bool, Float64, Int64, Symbol}(30, 3.0e-10, :newton, :forward, false, 3, Bool[0], [0], [0.0]), ChainSolverOptions{Bool, Int64, Float64, DuctAPE.ExternalSolverOptions}(DuctAPE.ExternalSolverOptions[NLsolveOptions{Bool, Float64, Int64, UnionAll, @NamedTuple{}, Symbol}(:anderson, 1.0e-12, 200, LineSearches.MoreThuente, NamedTuple(), Bool[0 0 0], [0 0 0], [-1.0]), MinpackOptions{Bool, Float64, Int64, Symbol}(:hybr, 1.0e-12, 100, Bool[0 0 0], [0 0 0], [-1.0])], Bool[0 0 0; 0 0 0], [0 0 0; 0 0 0], [-1.0]), true)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../inputs/">« Required Inputs</a><a class="docs-footer-nextpage" href="../caches/">Precompiled Caches »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Saturday 25 October 2025 15:45">Saturday 25 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
